{"meta":{"title":"轩辕Rowboat的博客","subtitle":"前端路上 | PPT爱好者 | 所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。","description":"轩辕Rowboat，某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。","author":"轩辕Rowboat","url":"https://lxchuan12.github.io"},"pages":[{"title":"tags","date":"2016-08-29T14:57:25.000Z","updated":"2016-08-29T14:58:46.028Z","comments":false,"path":"tags/index.html","permalink":"https://lxchuan12.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试官问：能否模拟实现JS的call和apply方法","slug":"20181130-Function.prototype.call-apply","date":"2018-11-30T13:38:51.000Z","updated":"2018-12-06T12:35:32.916Z","comments":true,"path":"2018/11/30/20181130-Function.prototype.call-apply/","link":"","permalink":"https://lxchuan12.github.io/2018/11/30/20181130-Function.prototype.call-apply/","excerpt":"","text":"之前写过两篇《面试官问：能否模拟实现JS的new操作符》和《面试官问：能否模拟实现JS的bind方法》 其中模拟bind方法时是使用的call和apply修改this指向。但面试官可能问：能否不用call和apply来实现呢。意思也就是需要模拟实现call和apply的了。 附上之前写文章写过的一段话：已经有很多模拟实现call和apply的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。 先通过MDN认识下call和applyMDN 文档：Function.prototype.call()语法1fun.call(thisArg, arg1, arg2, ...) thisArg在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。arg1, arg2, …指定的参数列表返回值返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。 MDN 文档：Function.prototype.apply()1func.apply(thisArg, [argsArray]) thisArg可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。argsArray可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。返回值调用有指定this值和参数的函数的结果。直接先看例子1 call 和 apply 的异同相同点：1、call和apply的第一个参数thisArg，都是func运行时指定的this。而且，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。2、都可以只传递一个参数。不同点：apply只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计。call接收第二个及以后一系列的参数。看两个简单例子1和2**：12345678910// 例子1：浏览器环境 非严格模式下var doSth = function(a, b)&#123; console.log(this); console.log([a, b]);&#125;doSth.apply(null, [1, 2]); // this是window // [1, 2]doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]doSth.call(undefined, 1, 2); // this 是 window // [1, 2]doSth.call(&apos;0&apos;, 1, &#123;a: 1&#125;); // this 是 String(&apos;0&apos;) // [1, &#123;a: 1&#125;] 123456789// 例子2：浏览器环境 严格模式下&apos;use strict&apos;;var doSth2 = function(a, b)&#123; console.log(this); console.log([a, b]);&#125;doSth2.call(0, 1, 2); // this 是 0 // [1, 2]doSth2.apply(&apos;1&apos;); // this 是 &apos;1&apos; // [undefined, undefined]doSth2.apply(null, [1, 2]); // this 是 null // [1, 2] typeof 有7种类型（undefined number string boolean symbol object function），笔者都验证了一遍：更加验证了相同点第一点，严格模式下，函数的this值就是call和apply的第一个参数thisArg，非严格模式下，thisArg值被指定为 null 或 undefined 时this值会自动替换为指向全局对象，原始值则会被自动包装，也就是new Object()。 重新认识了call和apply会发现：它们作用都是一样的，改变函数里的this指向为第一个参数thisArg，如果明确有多少参数，那可以用call，不明确则可以使用apply。也就是说完全可以不使用call，而使用apply代替。也就是说，我们只需要模拟实现apply，call可以根据参数个数都放在一个数组中，给到apply即可。 模拟实现 apply既然准备模拟实现apply，那先得看看ES5规范。ES5规范 英文版，ES5规范 中文版。apply的规范下一个就是call的规范，可以点击打开新标签页去查看，这里摘抄一部分。 Function.prototype.apply (thisArg, argArray) 当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤： 1.如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。2.如果 argArray 是 null 或 undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。3.返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。4.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常。5~8 略9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。 apply 方法的 length 属性是 2。 在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。 结合上文和规范，如何将函数里的this指向第一个参数thisArg呢，这是一个问题。这时候请出例子3：123456789101112// 浏览器环境 非严格模式下var doSth = function(a, b)&#123; console.log(this); console.log(this.name); console.log([a, b]);&#125;var student = &#123; name: &apos;轩辕Rowboat&apos;, doSth: doSth,&#125;;student.doSth(1, 2); // this === student // true // &apos;轩辕Rowboat&apos; // [1, 2]doSth.apply(student, [1, 2]); // this === student // true // &apos;轩辕Rowboat&apos; // [1, 2] 可以得出结论1：在对象student上加一个函数doSth，再执行这个函数，这个函数里的this就指向了这个对象。那也就是可以在thisArg上新增调用函数，执行后删除这个函数即可。知道这些后，我们试着容易实现第一版本： 123456789101112131415161718192021222324252627282930313233343536// 浏览器环境 非严格模式function getGlobalObject()&#123; return this;&#125;Function.prototype.applyFn = function apply(thisArg, argsArray)&#123; // `apply` 方法的 `length` 属性是 `2`。 // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。 if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos; is not a function&apos;); &#125; // 2.如果 argArray 是 null 或 undefined, 则 // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。 if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123; argsArray = []; &#125; // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 . if(argsArray !== new Object(argsArray))&#123; throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;); &#125; if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123; // 在外面传入的 thisArg 值会修改并成为 this 值。 // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window thisArg = getGlobalObject(); &#125; // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。 thisArg = new Object(thisArg); var __fn = &apos;__fn&apos;; thisArg[__fn] = this; // 9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果 var result = thisArg[__fn](...argsArray); delete thisArg[__fn]; return result;&#125;; 实现第一版后，很容易找出两个问题： [ ] 1.__fn 同名覆盖问题，thisArg对象上有__fn，那就被覆盖了然后被删除了。 针对问题1解决方案一：采用ES6 Sybmol() 独一无二的。可以本来就是模拟ES3的方法。如果面试官不允许用呢。解决方案二：自己用Math.random()模拟实现独一无二的key。面试时可以直接用生成时间戳即可。1234567891011121314151617// 生成UUID 通用唯一识别码// 大概生成 这样一串 &apos;18efca2d-6e25-42bf-a636-30b8f9f2de09&apos;function generateUUID()&#123; var i, random; var uuid = &apos;&apos;; for (i = 0; i &lt; 32; i++) &#123; random = Math.random() * 16 | 0; if (i === 8 || i === 12 || i === 16 || i === 20) &#123; uuid += &apos;-&apos;; &#125; uuid += (i === 12 ? 4 : (i === 16 ? (random &amp; 3 | 8) : random)) .toString(16); &#125; return uuid;&#125;// 简单实现// &apos;__&apos; + new Date().getTime(); 如果这个key万一这对象中还是有，为了保险起见，可以做一次缓存操作。比如如下代码：12345678910111213var student = &#123; name: &apos;轩辕Rowboat&apos;, doSth: &apos;doSth&apos;,&#125;;var originalVal = student.doSth;var hasOriginalVal = student.hasOwnProperty(&apos;doSth&apos;);student.doSth = function()&#123;&#125;;delete student.doSth;// 如果没有，`originalVal`则为undefined，直接赋值新增了一个undefined，这是不对的，所以需判断一下。if(hasOriginalVal)&#123; student.doSth = originalVal;&#125;console.log(&apos;student:&apos;, student); // &#123; name: &apos;轩辕Rowboat&apos;, doSth: &apos;doSth&apos; &#125; [ ] 2.使用了ES6扩展符...解决方案一：采用eval来执行函数。 eval把字符串解析成代码执行。MDN 文档：eval语法 1eval(string) 参数string表示JavaScript表达式，语句或一系列语句的字符串。表达式可以包含变量以及已存在对象的属性。返回值执行指定代码之后的返回值。如果返回值为空，返回undefined解决方案二：但万一面试官不允许用eval呢，毕竟eval是魔鬼。可以采用new Function()来生成执行函数。MDN 文档：Function语法1new Function ([arg1[, arg2[, ...argN]],] functionBody) 参数arg1, arg2, … argN被函数使用的参数的名称必须是合法命名的。参数名称是一个有效的JavaScript标识符的字符串，或者一个用逗号分隔的有效字符串的列表;例如“×”，“theValue”，或“A，B”。functionBody一个含有包括函数定义的JavaScript语句的字符串。接下来看两个例子：123简单例子：var sum = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a + b&apos;);console.log(sum(2, 6)); 12345678910111213141516171819202122232425// 稍微复杂点的例子：var student = &#123; name: &apos;轩辕Rowboat&apos;, doSth: function(argsArray)&#123; console.log(argsArray); console.log(this.name); &#125;&#125;;// var result = student.doSth([&apos;Rowboat&apos;, 18]);// 用new Function()生成函数并执行返回结果var result = new Function(&apos;return arguments[0][arguments[1]](arguments[2][0], arguments[2][1])&apos;)(student, &apos;doSth&apos;, [&apos;Rowboat&apos;, 18]);// 个数不定// 所以可以写一个函数生成函数代码：function generateFunctionCode(argsArrayLength)&#123; var code = &apos;return arguments[0][arguments[1]](&apos;; for(var i = 0; i &lt; argsArrayLength; i++)&#123; if(i &gt; 0)&#123; code += &apos;,&apos;; &#125; code += &apos;arguments[2][&apos; + i + &apos;]&apos;; &#125; code += &apos;)&apos;; // return arguments[0][arguments[1]](arg1, arg2, arg3...) return code;&#125; 你可能不知道在ES3、ES5中 undefined 是能修改的可能大部分人不知道。ES5中虽然在全局作用域下不能修改，但在局部作用域中也是能修改的，不信可以复制以下测试代码在控制台执行下。虽然一般情况下是不会的去修改它。12345function test()&#123; var undefined = 3; console.log(undefined); // chrome下也是 3&#125;test(); 所以判断一个变量a是不是undefined，更严谨的方案是typeof a === &#39;undefined&#39;或者a === void 0;这里面用的是void，void的作用是计算表达式，始终返回undefined，也可以这样写void(0)。更多可以查看韩子迟的这篇文章：为什么用「void 0」代替「undefined」解决了这几个问题，比较容易实现如下代码。 使用 new Function() 模拟实现的apply123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 浏览器环境 非严格模式function getGlobalObject()&#123; return this;&#125;function generateFunctionCode(argsArrayLength)&#123; var code = &apos;return arguments[0][arguments[1]](&apos;; for(var i = 0; i &lt; argsArrayLength; i++)&#123; if(i &gt; 0)&#123; code += &apos;,&apos;; &#125; code += &apos;arguments[2][&apos; + i + &apos;]&apos;; &#125; code += &apos;)&apos;; // return arguments[0][arguments[1]](arg1, arg2, arg3...) return code;&#125;Function.prototype.applyFn = function apply(thisArg, argsArray)&#123; // `apply` 方法的 `length` 属性是 `2`。 // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。 if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos; is not a function&apos;); &#125; // 2.如果 argArray 是 null 或 undefined, 则 // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。 if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123; argsArray = []; &#125; // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 . if(argsArray !== new Object(argsArray))&#123; throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;); &#125; if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123; // 在外面传入的 thisArg 值会修改并成为 this 值。 // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window thisArg = getGlobalObject(); &#125; // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。 thisArg = new Object(thisArg); var __fn = &apos;__&apos; + new Date().getTime(); // 万一还是有 先存储一份，删除后，再恢复该值 var originalVal = thisArg[__fn]; // 是否有原始值 var hasOriginalVal = thisArg.hasOwnProperty(__fn); thisArg[__fn] = this; // 9.提供 `thisArg` 作为 `this` 值并以 `argList` 作为参数列表，调用 `func` 的 `[[Call]]` 内部方法，返回结果。 // ES6版 // var result = thisArg[__fn](...args); var code = generateFunctionCode(argsArray.length); var result = (new Function(code))(thisArg, __fn, argsArray); delete thisArg[__fn]; if(hasOriginalVal)&#123; thisArg[__fn] = originalVal; &#125; return result;&#125;; 利用模拟实现的apply模拟实现call12345678910111213141516171819202122232425262728293031323334Function.prototype.callFn = function call(thisArg)&#123; var argsArray = []; var argumentsLength = arguments.length; for(var i = 0; i &lt; argumentsLength - 1; i++)&#123; // argsArray.push(arguments[i + 1]); argsArray[i] = arguments[i + 1]; &#125; console.log(&apos;argsArray:&apos;, argsArray); return this.applyFn(thisArg, argsArray);&#125;// 测试例子var doSth = function (name, age)&#123; var type = Object.prototype.toString.call(this); console.log(typeof doSth); console.log(this === firstArg); console.log(&apos;type:&apos;, type); console.log(&apos;this:&apos;, this); console.log(&apos;args:&apos;, [name, age], arguments); return &apos;this--&apos;;&#125;;var name = &apos;window&apos;;var student = &#123; name: &apos;轩辕Rowboat&apos;, age: 18, doSth: &apos;doSth&apos;, __fn: &apos;doSth&apos;,&#125;;var firstArg = student;var result = doSth.applyFn(firstArg, [1, &#123;name: &apos;Rowboat&apos;&#125;]);var result2 = doSth.callFn(firstArg, 1, &#123;name: &apos;Rowboat&apos;&#125;);console.log(&apos;result:&apos;, result);console.log(&apos;result2:&apos;, result2); 细心的你会发现注释了这一句argsArray.push(arguments[i + 1]);，事实上push方法，内部也有一层循环。所以理论上不使用push性能会更好些。面试官也可能根据这点来问时间复杂度和空间复杂度的问题。12345678910// 看看V8引擎中的具体实现：function ArrayPush() &#123; var n = TO_UINT32( this.length ); // 被push的对象的length var m = %_ArgumentsLength(); // push的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[ i + n ] = %_Arguments( i ); // 复制元素 (1) &#125; this.length = n + m; // 修正length属性的值 (2) return this.length;&#125;; 行文至此，就基本结束了，你可能还发现就是写的非严格模式下，thisArg原始值会包装成对象，添加函数并执行，再删除。而严格模式下还是原始值这个没有实现，而且万一这个对象是冻结对象呢，Object.freeze({})，是无法在这个对象上添加属性的。所以这个方法只能算是非严格模式下的简版实现。最后来总结一下。 总结通过MDN认识call和apply，阅读ES5规范，到模拟实现apply，再实现call。就是使用在对象上添加调用apply的函数执行，这时的调用函数的this就指向了这个thisArg，再返回结果。引出了ES6 Symbol，ES6的扩展符...、eval、new Function()，严格模式等。事实上，现实业务场景不需要去模拟实现call和apply,毕竟是ES3就提供的方法。但面试官可以通过这个面试题考察候选人很多基础知识。如：call、apply的使用。ES6 Symbol，ES6的扩展符...，eval，new Function()，严格模式，甚至时间复杂度和空间复杂度等。读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 最终版版 删除注释版，详细注释看文章// 浏览器环境 非严格模式function getGlobalObject()&#123; return this;&#125;function generateFunctionCode(argsArrayLength)&#123; var code = &apos;return arguments[0][arguments[1]](&apos;; for(var i = 0; i &lt; argsArrayLength; i++)&#123; if(i &gt; 0)&#123; code += &apos;,&apos;; &#125; code += &apos;arguments[2][&apos; + i + &apos;]&apos;; &#125; code += &apos;)&apos;; return code;&#125;Function.prototype.applyFn = function apply(thisArg, argsArray)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos; is not a function&apos;); &#125; if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123; argsArray = []; &#125; if(argsArray !== new Object(argsArray))&#123; throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;); &#125; if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123; thisArg = getGlobalObject(); &#125; thisArg = new Object(thisArg); var __fn = &apos;__&apos; + new Date().getTime(); var originalVal = thisArg[__fn]; var hasOriginalVal = thisArg.hasOwnProperty(__fn); thisArg[__fn] = this; var code = generateFunctionCode(argsArray.length); var result = (new Function(code))(thisArg, __fn, argsArray); delete thisArg[__fn]; if(hasOriginalVal)&#123; thisArg[__fn] = originalVal; &#125; return result;&#125;;Function.prototype.callFn = function call(thisArg)&#123; var argsArray = []; var argumentsLength = arguments.length; for(var i = 0; i &lt; argumentsLength - 1; i++)&#123; argsArray[i] = arguments[i + 1]; &#125; return this.applyFn(thisArg, argsArray);&#125; 扩展阅读《JavaScript设计模式与开发实践》- 第二章 第 2 章 this、call和applyJS魔法堂：再次认识Function.prototype.call不用call和apply方法模拟实现ES5的bind方法JavaScript深入之call和apply的模拟实现 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://lxchuan12.github.io/tags/面试/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"面试官问：能否模拟实现JS的bind方法","slug":"20181121-Function.prototype.bind","date":"2018-11-21T12:31:50.000Z","updated":"2018-11-30T13:50:48.163Z","comments":true,"path":"2018/11/21/20181121-Function.prototype.bind/","link":"","permalink":"https://lxchuan12.github.io/2018/11/21/20181121-Function.prototype.bind/","excerpt":"","text":"前言用过React的同学都知道，经常会使用bind来绑定this。12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;class TodoItem extends Component&#123; constructor(props)&#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick()&#123; console.log(&apos;handleClick&apos;); &#125; render()&#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;点击&lt;/div&gt; ); &#125;;&#125;export default TodoItem; 那么面试官可能会问是否想过bind到底做了什么，怎么模拟实现呢。 附上之前写文章写过的一段话：已经有很多模拟实现bind的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。 先看一下bind是什么。从上面的React代码中，可以看出bind执行后是函数，并且每个函数都可以执行调用它。眼见为实，耳听为虚。读者可以在控制台一步步点开例子1中的obj:123456var obj = &#123;&#125;;console.log(obj);console.log(typeof Function.prototype.bind); // functionconsole.log(typeof Function.prototype.bind()); // functionconsole.log(Function.prototype.bind.name); // bindconsole.log(Function.prototype.bind().name); // bound `Function.prototype.bind` 因此可以得出结论1：1、bind是Functoin原型链中Function.prototype的一个属性，每个函数都可以调用它。2、bind本身是一个函数名为bind的函数，返回值也是函数，函数名是bound。（打出来就是bound加上一个空格）。知道了bind是函数，就可以传参，而且返回值&#39;bound &#39;也是函数，也可以传参，就很容易写出例子2：后文统一 bound 指原函数original bind之后返回的函数，便于说明。1234567891011121314151617var obj = &#123; name: &apos;轩辕Rowboat&apos;,&#125;;function original(a, b)&#123; console.log(this.name); console.log([a, b]); return false;&#125;var bound = original.bind(obj, 1);var boundResult = bound(2); // &apos;轩辕Rowboat&apos;, [1, 2]console.log(boundResult); // falseconsole.log(original.bind.name); // &apos;bind&apos;console.log(original.bind.length); // 1console.log(original.bind().length); // 2 返回original函数的形参个数console.log(bound.name); // &apos;bound original&apos;console.log((function()&#123;&#125;).bind().name); // &apos;bound &apos;console.log((function()&#123;&#125;).bind().length); // 0 由此可以得出结论2：1、调用bind的函数中的this指向bind()函数的第一个参数。 2、传给bind()的其他参数接收处理了，bind()之后返回的函数的参数也接收处理了，也就是说合并处理了。 3、并且bind()后的name为bound + 空格 + 调用bind的函数名。如果是匿名函数则是bound + 空格。 4、bind后的返回值函数，执行后返回值是原函数（original）的返回值。 5、bind函数形参（即函数的length）是1。bind后返回的bound函数形参不定，根据绑定的函数原函数（original）形参个数确定。 根据结论2：我们就可以简单模拟实现一个简版bindFn123456789101112131415161718192021222324252627// 第一版 修改this指向，合并参数Function.prototype.bindFn = function bind(thisArg)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos;must be a function&apos;); &#125; // 存储函数本身 var self = this; // 去除thisArg的其他参数 转成数组 var args = [].slice.call(arguments, 1); var bound = function()&#123; // bind返回的函数 的参数转成数组 var boundArgs = [].slice.call(arguments); // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, args.concat(boundArgs)); &#125; return bound;&#125;// 测试var obj = &#123; name: &apos;轩辕Rowboat&apos;,&#125;;function original(a, b)&#123; console.log(this.name); console.log([a, b]);&#125;var bound = original.bindFn(obj, 1);bound(2); // &apos;轩辕Rowboat&apos;, [1, 2] 如果面试官看到你答到这里，估计对你的印象60、70分应该是会有的。但我们知道函数是可以用new来实例化的。那么bind()返回值函数会是什么表现呢。接下来看例子3：1234567891011121314var obj = &#123; name: &apos;轩辕Rowboat&apos;,&#125;;function original(a, b)&#123; console.log(&apos;this&apos;, this); // original &#123;&#125; console.log(&apos;typeof this&apos;, typeof this); // object this.name = b; console.log(&apos;name&apos;, this.name); // 2 console.log(&apos;this&apos;, this); // original &#123;name: 2&#125; console.log([a, b]); // 1, 2&#125;var bound = original.bind(obj, 1);var newBoundResult = new bound(2);console.log(newBoundResult, &apos;newBoundResult&apos;); // original &#123;name: 2&#125; 从例子3种可以看出this指向了new bound()生成的新对象。 可以分析得出结论3：1、bind原先指向obj的失效了，其他参数有效。 2、new bound的返回值是以original原函数构造器生成的新对象。original原函数的this指向的就是这个新对象。另外前不久写过一篇文章：面试官问：能否模拟实现JS的new操作符。简单摘要：new做了什么： 1.创建了一个全新的对象。2.这个对象会被执行[[Prototype]]（也就是__proto__）链接。3.生成的新对象会绑定到函数调用的this。4.通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 所以相当于new调用时，bind的返回值函数bound内部要模拟实现new实现的操作。话不多说，直接上代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 第三版 实现new调用Function.prototype.bindFn = function bind(thisArg)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos; must be a function&apos;); &#125; // 存储调用bind的函数本身 var self = this; // 去除thisArg的其他参数 转成数组 var args = [].slice.call(arguments, 1); var bound = function()&#123; // bind返回的函数 的参数转成数组 var boundArgs = [].slice.call(arguments); var finalArgs = args.concat(boundArgs); // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。 if(this instanceof bound)&#123; // 这里是实现上文描述的 new 的第 1, 2, 4 步 // 1.创建一个全新的对象 // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。 if(self.prototype)&#123; // ES5 提供的方案 Object.create() // bound.prototype = Object.create(self.prototype); // 但 既然是模拟ES5的bind，那浏览器也基本没有实现Object.create() // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create function Empty()&#123;&#125; Empty.prototype = self.prototype; bound.prototype = new Empty(); &#125; // 这里是实现上文描述的 new 的第 3 步 // 3.生成的新对象会绑定到函数调用的`this`。 var result = self.apply(this, finalArgs); // 这里是实现上文描述的 new 的第 5 步 // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)， // 那么`new`表达式中的函数调用会自动返回这个新的对象。 var isObject = typeof result === &apos;object&apos; &amp;&amp; result !== null; var isFunction = typeof result === &apos;function&apos;; if(isObject || isFunction)&#123; return result; &#125; return this; &#125; else&#123; // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果 return self.apply(thisArg, finalArgs); &#125; &#125;; return bound;&#125; 面试官看到这样的实现代码，基本就是满分了，心里独白：这小伙子/小姑娘不错啊。不过可能还会问this instanceof bound不准确问题。上文注释中提到this instanceof bound也不是很准确，ES6 new.target很好的解决这一问题，我们举个例子4: instanceof 不准确，ES6 new.target很好的解决这一问题12345678910111213141516171819202122232425function Student(name)&#123; if(this instanceof Student)&#123; this.name = name; console.log(&apos;name&apos;, name); &#125; else&#123; throw new Error(&apos;必须通过new关键字来调用Student。&apos;); &#125;&#125;var student = new Student(&apos;轩辕&apos;);var notAStudent = Student.call(student, &apos;Rowboat&apos;); // 不抛出错误，且执行了。console.log(student, &apos;student&apos;, notAStudent, &apos;notAStudent&apos;);function Student2(name)&#123; if(typeof new.target !== &apos;undefined&apos;)&#123; this.name = name; console.log(&apos;name&apos;, name); &#125; else&#123; throw new Error(&apos;必须通过new关键字来调用Student2。&apos;); &#125;&#125;var student2 = new Student2(&apos;轩辕&apos;);var notAStudent2 = Student2.call(student2, &apos;Rowboat&apos;);console.log(student2, &apos;student2&apos;, notAStudent2, &apos;notAStudent2&apos;); // 抛出错误 细心的同学可能会发现了这版本的代码没有实现bind后的bound函数的nameMDN Function.name和lengthMDN Function.length。面试官可能也发现了这一点继续追问，如何实现，或者问是否看过es5-shim的源码实现L201-L335。如果不限ES版本。其实可以用ES5的Object.defineProperties来实现。12345678Object.defineProperties(bound, &#123; &apos;length&apos;: &#123; value: self.length, &#125;, &apos;name&apos;: &#123; value: &apos;bound &apos; + self.name, &#125;&#125;); es5-shim的源码实现bind直接附上源码（有删减注释和部分修改等）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var $Array = Array;var ArrayPrototype = $Array.prototype;var $Object = Object;var array_push = ArrayPrototype.push;var array_slice = ArrayPrototype.slice;var array_join = ArrayPrototype.join;var array_concat = ArrayPrototype.concat;var $Function = Function;var FunctionPrototype = $Function.prototype;var apply = FunctionPrototype.apply;var max = Math.max;// 简版 源码更复杂些。var isCallable = function isCallable(value)&#123; if(typeof value !== &apos;function&apos;)&#123; return false; &#125; return true;&#125;;var Empty = function Empty() &#123;&#125;;// 源码是 defineProperties// 源码是bind笔者改成bindFn便于测试FunctionPrototype.bindFn = function bind(that) &#123; var target = this; if (!isCallable(target)) &#123; throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target); &#125; var args = array_slice.call(arguments, 1); var bound; var binder = function () &#123; if (this instanceof bound) &#123; var result = apply.call( target, this, array_concat.call(args, array_slice.call(arguments)) ); if ($Object(result) === result) &#123; return result; &#125; return this; &#125; else &#123; return apply.call( target, that, array_concat.call(args, array_slice.call(arguments)) ); &#125; &#125;; var boundLength = max(0, target.length - args.length); var boundArgs = []; for (var i = 0; i &lt; boundLength; i++) &#123; array_push.call(boundArgs, &apos;$&apos; + i); &#125; // 这里是Function构造方式生成形参length $1, $2, $3... bound = $Function(&apos;binder&apos;, &apos;return function (&apos; + array_join.call(boundArgs, &apos;,&apos;) + &apos;)&#123; return binder.apply(this, arguments); &#125;&apos;)(binder); if (target.prototype) &#123; Empty.prototype = target.prototype; bound.prototype = new Empty(); Empty.prototype = null; &#125; return bound;&#125;; 你说出es5-shim源码bind实现，感慨这代码真是高效、严谨。面试官心里独白可能是：你就是我要找的人，薪酬福利你可以和HR去谈下。 最后总结一下1、bind是Function原型链中的Function.prototype的一个属性，它是一个函数，修改this指向，合并参数传递给原函数，返回值是一个新的函数。2、bind返回的函数可以通过new调用，这时提供的this的参数被忽略，指向了new生成的全新对象。内部模拟实现了new操作符。3、es5-shim源码模拟实现bind时用Function实现了length。事实上，平时其实很少需要使用自己实现的投入到生成环境中。但面试官通过这个面试题能考察很多知识。比如this指向，原型链，闭包，函数等知识，可以扩展很多。读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。 文章中的例子和测试代码放在github中bind模拟实现 github。bind模拟实现 预览地址 F12看控制台输出，结合source面板查看效果更佳。123456789101112131415161718192021222324252627282930// 最终版 删除注释 详细注释版请看上文Function.prototype.bind = Function.prototype.bind || function bind(thisArg)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(this + &apos; must be a function&apos;); &#125; var self = this; var args = [].slice.call(arguments, 1); var bound = function()&#123; var boundArgs = [].slice.call(arguments); var finalArgs = args.concat(boundArgs); if(this instanceof bound)&#123; if(self.prototype)&#123; function Empty()&#123;&#125; Empty.prototype = self.prototype; bound.prototype = new Empty(); &#125; var result = self.apply(this, finalArgs); var isObject = typeof result === &apos;object&apos; &amp;&amp; result !== null; var isFunction = typeof result === &apos;function&apos;; if(isObject || isFunction)&#123; return result; &#125; return this; &#125; else&#123; return self.apply(thisArg, finalArgs); &#125; &#125;; return bound;&#125; 参考OshotOkill翻译的 深入理解ES6 简体中文版 - 第三章 函数（虽然我是看的纸质书籍，但推荐下这本在线的书）MDN Function.prototype.bind冴羽: JavaScript深入之bind的模拟实现《react状态管理与同构实战》侯策：从一道面试题，到“我可能看了假源码” 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://lxchuan12.github.io/tags/面试/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"面试官问：能否模拟实现JS的new操作符","slug":"20181105-new-operator","date":"2018-11-05T15:48:12.000Z","updated":"2018-11-23T12:24:05.495Z","comments":true,"path":"2018/11/05/20181105-new-operator/","link":"","permalink":"https://lxchuan12.github.io/2018/11/05/20181105-new-operator/","excerpt":"","text":"前言用过Vuejs的同学都知道，需要用new操作符来实例化。1234new Vue(&#123; el: &apos;#app&apos;, mounted()&#123;&#125;,&#125;); 那么面试官可能会问是否想过new到底做了什么，怎么模拟实现呢。 附上之前写文章写过的一段话：已经有很多模拟实现new操作符的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。 new 做了什么先看简单例子1：1234567891011121314151617181920// 例子1function Student()&#123;&#125;var student = new Student();console.log(student); // &#123;&#125;// student 是一个对象。console.log(Object.prototype.toString.call(student)); // [object Object]// 我们知道平时声明对象也可以用new Object(); 只是看起来更复杂// 顺便提一下 `new Object`(不推荐)和Object()也是一样的效果// 可以猜测内部做了一次判断，用new调用/** if (!(this instanceof Object)) &#123;* return new Object();* &#125;*/var obj = new Object();console.log(obj) // &#123;&#125;console.log(Object.prototype.toString.call(student)); // [object Object]typeof Student === &apos;function&apos; // truetypeof Object === &apos;function&apos; // true 从这里例子中，我们可以看出：一个函数用new操作符来调用后，生成了一个全新的对象。而且Student和Object都是函数，只不过Student是我们自定义的，Object是JS本身就内置的。再来看下控制台输出图，感兴趣的读者可以在控制台试试。 例子1 控制台输出图 与new Object() 生成的对象不同的是new Student()生成的对象中间还嵌套了一层__proto__，它的constructor是Student这个函数。123// 也就是说：student.constructor === Student;Student.prototype.constructor === Student; 小结1：从这个简单例子来看，new操作符做了两件事： 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是__proto__）链接。 接下来我们再来看升级版的例子2：12345678// 例子2function Student(name)&#123; console.log(&apos;赋值前-this&apos;, this); // &#123;&#125; this.name = name; console.log(&apos;赋值后-this&apos;, this); // &#123;name: &apos;轩辕Rowboat&apos;&#125;&#125;var student = new Student(&apos;轩辕Rowboat&apos;);console.log(student); // &#123;name: &apos;轩辕Rowboat&apos;&#125; 由此可以看出：这里Student函数中的this指向new Student()生成的对象student。 小结2：从这个例子来看，new操作符又做了一件事： 生成的新对象会绑定到函数调用的this。 接下来继续看升级版例子3：123456789101112131415161718// 例子3function Student(name)&#123; this.name = name; // this.doSth();&#125;Student.prototype.doSth = function() &#123; console.log(this.name);&#125;;var student1 = new Student(&apos;轩辕&apos;);var student2 = new Student(&apos;Rowboat&apos;);console.log(student1, student1.doSth()); // &#123;name: &apos;轩辕&apos;&#125; &apos;轩辕&apos;console.log(student2, student2.doSth()); // &#123;name: &apos;Rowboat&apos;&#125; &apos;Rowboat&apos;student1.__proto__ === Student.prototype; // truestudent2.__proto__ === Student.prototype; // true// __proto__ 是浏览器实现的查看原型方案。// 用ES5 则是：Object.getPrototypeOf(student1) === Student.prototype; // trueObject.getPrototypeOf(student2) === Student.prototype; // true 例子3 控制台输出图 关于JS的原型关系笔者之前看到这张图，觉得很不错，分享给大家。 JavaScript原型关系图 小结3：这个例子3再一次验证了小结1中的第2点。也就是这个对象会被执行[[Prototype]]（也就是__proto__）链接。并且通过new Student()创建的每个对象将最终被[[Prototype]]链接到这个Student.protytype对象上。 细心的同学可能会发现这三个例子中的函数都没有返回值。那么有返回值会是怎样的情形呢。那么接下来请看例子41234567891011121314151617181920// 例子4function Student(name)&#123; this.name = name; // Null（空） null // Undefined（未定义） undefined // Number（数字） 1 // String（字符串）&apos;1&apos; // Boolean（布尔） true // Symbol（符号）（第六版新增） symbol // Object（对象） &#123;&#125; // Function（函数） function()&#123;&#125; // Array（数组） [] // Date（日期） new Date() // RegExp（正则表达式）/a/ // Error （错误） new Error() // return /a/;&#125;var student = new Student(&apos;轩辕Rowboat&apos;);console.log(student); &#123;name: &apos;轩辕Rowboat&apos;&#125; 笔者测试这七种类型后MDN JavaScript类型，得出的结果是：前面六种基本类型都会正常返回{name: &#39;轩辕Rowboat&#39;}，后面的Object(包含Functoin, Array, Date, RegExg, Error)都会直接返回这些值。 由此得出 小结4： 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 结合这些小结，整理在一起就是： 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是__proto__）链接。 生成的新对象会绑定到函数调用的this。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 new 模拟实现知道了这些现象，我们就可以模拟实现new操作符。直接贴出代码和注释123456789101112131415161718192021222324252627282930/** * 模拟实现 new 操作符 * @param &#123;Function&#125; ctor [构造函数] * @return &#123;Object|Function|Regex|Date|Error&#125; [返回结果] */function newOperator(ctor)&#123; if(typeof ctor !== &apos;function&apos;)&#123; throw &apos;newOperator function the first param must be a function&apos;; &#125; // ES6 new.target 是指向构造函数 newOperator.target = ctor; // 1.创建一个全新的对象， // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 var newObj = Object.create(ctor.prototype); // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments); // 除去ctor构造函数的其余参数 var argsArr = [].slice.call(arguments, 1); // 3.生成的新对象会绑定到函数调用的`this`。 // 获取到ctor函数返回结果 var ctorReturnResult = ctor.apply(newObj, argsArr); // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&apos;object&apos;所以要不等于null，排除null var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === &apos;function&apos;; if(isObject || isFunction)&#123; return ctorReturnResult; &#125; // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。 return newObj;&#125; 最后用模拟实现的newOperator函数验证下之前的例子3：1234567891011121314151617181920212223// 例子3 多加一个参数function Student(name, age)&#123; this.name = name; this.age = age; // this.doSth(); // return Error();&#125;Student.prototype.doSth = function() &#123; console.log(this.name);&#125;;var student1 = newOperator(Student, &apos;轩辕&apos;, 18);var student2 = newOperator(Student, &apos;Rowboat&apos;, 18);// var student1 = new Student(&apos;轩辕&apos;);// var student2 = new Student(&apos;Rowboat&apos;);console.log(student1, student1.doSth()); // &#123;name: &apos;轩辕&apos;&#125; &apos;轩辕&apos;console.log(student2, student2.doSth()); // &#123;name: &apos;Rowboat&apos;&#125; &apos;Rowboat&apos;student1.__proto__ === Student.prototype; // truestudent2.__proto__ === Student.prototype; // true// __proto__ 是浏览器实现的查看原型方案。// 用ES5 则是：Object.getPrototypeOf(student1) === Student.prototype; // trueObject.getPrototypeOf(student2) === Student.prototype; // true 可以看出，很符合new操作符。读者发现有不妥或可改善之处，欢迎指出。回顾这个模拟new函数newOperator实现，最大的功臣当属于Object.create()这个ES5提供的API。 Object.create() 用法举例笔者之前整理的一篇文章中也有讲过，可以翻看JavaScript 对象所有API解析 MDN Object.create() Object.create(proto, [propertiesObject])方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是undefined）。 123456789101112131415var anotherObject = &#123; name: &apos;轩辕Rowboat&apos;&#125;;var myObject = Object.create(anotherObject, &#123; age: &#123; value：18, &#125;,&#125;);// 获得它的原型Object.getPrototypeOf(anotherObject) === Object.prototype; // true 说明anotherObject的原型是Object.prototypeObject.getPrototypeOf(myObject); // &#123;name: &quot;轩辕Rowboat&quot;&#125; // 说明myObject的原型是&#123;name: &quot;轩辕Rowboat&quot;&#125;myObject.hasOwnProperty(&apos;name&apos;); // false; 说明name是原型上的。myObject.hasOwnProperty(&apos;age&apos;); // true 说明age是自身的myObject.name; // &apos;轩辕Rowboat&apos;myObject.age; // 18; 对于不支持ES5的浏览器，MDN上提供了ployfill方案。12345678910111213141516if (typeof Object.create !== &quot;function&quot;) &#123; Object.create = function (proto, propertiesObject) &#123; if (typeof proto !== &apos;object&apos; &amp;&amp; typeof proto !== &apos;function&apos;) &#123; throw new TypeError(&apos;Object prototype may only be an Object: &apos; + proto); &#125; else if (proto === null) &#123; throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support &apos;null&apos; as the first argument.&quot;); &#125; if (typeof propertiesObject != &apos;undefined&apos;) throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support a second argument.&quot;); function F() &#123;&#125; F.prototype = proto; return new F(); &#125;;&#125; 到此，文章就基本写完了。感谢读者看到这里。 最后总结一下：1.new做了什么： 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是__proto__）链接。 生成的新对象会绑定到函数调用的this。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 2.怎么模拟实现：12345678910111213141516// 去除了注释function newOperator(ctor)&#123; if(typeof ctor !== &apos;function&apos;)&#123; throw &apos;newOperator function the first param must be a function&apos;; &#125; newOperator.target = ctor; var newObj = Object.create(ctor.prototype); var argsArr = [].slice.call(arguments, 1); var ctorReturnResult = ctor.apply(newObj, argsArr); var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === &apos;function&apos;; if(isObject || isFunction)&#123; return ctorReturnResult; &#125; return newObj;&#125; 读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://lxchuan12.github.io/tags/面试/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并","slug":"20180829-puppeteer-merge-pdf","date":"2018-08-29T12:05:13.000Z","updated":"2018-11-05T15:46:59.407Z","comments":true,"path":"2018/08/29/20180829-puppeteer-merge-pdf/","link":"","permalink":"https://lxchuan12.github.io/2018/08/29/20180829-puppeteer-merge-pdf/","excerpt":"","text":"1、puppeteer 是什么？puppeteer: Google 官方出品的 headless Chrome node 库puppeteer github仓库puppeteer API 官方介绍： 您可以在浏览器中手动执行的大多数操作都可以使用Puppeteer完成！ 生成页面的屏幕截图和PDF。抓取SPA并生成预渲染内容（即“SSR”）。自动化表单提交，UI测试，键盘输入等。创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能直接在最新版本的Chrome中运行测试。捕获时间线跟踪 您的网站，以帮助诊断性能问题。测试Chrome扩展程序。 2、爬取网站生成PDF2.1 安装 puppeteer12345// 安装 puppeteer// 可能会因为网络原因安装失败，可使用淘宝镜像 // npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm i puppeteer# or &quot;yarn add puppeteer&quot; 2.2 《React.js小书》简介 《React.js小书》简介关于作者@胡子大哈这是⼀本关于 React.js 的⼩书。因为⼯作中⼀直在使⽤ React.js，也⼀直以来想总结⼀下⾃⼰关于 React.js 的⼀些知识、经验。于是把⼀些想法慢慢整理书写下来，做成⼀本开源、免费、专业、简单的⼊⻔级别的⼩书，提供给社区。希望能够帮助到更多 React.js 刚⼊⻔朋友。下图是《React.js 小书》部分截图： 《`React.js` 小书》部分截图 2.3 一些可能会用到的 puppeteer API1234567891011121314151617181920// 新建 reactMiniBook.js, 运行 node reactMiniBook.js 生成pdfconst puppeteer = require(&apos;puppeteer&apos;);(async () =&gt; &#123; // 启动浏览器 const browser = await puppeteer.launch(&#123; // 无界面 默认为true,改成false,则可以看到浏览器操作，目前生成pdf只支持无界面的操作。 // headless: false, // 开启开发者调试模式，默认false, 也就是平时F12打开的面版 // devtools: true, &#125;); // 打开一个标签页 const page = await browser.newPage(); // 跳转到页面 http://huziketang.mangojuice.top/books/react/ await page.goto(&apos;http://huziketang.com/books/react/&apos;, &#123;waitUntil: &apos;networkidle2&apos;&#125;); // path 路径， format 生成pdf页面格式 await page.pdf(&#123;path: &apos;react.pdf&apos;, format: &apos;A4&apos;&#125;); // 关闭浏览器 await browser.close();&#125;)(); 知道这启动浏览器打开页面关闭浏览器主流程后，再来看几个API。12345678910111213141516const args = 1;let wh = await page.evaluate((args) =&gt; &#123; // args 可以这样传递给这个函数。 // 类似于 setTimeout(() =&gt; &#123;console.log(args);&#125;, 3000, args); console.log(&apos;args&apos;, args); // 1 // 这里可以运行 dom操作等js // 返回通过dom操作等获取到的数据 return &#123; width: 1920, height: document.body.clientHeight, &#125;;&#125;, args);// 设置视图大小await page.setViewport(wh);// 等待2sawait page.waitFor(2000); 1234// 以iPhone X执行。const devices = require(&apos;puppeteer/DeviceDescriptors&apos;);const iPhone = devices[&apos;iPhone X&apos;];await page.emulate(iPhone); 2.4 知道了以上这些API后，就可以开始写主程序了。简单说下：实现功能和主流程。从上面React.js小书截图来看。1、打开浏览器，进入目录页，生成0. React 小书 目录.pdf2、跳转到1. React.js 简介页面，获取左侧所有的导航a链接的href,标题。3、用获取到的a链接数组进行for循环，这个循环里主要做了如下几件事： 3.1 隐藏左侧导航，便于生成pdf 3.2 给React.js简介等标题 加上序号，便于查看 3.3 设置docment.title 加上序号, 便于在页眉中使用。 3.4 隐藏 传播一下知识也是一个很好的选择 这一个模块（因为页眉页脚中设置了书的链接等信息，就隐藏这个了） 3.5 给 分页 上一节，下一节加上序号，便于查看。 3.6 最末尾声明下该pdf的说明，仅供学习交流，严禁用于商业用途。 3.7 返回宽高，用于设置视图大小 3.8 设置视图大小，创建生成pdf 4、关闭浏览器 具体代码：可以查看这里爬虫生成《React.js小书》的pdf每一小节的代码 123// node 执行这个文件// 笔者这里是：node src/puppeteer/reactMiniBook.js 即可生成如下图：每一小节（0-46小节）的pdf 每一小节（0-46小节）的`pdf` 生成这些后，那么问题来了，就是查看时总不能看一小节，打开一小节来看，这样很不方便。于是接下来就是合并这些pdf成为一个pdf文件。 3、合并成一个PDF文件 pdf-merge起初，我是使用在线网站Smallpdf，合并PDF。合并的效果还是很不错的。这网站还是其他功能。比如word转pdf等。后来找到社区提供的一个npm packagepdf merge。 (毕竟笔者是写程序的，所以就用代码来实现合并了) 这个pdf-merge依赖 pdftk 安装 PDFtkWindows下载并安装笔者安装后，重启电脑才能使用。 Debian, Ubuntu 安装笔者在Ubuntu系统安装后，即可使用。apt-get install pdftk 使用例子12345678910111213141516171819const PDFMerge = require(&apos;pdf-merge&apos;);const files = [ `$&#123;__dirname&#125;/1.pdf`, `$&#123;__dirname&#125;/2.pdf`,];// Buffer (Default)PDFMerge(files).then((buffer) =&gt; &#123;...&#125;);// StreamPDFMerge(files, &#123;output: &apos;Stream&apos;&#125;).then((stream) =&gt; &#123;...&#125;);// 笔者这里使用的是这个// Save as new filePDFMerge(files, &#123;output: `$&#123;__dirname&#125;/3.pdf`&#125;).then((buffer) =&gt; &#123;...&#125;); 知道这些后，可以开始写主程序了。简单说下主流程1、读取到生成的所有pdf文件路径，并排序（0-46）2、判断下输出文件夹是否存在，不存在则创建3、合并这些小节的pdf保存到新文件 React小书（完整版）-作者：胡子大哈-时间戳.pdf 具体代码：可以查看这里爬虫生成《React.js小书》的pdf合并pdf的代码 最终合并的pdf文件在这里React小书（完整版）-作者：胡子大哈，可供下载。 本想着还可以加下书签和页码，没找到合适的生成方案，那暂时先不加了。如果读者有好的方案，欢迎与笔者交流。 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github 小结1、puppeteer是Google 官方出品的 headless Chrome node 库，可以在浏览器中手动执行的大多数操作都可以使用Puppeteer完成。总之可以用来做很多有趣的事情。2、用 puppeteer 生成每一小节的pdf，用依赖pdftk的pdf-merge npm包, 合并成一个新的pdf文件。或者使用Smallpdf等网站合并。3、《React.js小书》，推荐给大家。爬虫生成pdf，应该不会对作者@胡子大哈有什么影响。 最后推荐几个链接，方便大家学习 puppeteer。puppeteer入门教程Puppeteer 初探之前端自动化测试爬虫生成ES6标准入门 pdf大前端神器安利之 Puppeteerpuppeteer API中文文档","categories":[{"name":"node","slug":"node","permalink":"https://lxchuan12.github.io/categories/node/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://lxchuan12.github.io/tags/chrome/"},{"name":"爬虫","slug":"爬虫","permalink":"https://lxchuan12.github.io/tags/爬虫/"},{"name":"pdf","slug":"pdf","permalink":"https://lxchuan12.github.io/tags/pdf/"}],"keywords":[{"name":"node","slug":"node","permalink":"https://lxchuan12.github.io/categories/node/"}]},{"title":"分享百度网盘下载搜索神器和一些实用浏览器插件","slug":"20180714-some baiduyunpan-and chrome crx","date":"2018-07-14T14:42:50.000Z","updated":"2018-07-28T07:17:38.173Z","comments":true,"path":"2018/07/14/20180714-some baiduyunpan-and chrome crx/","link":"","permalink":"https://lxchuan12.github.io/2018/07/14/20180714-some baiduyunpan-and chrome crx/","excerpt":"","text":"前段时间（端午节期间）折腾电脑，用虚拟机安装mac 10.13，但安装包太大，6.5G。顺便放下我安装时参考的链接，说不定有人也想安装mac试试，不过我试验的是安装后比较卡。验证在vm12下安装os 10.13的可行性（同适用 os 10.12.6） 虚拟机安装`mac`后截图.png 文件在百度网盘中，但大家都知道百度云管家下载限制下载速度，按照限制的下载速度，不知道要下载到猴年马月。 Proxyee-down 百度网盘下载神器于是我发现了一款百度网盘下载神器【Proxyee-down】（支持Win/Mac/Linux的百度云文件下载工具），据说下载速度不止2M/s，可以跑到20M/s。当然也跟所在网络环境有关。总之要比官方百度云管家下载速度要快。下载地址（根据不同系统安装不同版本）项目开源，安装教程等相关都可以在这个链接里找到。我就不附图了。proxyee-down项目地址 云盘万能钥匙 插件既然推荐了百度网盘下载工具，那就再推荐 云盘万能钥匙这个插件。云盘万能钥匙官网谷歌应用商店安装地址官方是这样推荐的。1.自动识别并填写提取密码，懒癌患者的福音2.每当点击一个分享链接，却提示我分享已失效时，我的内心是崩溃的3.尊重个人隐私可以根据不同浏览器下载安装不同版本插件。不科学上网也可以下载安装。如何科学上网就自行百度研究了。简要推荐一个插件skyZIP-Proxy。在谷歌浏览器中离线安装、卸载和更新云盘万能钥匙 可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何离线安装可以参看这篇文章如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？，也可以参看上文推荐【在谷歌浏览器中安装、卸载和更新云盘万能钥匙】文章。不过还是简单说下离线安装步骤：把下载下YPSuperKey-For-Chrome-Only.crx文件，（如果没有扩展名，那设置显示）改成YPSuperKey-For-Chrome-Only.zip，然后用好压等工具解压出来。 YPSuperKey-For-Chrome-Only文件夹.png 打开chrome浏览器，按图所示，依次打开【更多工具】 - 【扩展程序】 - 勾选【开发者模式】【加载已解压的扩展程序】，选择刚刚的文件夹，安装这个插件成功了。 【更多工具】 - 【扩展程序】.png 开发模式 - 加载已解压的扩展程序.png ghostery 隐私广告拦截工具 插件说到隐私，推荐这个插件，能够屏蔽网站统计收集用户信息。应用商店下载安装 二维码生成 插件有时需要手机上访问电脑浏览器上某个地址，直接输入太长，不现实。这时候这个插件就很有用了。应用商店下载安装地址 云盘精灵，一个更好的网盘搜索引擎云盘精灵官网 这网站有时需要科学上网访问。 搜索罗小川chuan的结果，之前写的文章配套资源.png 官方是这样推荐的。 基于【云盘万能钥匙】收录的海量数据 支持搜索带提取密码的分享资源 资源链接失效时立即移除出搜索数据库 简洁清新的界面设计（没有低俗的广告） adblock-plus 屏蔽广告插件。说到广告啊。我用chrome adblock-plus插件应用商店安装地址屏蔽各种网站广告。 网页截图插件 fireShot , 系统截图PicPick软件应用商店下载地址有时需要截取整个网页，这个插件可以做到。跳出网站，系统截图我推荐Snipaste或者PicPick软件。Snipaste官网，win10也可以通过Microsoft Store 下载安装。PicPick官网。说到截图顺带提下，win系统下，按PrintScreen键截取整个屏幕、按Alt键+PrintScreen键截取活动窗口、按Win键+PrintScreen键截取整个屏幕，并保存在【图片】 - 【屏幕截图】 中，一般是C:\\Users{你的用户名}\\Pictures\\Screenshots中。（PS:这个按Win键+PrintScreen`键，我也是前不久才发现，真是活到老，学到老。） 鼠标手势插件 crxMouse 插件鼠标右击画一些手势，可以操作浏览器，控制前进、后退，关闭，翻页等。很好用。应用商店地址 OneTab 插件，节省内存，减轻标签页混乱现象应用商店下载安装地址官方是这样推荐的：节省高达95％的内存，并减轻标签页混乱现象有时打开很多页面，没有及时关闭，就占用挺大内存，这个插件可以一键收起。以后再打开。当然还有更多功能。 octotree 树形结构 查看github项目应用商店下载安装地址github项目地址 Octo Mate, 增强你的 github 体验能一键下载文件和目录形式查看文档等。应用商店下载安装地址 一键管理 扩展 插件安装了那么多插件，不常用的可以先停用，这个插件可以一键管理这些插件。应用商店下载安装地址 小结当然我安装了很多插件和软件，先推荐这些给大家，后续有时间再更新。还有更多好玩实用的插件和软件等着我们去发掘。写到这里好久之前写过这样一篇文章提高效率的电脑技巧及软件，可以看看。本着学我所学，为我所用，服务他人的宗旨^_^，这篇文章主要推荐了：1、Proxyee-down 百度网盘下载神器2、云盘万能钥匙 插件3、ghostery 隐私广告拦截工具 插件4、二维码生成 插件5、云盘精灵，一个更好的网盘搜索引擎6、adblock-plus 屏蔽广告插件。7、网页截图插件 fireShot , 系统截图Snipaste或者PicPick软件8、鼠标手势插件 crxMouse 插件9、OneTab 插件，节省内存，减轻标签页混乱现象10、Octotree 树形结构 查看github项目11、Octo Mate, 增强 github 体验12、一键管理 扩展 插件 文章同时发布在我的个人博客上：分享百度网盘下载搜索神器和一些实用浏览器插件","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://lxchuan12.github.io/categories/实用技巧/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://lxchuan12.github.io/tags/chrome/"},{"name":"skyDrive","slug":"skyDrive","permalink":"https://lxchuan12.github.io/tags/skyDrive/"},{"name":"baidu","slug":"baidu","permalink":"https://lxchuan12.github.io/tags/baidu/"}],"keywords":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://lxchuan12.github.io/categories/实用技巧/"}]},{"title":"分析vue-cli@2.9.3 搭建的webpack项目工程","slug":"20180611-analyse-vue-cli","date":"2018-06-11T12:22:38.000Z","updated":"2018-11-23T12:28:55.082Z","comments":true,"path":"2018/06/11/20180611-analyse-vue-cli/","link":"","permalink":"https://lxchuan12.github.io/2018/06/11/20180611-analyse-vue-cli/","excerpt":"","text":"前言 已经有很多分析Vue-cli搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。 项目放在笔者的github上，分析vue-cli@2.9.3 搭建的webpack项目工程。方便大家克隆下载，或者在线查看。同时也求个star ^_^，也是对笔者的一种鼓励和支持。 正文从这里开始～ 使用vue-cli初始化webpack工程1234567891011121314151617// # 安装npm install -g vue-cli// 安装完后vue命令就可以使用了。实际上是全局注册了vue、vue-init、vue-list几个命令// # ubuntu 系统下// [vue-cli@2.9.3] link /usr/local/bin/vue@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue// [vue-cli@2.9.3] link /usr/local/bin/vue-init@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-init// [vue-cli@2.9.3] link /usr/local/bin/vue-list@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-listvue list// 可以发现有browserify、browserify-simple、pwa、simple、webpack、webpack-simple几种模板可选，这里选用webpack。// # 使用 vue initvue init &lt;template-name&gt; &lt;project-name&gt;// # 例子vue init webpack analyse-vue-cli 更多vue-cli如何工作的可以查看这篇文章vue-cli是如何工作的，或者分析Vue-cli源码查看这篇走进Vue-cli源码，自己动手搭建前端脚手架工具，再或者直接查看vue-cli github仓库源码 如果对webpack还不是很了解，可以查看webpack官方文档中的概念，虽然是最新版本的，但概念都是差不多的。 package.json分析一个项目，一般从package.json的命令入口scripts开始。123456789101112131415&quot;scripts&quot;: &#123; // dev webpack-dev-server --inline 模式 --progress 显示进度 --config 指定配置文件（默认是webpack.config.js） &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, // jest测试 &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;, // e2e测试 &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;, // 运行jest测试和e2e测试 &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;, // eslint --ext 指定扩展名和相应的文件 &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;, // node 执行build/build.js文件 &quot;build&quot;: &quot;node build/build.js&quot;&#125;, Npm Script 底层实现原理是通过调用 Shell 去运行脚本命令。npm run start等同于运行npm run dev。 Npm Script 还有一个重要的功能是能运行安装到项目目录里的 node_modules 里的可执行模块。 例如在通过命令npm i -D webpack-dev-server将webpack-dev-server安装到项目后，是无法直接在项目根目录下通过命令 webpack-dev-server 去执行 webpack-dev-server 构建的，而是要通过命令 ./node_modules/.bin/webpack-dev-server 去执行。 Npm Script 能方便的解决这个问题，只需要在 scripts 字段里定义一个任务，例如：1&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot; Npm Script 会先去项目目录下的 node_modules 中寻找有没有可执行的 webpack-dev-server 文件，如果有就使用本地的，如果没有就使用全局的。 所以现在执行 webpack-dev-server 启动服务时只需要通过执行 npm run dev 去实现。 再来看下 npm run dev webpack-dev-server 其实是一个node.js的应用程序，它是通过JavaScript开发的。在命令行执行npm run dev命令等同于执行node ./node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js。你可以试试。 更多package.json的配置项，可以查看阮一峰老师的文章 package.json文件 npm run dev指定了build/webpack.dev.conf.js配置去启动服务，那么我们来看下这个文件做了什么。 build/webpack.dev.conf.js webpack开发环境配置这个文件主要做了以下几件事情：1、引入各种依赖，同时也引入了config文件夹下的变量和配置，和一个工具函数build/utils.js，2、合并build/webpack.base.conf.js配置文件，3、配置开发环境一些devServer，plugin等配置，4、最后导出了一个Promise，根据配置的端口，寻找可用的端口来启动服务。 具体可以看build/webpack.dev.conf.js这个文件注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&apos;use strict&apos;// 引入工具函数const utils = require(&apos;./utils&apos;)// 引入webpackconst webpack = require(&apos;webpack&apos;)// 引入config/index.js配置const config = require(&apos;../config&apos;)// 合并webpack配置const merge = require(&apos;webpack-merge&apos;)const path = require(&apos;path&apos;)// 基本配置const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)// 拷贝插件const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)// 生成html的插件const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// 友好提示的插件 https://github.com/geowarin/friendly-errors-webpack-pluginconst FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)// 查找可用端口 // github仓库 https://github.com/indexzero/node-portfinderconst portfinder = require(&apos;portfinder&apos;)// process模块用来与当前进程互动，可以通过全局变量process访问，不必使用require命令加载。它是一个EventEmitter对象的实例。// 后面有些process模块用到的，所以这里统一列举下。// 更多查看这篇阮一峰的这篇文章 http://javascript.ruanyifeng.com/nodejs/process.html// process对象提供一系列属性，用于返回系统信息。// process.pid：当前进程的进程号。// process.version：Node的版本，比如v0.10.18。// process.platform：当前系统平台，比如Linux。// process.title：默认值为“node”，可以自定义该值。// process.argv：当前进程的命令行参数数组。// process.env：指向当前shell的环境变量，比如process.env.HOME。// process.execPath：运行当前进程的可执行文件的绝对路径。// process.stdout：指向标准输出。// process.stdin：指向标准输入。// process.stderr：指向标准错误。// process对象提供以下方法：// process.exit()：退出当前进程。// process.cwd()：返回运行当前脚本的工作目录的路径。_// process.chdir()：改变工作目录。// process.nextTick()：将一个回调函数放在下次事件循环的顶部。// hostconst HOST = process.env.HOST// 端口const PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)// 合并基本的webpack配置const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // cssSourceMap这里配置的是true rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development // 在开发环境是cheap-module-eval-source-map选项更快 // 这里配置的是cheap-module-eval-source-map // 更多可以查看中文文档：https://webpack.docschina.org/configuration/devtool/#devtool // 英文 https://webpack.js.org/configuration/devtool/#development devtool: config.dev.devtool, // these devServer options should be customized in /config/index.js devServer: &#123; // 配置在客户端的日志等级，这会影响到你在浏览器开发者工具控制台里看到的日志内容。 // clientLogLevel 是枚举类型，可取如下之一的值 none | error | warning | info。 // 默认为 info 级别，即输出所有类型的日志，设置成 none 可以不输出任何日志。 clientLogLevel: &apos;warning&apos;, // historyApiFallback boolean object 用于方便的开发使用了 HTML5 History API 的单页应用。 // 可以简单true 或者 任意的 404 响应可以提供为 index.html 页面。 historyApiFallback: &#123; rewrites: [ // config.dev.assetsPublicPath 这里是 / &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;, ], &#125;, // 开启热更新 hot: true, // contentBase 配置 DevServer HTTP 服务器的文件根目录。 // 默认情况下为当前执行目录，通常是项目根目录，所有一般情况下你不必设置它，除非你有额外的文件需要被 DevServer 服务。 contentBase: false, // since we use CopyWebpackPlugin. // compress 配置是否启用 gzip 压缩。boolean 为类型，默认为 false。 compress: true, // host // 例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 --host 0.0.0.0 // 或者直接设置为 0.0.0.0 // 这里配置的是localhost host: HOST || config.dev.host, // 端口号 这里配置的是8080 port: PORT || config.dev.port, // 打开浏览器，这里配置是不打开false open: config.dev.autoOpenBrowser, // 是否在浏览器以遮罩形式显示报错信息 这里配置的是true overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, // 这里配置的是 / publicPath: config.dev.assetsPublicPath, // 代理 这里配置的是空&#123;&#125;,有需要可以自行配置 proxy: config.dev.proxyTable, // 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。 // 开启后一般非常干净只有类似的提示 Your application is running here: http://localhost:8080 quiet: true, // necessary for FriendlyErrorsPlugin // webpack-dev-middleware // watch: false, // 启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。Watch 模式默认关闭。 // webpack-dev-server 和 webpack-dev-middleware 里 Watch 模式默认开启。 // Watch 模式的选项 watchOptions: &#123; // 或者指定毫秒为单位进行轮询。 // 这里配置为false poll: config.dev.poll, &#125; // 更多查看中文文档：https://webpack.docschina.org/configuration/watch/#src/components/Sidebar/Sidebar.jsx &#125;, plugins: [ // 定义为开发环境 new webpack.DefinePlugin(&#123; // 这里是 &#123; NODE_ENV: &apos;&quot;development&quot;&apos; &#125; &apos;process.env&apos;: require(&apos;../config/dev.env&apos;) &#125;), // 热更新插件 new webpack.HotModuleReplacementPlugin(), // 热更新时显示具体的模块路径 new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. // 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。 new webpack.NoEmitOnErrorsPlugin(), // github仓库 https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, // inject 默认值 true，script标签位于html文件的 body 底部 // body 通true, header, script 标签位于 head 标签内 // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件 inject: true &#125;), // copy custom static assets // 把static资源复制到相应目录。 new CopyWebpackPlugin([ &#123; // 这里是 static from: path.resolve(__dirname, &apos;../static&apos;), // 这里是 static to: config.dev.assetsSubDirectory, // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)// 导出一个promisemodule.exports = new Promise((resolve, reject) =&gt; &#123; // process.env.PORT 可以在命令行指定端口号，比如PORT=2000 npm run dev，那访问就是http://localhost:2000 // config.dev.port 这里配置是 8080 portfinder.basePort = process.env.PORT || config.dev.port // 以配置的端口为基准，寻找可用的端口，比如：如果8080占用，那就8081,以此类推 // github仓库 https://github.com/indexzero/node-portfinder portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, // notifyOnErrors 这里配置是 true // onErrors 是一个函数，出错输出错误信息，系统原生的通知 onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) build/utils.js 工具函数上文build/webpack.dev.conf.js提到引入了build/utils.js工具函数。该文件主要写了以下几个工具函数：1、assetsPath返回输出路径，2、cssLoaders返回相应的css-loader配置，3、styleLoaders返回相应的处理样式的配置，4、createNotifierCallback创建启动服务时出错时提示信息回调。 具体配置可以看该文件注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&apos;use strict&apos;const path = require(&apos;path&apos;)// 引入配置文件config/index.jsconst config = require(&apos;../config&apos;)// 提取css的插件const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)// 引入package.json配置const packageConfig = require(&apos;../package.json&apos;)// 返回路径exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos; // 二级目录 这里是 static ? config.build.assetsSubDirectory // 二级目录 这里是 static : config.dev.assetsSubDirectory // 生成跨平台兼容的路径 // 更多查看Node API链接：https://nodejs.org/api/path.html#path_path_posix return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; // 作为参数传递进来的options对象 // &#123; // // sourceMap这里是true // sourceMap: true, // // 是否提取css到单独的css文件 // extract: true, // // 是否使用postcss // usePostCSS: true // &#125; options = options || &#123;&#125; const cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &apos;postcss-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin // 创建对应的loader配置 function generateLoaders (loader, loaderOptions) &#123; // 是否使用usePostCSS，来决定是否采用postcssLoader const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, // 合并 loaderOptions 生成options options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; // 如果提取使用ExtractTextPlugin插件提取 // 更多配置 看插件中文文档：https://webpack.docschina.org/plugins/extract-text-webpack-plugin/ return ExtractTextPlugin.extract(&#123; // 指需要什么样的loader去编译文件 // loader 被用于将资源转换成一个 CSS 导出模块 (必填) use: loaders, // loader（例如 &apos;style-loader&apos;）应用于当 CSS 没有被提取(也就是一个额外的 chunk，当 allChunks: false) fallback: &apos;vue-style-loader&apos; &#125;) &#125; else &#123; return [&apos;vue-style-loader&apos;].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders(&apos;less&apos;), // sass indentedSyntax 语法缩进，类似下方格式 // #main // color: blue // font-size: 0.3em sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;), scss: generateLoaders(&apos;sass&apos;), stylus: generateLoaders(&apos;stylus&apos;), styl: generateLoaders(&apos;stylus&apos;) &#125;&#125;// Generate loaders for standalone style files (outside of .vue)// 最终会返回webpack css相关的配置exports.styleLoaders = function (options) &#123; // &#123; // // sourceMap这里是true // sourceMap: true, // // 是否提取css到单独的css文件 // extract: true, // // 是否使用postcss // usePostCSS: true // &#125; const output = [] const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&apos;\\\\.&apos; + extension + &apos;$&apos;), use: loader &#125;) &#125; return output&#125;// npm run dev 出错时， FriendlyErrorsPlugin插件 配置 onErrors输出错误信息exports.createNotifierCallback = () =&gt; &#123; // &apos;node-notifier&apos;是一个跨平台系统通知的页面，当遇到错误时，它能用系统原生的推送方式给你推送信息 const notifier = require(&apos;node-notifier&apos;) return (severity, errors) =&gt; &#123; if (severity !== &apos;error&apos;) return const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &apos;: &apos; + error.name, subtitle: filename || &apos;&apos;, icon: path.join(__dirname, &apos;logo.png&apos;) &#125;) &#125;&#125; build/webpack.base.conf.js webpack基本配置文件上文build/webpack.dev.conf.js提到引入了build/webpack.base.conf.js这个webpack基本配置文件。这个文件主要做了以下几件事情：1、引入各种插件、配置等，其中引入了build/vue-loader.conf.js相关配置，2、创建eslint规则配置，默认启用，3、导出webpack配置对象，其中包含context，入口entry，输出output，resolve，module下的rules（处理对应文件的规则），和node相关的配置等。 具体可以看这个文件注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 使用严格模式，更多严格模式可以查看// [阮一峰老师的es标准入门](http://es6.ruanyifeng.com/?search=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F&amp;x=0&amp;y=0#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)&apos;use strict&apos;const path = require(&apos;path&apos;)// 引入工具函数const utils = require(&apos;./utils&apos;)// 引入配置文件，也就是config/index.js文件const config = require(&apos;../config&apos;)// 引入vue-loader的配置文件const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)// 定义获取绝对路径函数function resolve (dir) &#123; return path.join(__dirname, &apos;..&apos;, dir)&#125;// 创建eslint配置const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, // 执行顺序，前置，还有一个选项是post是后置 // 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查 enforce: &apos;pre&apos;, // 包含文件夹 include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: &#123; // 使用友好的eslint提示插件 formatter: require(&apos;eslint-friendly-formatter&apos;), // eslint报错提示是否显示以遮罩形式显示在浏览器中 // 这里showEslintErrorsInOverlay配置是false emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123; // 运行环境的上下文，就是实际的目录，也就是项目根目录 context: path.resolve(__dirname, &apos;../&apos;), // 入口 entry: &#123; app: &apos;./src/main.js&apos; &#125;, // 输出 output: &#123; // 路径 这里是根目录下的dist path: config.build.assetsRoot, // 文件名 filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; // 这里是 /，但要上传到github pages等会路径不对，需要修改为./ ? config.build.assetsPublicPath // 这里配置是 / : config.dev.assetsPublicPath &#125;, // Webpack 在启动后会从配置的入口模块出发找出所有依赖的模块，Resolve 配置 Webpack 如何寻找模块所对应的文件。 resolve: &#123; // 配置了这个，对应的扩展名可以省略 extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; // 给定对象的键后的末尾添加 $，以表示精准匹配 node_modules/vue/dist/vue.esm.js // 引用 import Vue from &apos;vue&apos;就是引入的这个文件最后export default Vue 导出的Vue; // 所以这句可以以任意大写字母命名 比如：import V from &apos;vue&apos; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, // src别名 比如 ：引入import HelloWorld from &apos;@/components/HelloWorld&apos; &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, // 定义一些文件的转换规则 module: &#123; rules: [ // 是否使用eslint 这里配置是true ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\\.vue$/, // vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/ loader: &apos;vue-loader&apos;, options: vueLoaderConfig &#125;, &#123; // js文件使用babel-loader转换 test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)] &#125;, &#123; // 图片文件使用url-loader转换 test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; // 限制大小10000B(bytes)以内，转成base64编码的dataURL字符串 limit: 10000, // 输出路径 img/名称.7位hash.扩展名 name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; // 视频文件使用url-loader转换 test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ] &#125;, // 这里的node是一个对象，其中每个属性都是 Node.js 全局变量或模块的名称，每个 value 是以下其中之一 // empty 提供空对象。 // false 什么都不提供。 // 更多查看 中文文档：https://webpack.docschina.org/configuration/node/ node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it&apos;s native). // 防止webpack注入一些polyfill 因为Vue已经包含了这些。 setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: &apos;empty&apos;, fs: &apos;empty&apos;, net: &apos;empty&apos;, tls: &apos;empty&apos;, child_process: &apos;empty&apos; &#125;&#125; build/vue-loader.conf.js vue-loader配置文件上文build/webpack.dev.conf.js提到引入了build/vue-loader.conf.js。 这个文件主要导出了一份Vue-loader的配置，主要有：loaders，cssSourceMap，cacheBusting，transformToRequire。 具体看该文件注释：1234567891011121314151617181920212223242526272829303132&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const isProduction = process.env.NODE_ENV === &apos;production&apos;const sourceMapEnabled = isProduction // 这里是true ? config.build.productionSourceMap // 这里是true : config.dev.cssSourceMap// 更多配置 可以查看vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/module.exports = &#123; // cssLoaders 生成相应loader配置，具体看utils文件中的cssLoader loaders: utils.cssLoaders(&#123; // 是否开启sourceMap，便于调试 sourceMap: sourceMapEnabled, // 是否提取vue单文件的css extract: isProduction &#125;), // 是否开启cssSourceMap，便于调试 cssSourceMap: sourceMapEnabled, // 这里是true // 缓存破坏，进行sourceMap debug时，设置成false很有帮助。 cacheBusting: config.dev.cacheBusting, // vue单文件中，在模板中的图片等资源引用转成require的形式。以便目标资源可以由 webpack 处理。 transformToRequire: &#123; video: [&apos;src&apos;, &apos;poster&apos;], source: &apos;src&apos;, img: &apos;src&apos;, // 默认配置会转换 &lt;img&gt; 标签上的 src 属性和 SVG 的 &lt;image&gt; 标签上的 xlink：href 属性。 image: &apos;xlink:href&apos; &#125;&#125; 看完了这些文件相应配置，开发环境的相关配置就串起来了。其中config/文件夹下的配置，笔者都已经注释在build/文件夹下的对应的文件中，所以就不单独说明了。 那回过头来看，package.json的scripts中的npm run build配置，node build/build.js，其实就是用node去执行build/build.js文件。 build/build.js npm run build 指定执行的文件这个文件主要做了以下几件事情：1、引入build/check-versions文件，检查node和npm的版本，2、引入相关插件和配置，其中引入了webpack生产环境的配置build/webpack.prod.conf.js，3、先控制台输出loading，删除dist目录下的文件，开始构建，构建失败和构建成功都给出相应的提示信息。 具体可以查看相应的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&apos;use strict&apos;// 检查node npm的版本require(&apos;./check-versions&apos;)()process.env.NODE_ENV = &apos;production&apos;// 命令行中的loadingconst ora = require(&apos;ora&apos;)// 删除文件或文件夹const rm = require(&apos;rimraf&apos;)// 路径相关const path = require(&apos;path&apos;)// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalkconst chalk = require(&apos;chalk&apos;)// 引入webpackconst webpack = require(&apos;webpack&apos;)// 引入config/index.jsconst config = require(&apos;../config&apos;)// 引入 生产环境webpack配置const webpackConfig = require(&apos;./webpack.prod.conf&apos;)// 控制台输入开始构建loadingconst spinner = ora(&apos;building for production...&apos;)spinner.start()// 删除原有构建输出的目录文件 这里是dist 和 staticrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; // 如果出错，抛出错误 if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; // 关闭 控制台输入开始构建loading spinner.stop() // 如果出错，抛出错误 if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, chunkModules: false &#125;) + &apos;\\n\\n&apos;) // 如果有错，控制台输出构建失败 if (stats.hasErrors()) &#123; console.log(chalk.red(&apos; Build failed with errors.\\n&apos;)) process.exit(1) &#125; // 控制台输出构建成功相关信息 console.log(chalk.cyan(&apos; Build complete.\\n&apos;)) console.log(chalk.yellow( &apos; Tip: built files are meant to be served over an HTTP server.\\n&apos; + &apos; Opening index.html over file:// won\\&apos;t work.\\n&apos; )) &#125;)&#125;) build/check-versions 检查node和npm版本上文提到build/check-versions 检查node和npm版本，这个文件主要引入了一些插件和配置，最后导出一个函数，版本不符合预期就输出警告。 具体查看这个配置文件注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&apos;use strict&apos;// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalkconst chalk = require(&apos;chalk&apos;)// 语义化控制版本的插件 更多查看：https://github.com/npm/node-semverconst semver = require(&apos;semver&apos;)// package.json配置const packageConfig = require(&apos;../package.json&apos;)// shell 脚本 Unix shell commands for Node.js 更多查看：https://github.com/shelljs/shelljsconst shell = require(&apos;shelljs&apos;)function exec (cmd) &#123; return require(&apos;child_process&apos;).execSync(cmd).toString().trim()&#125;const versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), // 这里配置是&quot;node&quot;: &quot;&gt;= 6.0.0&quot;, versionRequirement: packageConfig.engines.node &#125;]// 需要使用npmif (shell.which(&apos;npm&apos;)) &#123; versionRequirements.push(&#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), // 这里配置是&quot;npm&quot;: &quot;&gt;= 3.0.0&quot; versionRequirement: packageConfig.engines.npm &#125;)&#125;// 导出一个检查版本的函数module.exports = function () &#123; const warnings = [] for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i] // 当前版本不大于所需版本 if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; // 如果有警告，全部输出到控制台 if (warnings.length) &#123; console.log(&apos;&apos;) console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;)) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(&apos; &apos; + warning) &#125; console.log() process.exit(1) &#125;&#125; build/webpack.prod.conf.js webpack生产环境配置上文build/build.js提到，引入了这个配置文件。这个文件主要做了以下几件事情：1、引入一些插件和配置，其中引入了build/webpack.base.conf.js webpack基本配置文件，2、用DefinePlugin定义环境，3、合并基本配置，定义自己的配置webpackConfig，配置了一些modules下的rules，devtools配置，output输出配置，一些处理js、提取css、压缩css、输出html插件、提取公共代码等的plugins，4、如果启用gzip，再使用相应的插件处理，5、如果启用了分析打包后的插件，则用webpack-bundle-analyzer，6、最后导出这份配置。 具体可以查看这个文件配置注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&apos;use strict&apos;// 引入node路径相关const path = require(&apos;path&apos;)// 引入utils工具函数const utils = require(&apos;./utils&apos;)// 引入webpackconst webpack = require(&apos;webpack&apos;)// 引入config/index.js配置文件const config = require(&apos;../config&apos;)// 合并webpack配置的插件const merge = require(&apos;webpack-merge&apos;)// 基本的webpack配置const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)// 拷贝文件和文件夹的插件const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)// 压缩处理HTML的插件const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)// 压缩处理css的插件const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)// 压缩处理js的插件const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)// 用DefinePlugin定义环境const env = process.env.NODE_ENV === &apos;testing&apos; // 这里是 &#123; NODE_ENV: &apos;&quot;testing&quot;&apos; &#125; ? require(&apos;../config/test.env&apos;) // 这里是 &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125; : require(&apos;../config/prod.env&apos;)// 合并基本webpack配置const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 通过styleLoaders函数生成样式的一些规则 rules: utils.styleLoaders(&#123; // sourceMap这里是true sourceMap: config.build.productionSourceMap, // 是否提取css到单独的css文件 extract: true, // 是否使用postcss usePostCSS: true &#125;) &#125;, // 配置使用sourceMap true 这里是 #source-map devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; // 这里是根目录下的dist path: config.build.assetsRoot, // 文件名称 chunkhash filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), // chunks名称 chunkhash chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) &#125;, plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html // 定义具体是什么环境 new webpack.DefinePlugin(&#123; &apos;process.env&apos;: env &#125;), // 压缩js插件 new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 警告 warnings: false // 构建后的文件 常用的配置还有这些 // 去除console.log 默认为false。 传入true会丢弃对console函数的调用。 // drop_console: true, // 去除debugger // drop_debugger: true, // 默认为null. 你可以传入一个名称的数组，而UglifyJs将会假定那些函数不会产生副作用。 // pure_funcs: [ &apos;console.log&apos;, &apos;console.log.apply&apos; ], &#125; &#125;, // 是否开启sourceMap 这里是true sourceMap: config.build.productionSourceMap, // 平行处理（同时处理）加快速度 parallel: true &#125;), // extract css into its own file // 提取css到单独的css文件 new ExtractTextPlugin(&#123; // 提取到相应的文件名 使用内容hash contenthash filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It&apos;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&apos;s `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 // allChunks 默认是false,true指提取所有chunks包括动态引入的组件。 allChunks: true, &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin(&#123; // 这里配置是true cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; // 输出html名称 filename: process.env.NODE_ENV === &apos;testing&apos; ? &apos;index.html&apos; // 这里是 根目录下的dist/index.html : config.build.index, // 使用哪个模板 template: &apos;index.html&apos;, // inject 默认值 true，script标签位于html文件的 body 底部 // body 通true, header, script 标签位于 head 标签内 // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件 inject: true, // 压缩 minify: &#123; // 删除注释 removeComments: true, // 删除空格和换行 collapseWhitespace: true, // 删除html标签中属性的双引号 removeAttributeQuotes: true // 更多配置查看html-minifier插件 // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin // 在chunk被插入到html之前，你可以控制它们的排序。允许的值 ‘none’ | ‘auto’ | ‘dependency’ | &#123;function&#125; 默认为‘auto’. // dependency 依赖（从属） chunksSortMode: &apos;dependency&apos; &#125;), // keep module.id stable when vendor modules does not change // 根据代码内容生成普通模块的id，确保源码不变，moduleID不变。 new webpack.HashedModuleIdsPlugin(), // enable scope hoisting // 开启作用域提升 webpack3新的特性，作用是让代码文件更小、运行的更快 new webpack.optimize.ModuleConcatenationPlugin(), // split vendor js into its own file // 提取公共代码 new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks (module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 提取公共代码 new webpack.optimize.CommonsChunkPlugin(&#123; // 把公共的部分放到 manifest 中 name: &apos;manifest&apos;, // 传入 `Infinity` 会马上生成 公共chunk，但里面没有模块。 minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk // 提取动态组件 new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;app&apos;, // 如果设置为 `true`，一个异步的 公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。 // 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。 async: &apos;vendor-async&apos;, // 如果设置为 `true`，所有 公共chunk 的子模块都会被选择 children: true, // 最小3个，包含3，chunk的时候提取 minChunks: 3 &#125;), // copy custom static assets // 把static资源复制到相应目录。 new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), // 这里配置是static to: config.build.assetsSubDirectory, // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)// 如果开始gzip压缩，使用compression-webpack-plugin插件处理。这里配置是false// 需要使用是需要安装 npm i compression-webpack-plugin -Dif (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; // asset： 目标资源名称。 [file] 会被替换成原始资源。 // [path] 会被替换成原始资源的路径， [query] 会被替换成查询字符串。默认值是 &quot;[path].gz[query]&quot;。 asset: &apos;[path].gz[query]&apos;, // algorithm： 可以是 function(buf, callback) 或者字符串。对于字符串来说依照 zlib 的算法(或者 zopfli 的算法)。默认值是 &quot;gzip&quot;。 algorithm: &apos;gzip&apos;, // test： 所有匹配该正则的资源都会被处理。默认值是全部资源。 // config.build.productionGzipExtensions 这里是[&apos;js&apos;, &apos;css&apos;] test: new RegExp( &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), // threshold： 只有大小大于该值的资源会被处理。单位是 bytes。默认值是 0。 threshold: 10240, // minRatio： 只有压缩率小于这个值的资源才会被处理。默认值是 0.8。 minRatio: 0.8 &#125;) )&#125;// 输出分析的插件 运行npm run build --report// config.build.bundleAnalyzerReport这里是 process.env.npm_config_report// build结束后会自定打开 http://127.0.0.1:8888 链接if (config.build.bundleAnalyzerReport) &#123; // 更多查看链接地址：https://www.npmjs.com/package/webpack-bundle-analyzer const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;// 当然也可以用官方提供的网站 http://webpack.github.io/analyse/#home// 运行类似 webpack --profile --json &gt; stats.json 命令// 把生成的构建信息stats.json上传即可// 最终导出 webpackConfigmodule.exports = webpackConfig 至此，我们就分析完了package.json中的npm run dev和npm run build两个命令。测试相关的类似就略过吧。 npm run lint，.eslintrc.js中的配置不多，更多可以查看eslint英文文档或eslint中文官网，所以也略过吧。不过提一下，把eslint整合到git工作流。可以安装husky，npm i husky -S。安装后，配置package.json的scripts中，配置precommit，具体如下：1234&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;, &quot;precommit&quot;: &quot;npm run lint&quot;,&#125;, 配置好后，每次git commit -m提交会检查代码是否通过eslint校验，如果没有校验通过则提交失败。还可以配置prepush。husky不断在更新，现在可能与原先的配置不太相同了，具体查看husky github仓库。原理就是git-hooks,pre-commit的钩子。对shell脚本熟悉的同学也可以自己写一份pre-commit。复制到项目的.git/hooks/pre-commit中。不需要依赖husky包。我司就是用的shell脚本。 最后提一下.babelrc文件中的配置。 .babelrc babel相关配置配置了一些转码规则。这里附上两个链接：babel英文官网和babel的中文官网。 具体看文件中的配置注释：123456789101112131415161718192021222324&#123; // presets指明转码的规则 &quot;presets&quot;: [ // env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码 [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], // plugins 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。 // transform-vue-jsx 表明可以在项目中使用jsx语法，会使用这个插件转换 &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;], // 在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置 &quot;env&quot;: &#123; // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development &quot;test&quot;: &#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-es2015-modules-commonjs&quot;, &quot;dynamic-import-node&quot;] &#125; &#125;&#125; 文件中presets中有配置env和stage-2，可能不知道是什么。这里引用深入浅出webpack书中，第三章，3-1使用ES6语言 小节的一段，解释一下。 presets 属性告诉 Babel 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 Presets 可以叠加。 Presets 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作。Presets 是按照 ECMAScript 草案来组织的，通常可以分为以下三大类（书中就是说三大类，我发现就两点~~~）：1、已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为：es2015 包含在2015里加入的新特性；es2016 包含在2016里加入的新特性；es2017 包含在2017里加入的新特性；es2017 包含在2017里加入的新特性；env 包含当前所有 ECMAScript 标准里的最新特性。2、被社区提出来的但还未被写入 ECMAScript 标准里特性，这其中又分为以下四种：stage0 只是一个美好激进的想法，有 Babel 插件实现了对这些特性的支持，但是不确定是否会被定为标准；stage1 值得被纳入标准的特性；stage2 该特性规范已经被起草，将会被纳入标准里；stage3 该特性规范已经定稿，各大浏览器厂商和 社区开始着手实现；stage4 在接下来的一年将会加入到标准里去。 至此，就算相对完整的分析完了Vue-cli(版本v2.9.3)搭建的webpack项目工程。希望对大家有所帮助。项目放在笔者的github上，分析vue-cli@2.9.3 搭建的webpack项目工程。方便大家克隆下载，或者在线查看。同时也求个star ^_^，也是对笔者的一种鼓励和支持。笔者知识能力有限，文章有什么不妥之处，欢迎指出~ 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github 小结1、分析这些，逐行注释，还是需要一些时间的。其中有些不是很明白的地方，及时查阅相应的官方文档和插件文档（建议看英文文档和最新的文档），不过文档没写明白的地方，可以多搜索一些别人的博客文章，相对比较清晰明了。2、前端发展太快，这个`Vue-cli@2.9.3webpack版本还是v3.x，webpack现在官方版本已经是v4.12.0，相信不久后，Vue-cli也将发布支持webpack v4.x的版本，v3.0.0已经是beta.16了。 3、后续有余力，可能会继续分析新版的vue-cli构建的webpack`项目工程。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/tags/Vue/"},{"name":"Vue-cli","slug":"Vue-cli","permalink":"https://lxchuan12.github.io/tags/Vue-cli/"},{"name":"webpack","slug":"webpack","permalink":"https://lxchuan12.github.io/tags/webpack/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}]},{"title":"win10 安装 oh my zsh 和 window git bash 设置别名提高效率","slug":"20180603-oh my zsh - window git bash alias","date":"2018-06-03T15:19:55.030Z","updated":"2018-07-28T06:52:59.740Z","comments":true,"path":"2018/06/03/20180603-oh my zsh - window git bash alias/","link":"","permalink":"https://lxchuan12.github.io/2018/06/03/20180603-oh my zsh - window git bash alias/","excerpt":"","text":"安装 oh my zsh公司使用Ubuntu系统。自己安装了 oh my zshoh my zsh官网。这里简述下安装方法1234567891011121314151617181920echo $SHELL// /bin/bash 默认是bash// 查看下有哪些shellscat /etc/shells// # /etc/shells: valid login shells// /bin/sh// /bin/bash// /bin/rbash// /bin/dash// /usr/bin/tmux// /usr/bin/screen// /bin/zsh// /usr/bin/zshsudo apt-get install zshzsh --version// 5.1.1// 安装后zsh 后cat /etc/shells 才有/bin/zsh /usr/bin/zsh// 切换成zshchsh -s /bin/zsh 123456// 两种安装方案可供选择：// Via curl$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;// Via Wget$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装成功后，配置信息会在~/.zshrc。可以通过vim ~/.zshrc打开编辑zsh配置信息，可以看到默认配置了git 插件Plugin:git。也就是说，可以更加简便的使用git 相关的一些别名。1234// 比如`git status`时，只需要输入`gst`。`git pull` 时，只需要输入`gl`。`git push 时，只需要输入`gp`等等。 是因为配置里有这些简写，oh my zsh plugin git.plugin.zsh。安装成功后，同时会创建~/.oh-my-zsh的文件夹，其实就是.oh-my-zsh 的 git 仓库master分支。可以发现文件夹中有一个plugins文件夹，内置了很多插件。可以自定义主题theme，具体可以看example.zsh-theme。custom自定义相关。插件相关会安装在这里，更多可以查看example.plugin.zsh 我暂时安装了这几个插件。123456789101112plugins=( // 内置插件，启用即可 git cp mv // 按两下esc键，用sudo权限 sudo // 记录历史输入的zsh命令，自动提示，快速使用 zsh-autosuggestions // zsh 命令高亮 zsh-syntax-highlighting) 顺带讲下后面两个插件的安装方法安装 zsh-autosuggestions1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 安装zsh-syntax-highlighting1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting $ZSH_CUSTOM 其实是个变量，代表这个路径~/.oh-my-zsh/custom，也就是安装到了这个目录下。还有很多高效插件，等您发掘~oh my zsh官网不过插件安装多了，感觉会有些卡顿~1234// 每次修改了这个`.zshrc`配置文件，需要重载一下，才能生效。source .zshrc// 也可以封装成一个简写命令 aliasalias rl=&apos;source ~/.zshrc&apos; 也可以在这个配置文件中配置更多alias。oh my zsh命令工具确实好用，但还没买mac，又不想用ubuntu的童鞋怎么办呢~win10 支持安装ubuntu等子系统，就可以安装oh my zsh, 学习linux了。 windows 10 安装 Ubuntu 子系统，安装oh my zsh之前偶然发现自己电脑windows 10 有类似linux 功能（虽然这功能之前就有印象，但没去研究），这里有篇简短介绍文章：微软官方 Ubuntu for Win10 版免费 Linux 子系统下载！一键安装运行超简单 竟然也可以安装oh my zsh官网。想学习 linux 又不想安装 linux 系统，这时候可以用win10自带的Ubuntu。发现这篇写的比较详细，笔者就不再赘述了。笔者安装ubuntu 18.04子系统后，文件目录在这个路径下。C:\\Users\\lxchuan12\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\\LocalState\\rootfsWin10 环境下安装配置 zsh win10安装了ubuntu子系统和oh my zsh后，则可以通过/mnt/f/访问win10下的f盘，或者其他盘。1234// 比如跳转到工作目录alias dgg=&apos;cd /mnt/f/git-source/github&apos;// vscode 打开要编辑的文件或文件夹code sticky-notes 也就是相当于win10下解锁了oh my zsh。那不是win10，也想通过设置别名来提高效率，是不是就没有办法了呢，可以使用git bash设置alias，安装git，自带git bash。 windows git bash 设置别名提高效率windows 桌面或任意资源管理器位置，右击，选择Git Bash Here，即打开了git bash命令行。先设置下主题，右击选择options, Looks &gt; theme &gt; dracula我选择的是dracula主题，看起来比较舒适。还可以设置字体等。12345678// 跳转到根路径cd ~// 查看下是否有.bash_profile文件la// 如果没有.bash_profile文件，需要创建touch .bash_profile// 打开编辑 （笔者这里安装了vscode，所以直接用其打开文件）code .bash_profile 可以根据修改设置一些别名。比如我们常用的git status命令，可以封装成gst。清屏clear命令封装成cls。12alias gst=&apos;git status&apos;alias cls=&apos;clear&apos; 每次修改这个文件需要输入source ~/.bash_profile重载这个文件，才会生效。code ~/.bash_profile，用vscode编辑这个配置文件，封装成一个命令。比如：12alias rl=&apos;source ~/.bash_profile&apos;alias bashconfig=&apos;code ~/.bash_profile&apos; 这样每次修改保存后就只需要输入rl，即可重载生效了。还可以把一些工作目录封装，笔者的一些项目是放在/f/git-source/github文件下。1234// github上的项目alias dgg=&apos;cd F:/git-source/github&apos;// 周报相关alias dcwk=&apos;cd F:/git-source/coding/weekly&apos; 每次进入项目，就直接dgg，即可跳转到这个目录，然后选择相应的目录即可。比如dgg进入工作目录，cd analyse-vue-cli进入项目目录,（输入anal按tab键智能提示）12345// /f/git-source/github/analyse-vue-cli (dev)// 查看状态 git statusgst// 用vscode 打开这个文件夹，开始编辑~code ./ git 相关的，例举一些平时用的比较多的。123456789101112131415161718alias g=&apos;git&apos;alias ga=&apos;git add&apos;alias gaa=&apos;git add -all&apos;alias gp=&apos;git push&apos;alias gl=&apos;git pull&apos;alias gcmsg=&apos;git commit -m&apos;// 分支相关alias gb=&apos;git branch&apos;alias gbr=&apos;git branch -r&apos;alias gba=&apos;git branch -a&apos;// checkoutalias gco=&apos;git checkout&apos;alias gcb=&apos;git checkout -b&apos;// mergealias gm=&apos;git merge&apos;// diffalias gd=&apos;git diff&apos;alias gdw=&apos;git diff --word-diff&apos; 更多可以把oh my zsh的插件一些命令拷贝过来，留alias相关的即可，oh my zsh plugin git.plugin.zshPlugin:git wiki相当于解锁了oh my zsh 的git插件。还有很多插件，比如npm点击查看, node 等，都可以研究下。 git bash，有没有类似oh my zsh的插件呢，笔者暂时没发现，如果您知道，欢迎告诉笔者。目录相关的操作，也可以设置一些别名。比如：123456// 回退到上一级alias ..=&apos;cd ..&apos;alias ...=&apos;cd ../..&apos;alias ....=&apos;cd ../../..&apos;alias .....=&apos;cd ../../../..&apos;alias ......=&apos;cd ../../../../..&apos; 更多别名可以自定义～windows上命令行工具还可以使用cmder点击查看cmder官网命令行工具。虽然笔者几年前就安装了，但发现还是git bash用的顺畅些，可能是我还不太习惯cmder。关于cmder配置相关，这里推荐晚晴幽草轩轩主的一篇文章：《Win下必备神器之Cmder》 也有cygwin，也是windows命令行工具，也可以安装on my zsh。 当然，git也是可以设置别名的。 git设置别名，使用tig神器12// git status =&gt; git stgit config --global alias.st status 更多可以查看廖雪峰老师的这篇文章git 配置别名。不过可能大多数人不知道，他们可能用着可视化工具。笔者觉得可视化工具也是对git的一些封装，具体背后是什么命令，我们还是需要去了解熟悉的。命令行使用git，笔者推荐使用tig。git log增强版，性能很好。Ubuntu、linux、mac可以直接安装，windows稍微麻烦些。具体安装方法查看tig github仓库中的官方安装文档，或者查看这篇文章：颠覆 Git 命令使用体验的神器 – tig 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github 小结磨刀不误砍柴工，花时间折腾研究工具，有利于提高开发效率。 最新更新于 2018-07-28 14:46:08 文章首发于segmentfault win10 安装 oh my zsh 和 windows git bash 设置别名提高效率","categories":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/tags/git/"},{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/tags/tool/"},{"name":"zsh","slug":"zsh","permalink":"https://lxchuan12.github.io/tags/zsh/"},{"name":"oh my zsh","slug":"oh-my-zsh","permalink":"https://lxchuan12.github.io/tags/oh-my-zsh/"},{"name":"git bash","slug":"git-bash","permalink":"https://lxchuan12.github.io/tags/git-bash/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://lxchuan12.github.io/tags/ubuntu/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}]},{"title":"vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴","slug":"20180515-vue qrcode clipboard","date":"2018-05-15T16:15:21.000Z","updated":"2018-11-23T12:28:39.759Z","comments":true,"path":"2018/05/16/20180515-vue qrcode clipboard/","link":"","permalink":"https://lxchuan12.github.io/2018/05/16/20180515-vue qrcode clipboard/","excerpt":"近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。老模块是用的qrocode中文文档，qrcode github。 先想着新模块中是否有生成二维码的插件，看了下package.json。有安装一个vue-qriously…","text":"近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。老模块是用的qrocode中文文档，qrcode github。 先想着新模块中是否有生成二维码的插件，看了下package.json。有安装一个vue-qriously…但搜索了一下，竟然没有使用，可能是因为很多二维码都是后端生成返回链接给前端的。而在其他H5、微信项目中使用了。看了下这个项目star数是113。但我不想重新引入老模块的qrcodejs，重新引入其他的二维码插件，相对比较麻烦。于是就保持统一用vue-qriously了。猜想当时引入这个是vue 资源合集awesome-vue中，qrcode相关第一个就是vue-qriously。 vue-qriously插件使用12345// 入口js文件// npm install vue-qriously -Simport Vue from &apos;vue&apos;;import VueQriously from &apos;vue-qriously&apos;;Vue.use(VueQriously); 1234567891011121314151617181920// vue 文件&lt;template&gt; &lt;qriously :value=&quot;value&quot; size=&quot;size&quot; :backgroundAlpha=&quot;backgroundAlpha&quot;/&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, data()&#123; return &#123; // 可以自定义，必填项。 value: &apos;http://lxchuan12.github.io/&apos;, // 二维码大小 默认 100 size: 80, // 背景透明度，默认透明 0 backgroundAlpha： 1, &#125; &#125;&#125;&lt;/script&gt; 更多参数配置可以查看：github 仓库 v-qriously.vue源码查看代码可以发现，开头引用了qrious，这个star就多一点，600多。1import Qrious from &apos;qrious&apos; qrious github 地址qrious 文档 下载二维码粗略的翻看下以上相关文档，写完正准备要做下载功能。这时发现，哎呀，竟然就是只生成了一个canvas。于是百度(暴露了用百度…我也想用谷歌，但现在不行…)了下canvas如何转图片。stackoverflow Capture HTML Canvas as gif/jpg/png/pdf?12345var canvas = document.getElementById(&quot;mycanvas&quot;);var imgSrc = canvas.toDataURL(&quot;image/png&quot;);document.write(&apos;&lt;img src=&quot;&apos;+img+&apos;&quot;/&gt;&apos;);// 搜索到一些其他的方案，感觉挺麻烦。// 嗯，这个简单。想着我们项目兼容性没什么要求，于是就用这个了。 生成了img的src资源，那么就可以下载了。123456// 老模块是用的`jquery` + `seajs` + `vue1.x`// 新模块尽量要去除`jquery`。let src = $(&apos;.img&apos;).src;let aLink = $(&apos;&lt;a&gt;&lt;/a&gt;&apos;).attr(&apos;href&apos;, src).attr(&apos;download&apos;, &apos;xxx二维码.png&apos;).appendTo(&apos;body&apos;);aLink[0].click();aLink.remove(); 1234567// 新模块 去除jquerylet elem = document.createElement(&apos;a&apos;);elem.setAttribute(&apos;href&apos;, imgSrc);elem.setAttribute(&apos;download&apos;, &apos;xxx二维码.png&apos;);document.body.appendChild(elem);elem.click();document.body.removeChild(elem); 但这样写也相对比较麻烦。项目中封装了一个v-click指令。1234567891011121314151617181920212223/** * vClick 触发点击 * @type &#123;Object&#125; */export const vClick = &#123; directives: &#123; click: &#123; /** * 值更新时候触发点击 * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt; * @date 2018-05-15 * @param &#123;HTMLElement&#125; el 指令所绑定的元素 * @param &#123;Boolean&#125; options.value 绑定值(新) * @param &#123;Boolean&#125; options.oldValue 绑定值(旧) */ update(el, &#123; value, oldValue &#125;)&#123; if(value &amp;&amp; !oldValue)&#123; el.click(); &#125; &#125;, &#125;, &#125;,&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt;&lt;div&gt; &lt;div class=&quot;img&quot; v-show=&quot;listShareShow&quot;&gt; &lt;qriously id=&quot;qriously&quot; :backgroundAlpha=&quot;1&quot; :value=&quot;listSharingLink&quot; :size=&quot;160&quot; v-show=&quot;false&quot;/&gt; &lt;img :src=&quot;listSharingLinkSrc&quot; alt=&quot;xxx二维码&quot;&gt; &lt;/div&gt; &lt;a :href=&quot;exportLink&quot; v-click=&quot;download&quot; :download=&quot;downloadFilename&quot;&gt;&lt;/a&gt; &lt;a @click.stop=&quot;listShare&quot;&gt;查看链接/二维码&lt;/a&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 提取出主要代码 data()&#123; retrun &#123; // 下载 download: false, downloadFilename: &apos;xxx二维码&apos;, listSharingLinkSrc: &apos;&apos;, listSharingLinkSrc: &apos;&apos;, listShareShow: false, &#125; &#125;, // ... methods: &#123; /** * 查看链接/二维码 * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt; * @date 2018-05-15 */ listShare(event)&#123; if(!this.listSharingLinkSrc)&#123; let canvas = document.querySelector(&apos;#qriously canvas&apos;); let imgSrc = canvas.toDataURL(&apos;image/png&apos;); this.listSharingLinkSrc = imgSrc; &#125; this.listShareShow = !this.listShareShow; &#125;, /** * 表格上方：下载二维码列表 * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt; * @date 2018-05-15 */ downloadQrcode(event, linkSrc, downloadFilename)&#123; event.stopPropagation(); this.exportLink = linkSrc; this.downloadFilename = downloadFilename; this.download = true; this.$nextTick(() =&gt; &#123; this.exportLink = &apos;&apos;; this.download = false; this.downloadFilename = &apos;&apos;; &#125;); &#125;, &#125;,&#125;;&lt;/script&gt; 代码写到这里，嗯，实现完了下载。但又发现又一需求，显示大小是80 * 80，下载需要是160 * 160。 显示大小和下载大小不一样。参考了下老模块，qrcodejs渲染出来的html,12345// 跟这个类似&lt;div id=&quot;qrcode_1&quot; title=&quot;your content&quot;&gt; &lt;canvas width=&quot;256&quot; height=&quot;256&quot; style=&quot;display: none;&quot;&gt;&lt;/canvas&gt; &lt;img alt=&quot;Scan me!&quot; style=&quot;display: block;&quot; src=&quot;data:image/png;base64,xxx&quot;&gt;&lt;/div&gt; vue-qriously渲染出来是123&lt;div&gt; &lt;canvas width=&quot;80&quot; width=&quot;80&quot;&gt;&lt;/canvas&gt;&lt;/div&gt; 于是我可以把生成的imgSrc资源,123456789101112&lt;template&gt;&lt;div&gt; &lt;canvas width=&quot;160&quot; width=&quot;160&quot; v-show=&quot;false&quot;&gt;&lt;/canvas&gt; &lt;img class=&quot;img&quot; :src=&quot;imgSrc&quot;/&gt;&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;.img&#123; width: 80px; height: 80px;&#125;&lt;/style&gt; 这就实现了下载的资源是160 * 160，用样式控制图片显示80 * 80。代码写完，觉得应该给vue-qriously写个pr,实现 不仅仅是渲染canvas，而是让大家可以选择时img还是canvas。又去翻了翻这个项目的issue,有一个issue链接：how to make this canvas exchange to img 就是说的这个。还没关闭。1i think u can create type let user select img and canvas. 12// 有一个回复If you want to make it become downloadable, maybe you can transform it from canvas easily by canvas.toDataURL() 文章写到这里，我发现这样似乎不太妥。我的场景，是点击时显示浮层（浮层有二维码和复制链接地址和下载二维码按钮等），获取canvas元素，去转成img src，再去渲染到页面，而且图片可能会闪，因为是实际大小是160，样式强制控制在80。何不生成两份，一份是用来获取资源下载的。一份用来显示的。嗯，之后去优化下。顺带说一下，复制粘贴 cliploard 复制粘贴老模块中是用的cliploardclipboard github仓库。就是我引入的。 新模块还没使用过，但依然使用这个。1234567891011121314151617181920212223// 安装// npm install clipboard --save&lt;template @click=&quot;Clip($event, &apos;快来复制&apos;)&quot;&gt;&lt;template&gt;// 封装成一个函数import Clipboard from &apos;clipboard&apos;;export default function Clip(event，text) &#123; const clipboard = new Clipboard(event.target, &#123; text: () =&gt; text &#125;); clipboard.on(&apos;success&apos;, () =&gt; &#123; console.log(&apos;复制成功&apos;); clipboard.off(&apos;error&apos;); clipboard.off(&apos;success&apos;); clipboard.destroy(); &#125;); clipboard.on(&apos;error&apos;, () =&gt; &#123; console.log(&apos;复制失败，请刷新试试&apos;); clipboard.off(&apos;error&apos;) clipboard.off(&apos;success&apos;) clipboard.destroy() &#125;); clipboard.onClick(event);&#125; 当然也可以封装成vue指令。可以参考vue-element-admin这个项目之前我看的时候还是3000多star，现在1.2w+，说明值得学习。另外推荐awesomes网站 工具类库合集 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github 小结1、引入第三方插件等使用时，多查看github 文档 issue等，在技术社区搜索别人使用的方案。2、选用第三方插件时，尽可能挑选star比较多的，issue处理比较及时的，在更新维护的。3、富余时间可以多研究下别人的项目是如何组织文件，和实现的一些常用功能的。4、尽可能去优化自己的代码，总结回顾。 文章首发于vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/tags/Vue/"},{"name":"qrcode","slug":"qrcode","permalink":"https://lxchuan12.github.io/tags/qrcode/"},{"name":"clipboard","slug":"clipboard","permalink":"https://lxchuan12.github.io/tags/clipboard/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}]},{"title":"参加有赞前端技术开放日所感所想","slug":"20180421-youzan front-end tech open day","date":"2018-04-21T12:08:26.000Z","updated":"2018-05-27T06:07:07.006Z","comments":true,"path":"2018/04/21/20180421-youzan front-end tech open day/","link":"","permalink":"https://lxchuan12.github.io/2018/04/21/20180421-youzan front-end tech open day/","excerpt":"从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。之前参加过网易云课堂学习节、拉勾网理想之上、coding.net 技术小馆、阿里D2两次、阿里work like alibaba沙龙、freeCodeCamp线下分享等…自己也参与到freeCodeCamp(FCC)，点击访问freeCodeCamp，杭州线下分享活动的组织中","text":"从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。之前参加过网易云课堂学习节、拉勾网理想之上、coding.net 技术小馆、阿里D2两次、阿里work like alibaba沙龙、freeCodeCamp线下分享等…自己也参与到freeCodeCamp(FCC)，点击访问freeCodeCamp，杭州线下分享活动的组织中 为什么这么热衷于参加这类活动呢？可能拿之前D2填写的参会理由可以很好的解答这个问题。 D2报名填写的参会理由:1、了解讲师碰到的问题，有哪些解决方案，是如何解决的，学习他们的解决思路和方案。2、了解现在前端技术发展情况和未来发展趋势，把握学习方向。3、结交前端圈内朋友，让自己融入到更积极的技术氛围，促进自己的技术提升。 为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？刚好看到知乎上有这个帖子。参加有赞前端技术开放日是种怎样的体验？ 因为之前都是免费的活动。好像也没什么可写的。觉得发条朋友圈简明扼要的总结下即可。这次有赞的活动是收费的，都这么多人参加，直播观看量3w人次（最高时），而且有其他城市的人过来。比如：罗辑思维（北京），简书（上海）。可见前端圈的小伙伴对参与这类活动也是十分活跃的，同时说明了有赞宣传的比较好。所以，觉得有必要写一下。技术方面不多写，可以回看PPT，或视频。 可以看下官方微信公众号发布的活动总结文章，里面有PPT，视频回放等。有赞技术活动首秀——有赞前端技术开放日圆满结束主题主要有：1、主题一：有赞开源项目最佳实践2、主题二：本地调试线上代码——已开源，点击访问ZanProxy3、主题三：让前后端协作更高效——ZanAPI4、主题四：Node 在有赞的实践5、主题五：有赞内部代码管理工具串讲 为什么会有这么多产出，主要有三点：1、业务逼的2、工程师文化3、注重技术基础 感觉就是有赞前端技术团队，碰到什么问题，奔着高效工作的目的，提出解决方案，团队内部适用、推广，最后把做得比较好的项目开源。总之有赞前端技术团队靠谱、有追求。值得加入。 我是12点多到达场地。这时人还不多。拍了两张照。 回顾一下整场活动，主要有六点：1、人脉圈子 有赞前端技术负责人施德来（下文简称德来）分享的缘起，说杭州兑吧公司想去有赞参观参观，交流交流。于是干脆办一个技术开放日。然后邀请了杭州一些公司来参与。比如点我达、丁香园、兑吧等。说明杭州各个公司的前端负责人的有技术圈子，都相互认识熟悉，而且比较注重交流。有人脉圈子，对于程序员来说，很重要。 2、正向反馈虽然有赞搞了很多成功的项目，但也有失败的项目。所有的失败项目，总结起来，就一条：没有准确估计投入产出比。就是说没有正向反馈，就最后不了了之了。平时自己学习也是如此，如果没能看到正反馈，很难坚持下去。 3、演讲能力 德来宣称他们内部演讲已经练习过几次了。程序员可能比较欠缺演讲能力，毕竟很少机会上台面对上百人演讲，分享技术。 4、救场解围Q/A问答环节，可能有些问题讲师解答不是很清晰，或者说提问者不停追问，就容易导致僵持下去，现场尴尬，时间不可控等。于是好几次都是德来来解答提问者的问题。 5、技术（开源）项目本质上是：理念、套路、规范的工具化。这句话是德来说的，印象比较深刻。比如开源的项目点击访问felint就是一个集成了 eslint、stylelint、git hook 的前端代码检查工具。规范定好，提交代码时强制校验，或者说随你怎么写，代码都一样，最后提交会验证一遍。我司用的就是githooks git commit 时校验代码规范性。 6、参与到开源项目有余力的情况下，可以参与到开源项目，也是对自己的一种提升。 最后放两张照片","categories":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/tags/随笔/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}]},{"title":"2017年度总结，一如既往","slug":"20180105-2017-annual-summary","date":"2018-01-05T15:56:52.000Z","updated":"2018-01-10T14:33:54.066Z","comments":true,"path":"2018/01/05/20180105-2017-annual-summary/","link":"","permalink":"https://lxchuan12.github.io/2018/01/05/20180105-2017-annual-summary/","excerpt":"斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。 年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…","text":"斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。 年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…翻看着电脑上【N-年度总结】文件夹中2014~2016年年度总结。一般文件夹中有一份PPT和一份思维导图。 新建了一个【2017年】的文件夹，翻看2017年微博整理出2017微博时间轴，继而整理出2017年的各个方面的思维导图。 再看看2017年年初的年度大体计划，付出、收获这样的词汇，似乎不太合适。2018年的年度计划不敢写了。 如果说2015年关键词是PPT，2016年说是毕业、开发，那么2017年依旧是开发。2017年和2016年基本一样，没什么波澜，一如既往。 “丰富多彩的生活”1月份，过年期间去舅舅家拜年，舅舅和姐夫都说我2016年工作后变了挺多，尤其酒量不错。大学室友说我工作后比较爱玩了，大学期间比较喜欢宅在寝室。其实我是那种宅也可以，游山玩水也可以的一类人。 12月份，和一朋友聊天，她说了一句：看你朋友圈各方面蛮精彩的。想起高中关系比较好的几个同学都在985、211读研，虽然他们表示比较羡慕我朋友圈发的”丰富多彩”的生活，但我也比较羡慕他们的。这也许就是人们常说的围城吧。城外的人想进城，城里的人想出城。 但事实上，我们总是习惯地去推测：看到一个人去图书馆，就推测TA博览群书。看到一个人发朋友圈在旅行，就推测TA经常在旅行。看到一个人去参加各种线下活动学习，就推测TA经常去参加这类活动。于是将美好的别人与糟糕的自己对比，从而心生羡慕。但往往这种推测不准确。 身体健康这一年，每天基本都是12点10分左右，有时睡得比较晚上班就容易打哈欠，同事开玩笑说是不是早起偷能量了。 基本也没怎么锻炼，（半小时左右）上半年基本走路上下班，下半年就成基本骑车上下班了。 年初体检了一次，年底体检了一次，虽无大碍，但还是要注意身体。体检时听到体检机构的工作人员讨论，别看现在的年轻人年轻，但他们经常很晚才睡，熬夜，不吃早餐等。是啊，年轻人更应该注意身体，尤其是IT行业的程序员。 慢慢打造“个人品牌”这一年，换了工作，在前端开发上有所成长，偶尔会在segmentFault社区答题，主要是10月份，一个月声望值增长976分。月度排行榜排名第六。现在声望值2.2K。虽然比较少，但基本是今年才涨的。全年只在segmentFault社区、掘金发布了两篇文章。 5月份，开通了“前端视野”，知识星球（原“小密圈”），偶尔发一些前端开发相关的知识和感想，没怎么推广的情况下，没想到到年底有91人加入。 很多人努力学习知识，参加各种沙龙，向前辈学习，参加开源项目，把自己的心得无私的分享出来，慢慢的，他们踏上了不一样的平台，快速成长。 这样努力的人我朋友圈就有一位。毕业四年在北京，月薪早已超出同龄人的水平。但基本学习到2点左右睡，6:50起，午休睡一会，一般一天不少于6小时。还读着英文文档，玩转各种开发语言。想想我身边他这层次的人也没有这么拼啊，他解释道：个人追求也不同，追求也不一样。他都这样的努力确实让我敬佩不已。真是应了那句话：比你优秀的人不可怕，可怕的是比你优秀的人比你更努力。 旅行这一年，清明假期和同学去了江苏无锡鼋头渚、惠山古镇、三国城等。太湖四月天，无锡鼋头渚。登上赏樱楼，樱花似白雪。惠山古镇，历史悠久，古迹众多，人文荟萃。宝界山林，远眺太湖。湖光山色，相映生辉。 五一假期去了浙江舟山。人生中的第一次看海，海上日出日落。 随便放了几张照片。2017年初上写的旅行计划去黄山、上海、出境游通通没有实现，现实版的计划赶不上变化，是多么痛的领悟。 危机感5月13日，和课题组的两位同学，一起回学校参加课题组老师的婚礼，老师说：“到时你们婚礼的时候派代表参加”。一次和毕业几年的表哥聊天，聊到年轻的时候最重要的两件事就是结婚和买房。同事也会问准备一直在杭州吗。感觉这类话题，不管和谁聊天都会聊到。我就感慨到：现如今，大学毕业生靠自己在杭州买房，真是难于上青天。 到底有多难，我大概算了下。假如杭州郊区算3万一平，那么一套房算300万，首付30%则需90万。假如一年存款能有10万，那么也要攒9年。你可能会说工资会涨，但可以肯定没有房价涨得快…而且只是付完首付而已，就要9年。9年后又到了人们常说的中年危机，面对各方面的压力，那么以后的日子更加艰难。照这样想想都后怕。但在大城市还是有一定机会的，虽然比较渺茫。退一步回老家买房，但小县城房价均价据说都6K+了。而且感觉在老家买房，自己在外漂泊也不是办法啊。 写到这里，看到统计的字数是1818字，刚好2018年，很吉利。2017年度总结算是收尾了。","categories":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/tags/年度总结/"}],"keywords":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}]},{"title":"JavaScript设计模式与开发实践 读书笔记 - 未完待续...不用点开了~","slug":"20171205-JavaScript design patterns","date":"2017-12-05T15:25:01.000Z","updated":"2018-06-23T13:41:18.067Z","comments":true,"path":"2017/12/05/20171205-JavaScript design patterns/","link":"","permalink":"https://lxchuan12.github.io/2017/12/05/20171205-JavaScript design patterns/","excerpt":"","text":"看完此书，打算慢慢整理下读书笔记。便于巩固消化。 第一部分 基础知识第二部分 设计模式4.单例模式定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。例子比如弹窗 通用的惰性单例123456var getSingle = function(fn)&#123; var result; return function()&#123; return result || (result = fn.apply(this, arguments)); &#125;&#125; 第三部分 设计原则和编程技巧","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"移动端双击事件和PC端","slug":"20171204-mobile pc dblclick","date":"2017-12-04T13:37:29.000Z","updated":"2017-12-04T14:49:57.395Z","comments":true,"path":"2017/12/04/20171204-mobile pc dblclick/","link":"","permalink":"https://lxchuan12.github.io/2017/12/04/20171204-mobile pc dblclick/","excerpt":"","text":"SF上，有个问题想请教一下，一般类似于微信那样的，双击屏幕回到顶部是怎么做的呀？刚开始我回答的直接是：1234// 原生JS、PC端可以在`body`上添加双击事件document.addEventListener(&apos;dblclick&apos;, function()&#123; window.scrollTo(0, 0);&#125;); 在PC端测试了下，没问题。然后再看到别人的回答，似乎好像在移动端不起作用。于是用Chrome浏览器的移动端模拟试了下果然没用。然后百度搜索了下，看到两篇文章移动手机端不能触发jQuery双击事件dblclick解决方法，双击事件dblclick在移动端不起作用？，加上了下面的答案。测试通过。12345678910111213// 移动端双击不起作用。// 可以用单击事件模拟var touchTime = Date.now();function handleClick()&#123; if( Date.now() - touchTime &lt; 800 )&#123; window.scrollTo(0, 0); &#125;else&#123; //如果第二次点击在第一次点击0.8秒后， //则第二次点击默认为下一次双击判断的第一次点击 touchTime = Date.now(); &#125;&#125;document.addEventListener(&apos;click&apos;, handleClick); 那么问题又来了，我知道直接在document上挂载事件是正确的。但为什么不用document.body呢，我一下说不上来。document.body是&lt;body&gt;&lt;/body&gt;。是只适用于HTML对象的DOM对象。类似这样的还有123456document.images -- 当前页面中所有图片的集合。等价于Core DOM组件中的document.getElementsByTagName(&apos;img&apos;)调用。document.applets -- 等价于document.getElementsByTagName(&apos;applets&apos;)。document.links -- 是一个列表，包含了页面中所有的`&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;`标签，也就是页面中所有含有`href`属性的A标签。document.anchors -- 是包含所有带name熟悉的链接。即`&lt;a name=&quot;...&quot;&gt;&lt;/a&gt;`document.forms -- 用的比较广泛。forms标签的集合。document.forms[0] === document.getElementsByTagName(&apos;form&apos;)[0]// 以上只适用于`HTML`对象的`DOM`对象内容，摘抄于《JavaScript面向对象编程指南 · 第2版》 我们常见的获取元素是document.querySelector(&#39;body&#39;)，document.getElementById()，或者document.getElementsByClassName(),document.getElementsByTagName(),document.getElementsByName()等。于是我谷歌了一下，document和document.body却出来了document.ducumentElement的对比。我们知道document.documentElement是HTML节点。123456Object.prototype.toString.call(document)&quot;[object HTMLDocument]&quot;Object.prototype.toString.call(document.body)&quot;[object HTMLBodyElement]&quot;Object.prototype.toString.call(document.documentElement)&quot;[object HTMLHtmlElement]&quot; 12345var divNode = document.createElement(&apos;div&apos;);document.appendChild(divNode);// 报错：// VM396:1 Uncaught DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: Only one element on document allowed.document.body.appendChild(divNode); 我翻了翻w3c规范W3C 标准内容列表1.文档对象模型（核心）级别1 1234Object.getOwnPropertyDescriptors(document);// &#123;location: &#123;&#125;&#125;document.location === window.location;// true 未完待续…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"你不知道的JavaScript上卷-读书笔记 - 未完待续...不用点开了~","slug":"20171026-you don't know js-1","date":"2017-10-26T15:36:52.000Z","updated":"2018-06-20T13:13:08.541Z","comments":true,"path":"2017/10/26/20171026-you don't know js-1/","link":"","permalink":"https://lxchuan12.github.io/2017/10/26/20171026-you don't know js-1/","excerpt":"","text":"前言：你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之后， 无论什么技术、 框架和流行词语你都能轻松理解。使用代码示例可以在这里下载本书第一部分“作用域和闭包” 随附的资料（代码示例、 练习题等） ：http://bit.ly/1c8HEWF。可以在这里下载本书第二部分“this 和对象原型” 随附的资料（代码示例、 练习题等） ：http://bit.ly/ydkjs-this-code要了解更多 O’Reilly 图书、 培训课程、 会议和新闻的信息， 请访问以下网站：http://www.oreilly.com我们在 Facebook 的地址如下： http://facebook.com/oreilly请关注我们的 Twitter 动态： http://twitter.com/oreillymedia我们的 YouTube 视频地址如下： http://www.youtube.com/oreillymedia要查看“你不知道的 JavaScript” 系列丛书中的全部图书， 请访问：http://YouDontKnowJS.com 第一部分 作用域和闭包知其然， 也要知其所以然。 第一章 作用域是什么分词/词法分析（Tokenizing/Lexing）这个过程会将由字符组成的字符串分解成（对编程语言来说） 有意义的代码块， 这些代码块被称为词法单元（token）。 例如， 考虑程序 var a = 2;。 这段程序通常会被分解成为下面这些词法单元： var、 a、 =、 2 、 ;。 空格是否会被当作词法单元， 取决于空格在这门语言中是否具有意义。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"JavaScript正则表达式迷你书-阅读笔记","slug":"20171012-JavaScript regex mini books reading record","date":"2017-10-12T15:45:52.000Z","updated":"2017-10-21T15:52:11.461Z","comments":true,"path":"2017/10/12/20171012-JavaScript regex mini books reading record/","link":"","permalink":"https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/","excerpt":"","text":"正则可视化工具正则可视化工具-regexper正则在线测试工具-regex101 勘误：2.4.2.5. 格式化$ 1888.00 -&gt; $ 1,888.00 3.3.1. 括号嵌套怎么办？最后的是 \\4，找到第3个开括号 -&gt; 最后的是 \\4，找到第4个开括号 3.5.6. 匹配成对标签其中开标签 &lt;[\\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt; -&gt; 其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt; 5.1. 结构和操作符在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构—&gt;按照原文：这里的因此应该不标红。 6.3.2. 匹配浮点数因此整个正则是这三者的或的关系，提取公众部分后是：—-&gt;公共部分 [《JavaScript 正则表达式迷你书》问世了！]（https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social） 记录一些学到的1. 第一章 正则表达式字符匹配攻略1.2.1. 范围表示法因为连字符有特殊用途，那么要匹配 “a”、”-“、”z” 这三者中任意一个字符，该怎么做呢？不能写成 [a-z]，因为其表示小写字符中的任何一个字符。可以写成如下的方式：[-az] 或 [az-] 或 [a-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 1.2.3. 常见的简写形式如果要匹配任意字符怎么办？可以使用 [\\d\\D]、[\\w\\W]、[\\s\\S] 和 [^] 中任何的一个。 1.3.2. 贪婪匹配与惰性匹配其中 /\\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。 1.4. 多选分支但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 “goodbye” 字符串时，结果是 “good”： 1234var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;good&quot;] 1234var regex = /goodbye|good/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;goodbye&quot;] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 1.5.1. 匹配 16 进制颜色值1234var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;console.log( string.match(regex) );// =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;] 1.5.2. 匹配时间12345var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;console.log( regex.test(&quot;23:59&quot;) );console.log( regex.test(&quot;02:07&quot;) );// =&gt; true// =&gt; true 如果也要求匹配 “7:9”，也就是说时分前面的 “0” 可以省略。此时正则变成： 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test(&quot;23:59&quot;) );console.log( regex.test(&quot;02:07&quot;) );console.log( regex.test(&quot;7:9&quot;) );// =&gt; true// =&gt; true// =&gt; true 1.5.3. 匹配日期123var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;console.log( regex.test(&quot;2017-06-10&quot;) );// =&gt; true 1.5.4. window 操作系统文件路径123456789var regex = /^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?$/;console.log( regex.test(&quot;F:\\\\study\\\\javascript\\\\regex\\\\regular expression.pdf&quot;) );console.log( regex.test(&quot;F:\\\\study\\\\javascript\\\\regex\\\\&quot;) );console.log( regex.test(&quot;F:\\\\study\\\\javascript&quot;) );console.log( regex.test(&quot;F:\\\\&quot;) );// =&gt; true// =&gt; true// =&gt; true// =&gt; true 1.5.5. 匹配 id12345// 解决之道，可以使用惰性匹配：var regex = /id=&quot;.*?&quot;/var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;console.log(string.match(regex)[0]);// =&gt; id=&quot;container&quot; 当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下： 12345var regex = /id=&quot;[^&quot;]*&quot;/var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;console.log(string.match(regex)[0]);// =&gt; id=&quot;container&quot;// 思考：id里有特殊字符呢。 2. 第二章 正则表达式位置匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 2.2. 如何匹配位置呢？在 ES5 中，共有 6 个锚：^、$、\\b、\\B、(?=p)、(?!p) 2.2.1. ^ 和 $^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。 2.2.2. \\b 和 \\B\\b 是单词边界，具体就是 \\w 与 \\W 之间的位置，也包括 \\w 与 ^ 之间的位置，和 \\w 与 $ 之间的位置。比如考察文件名 “[JS] Lesson_01.mp4” 中的 \\b，如下：123var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\\b/g, &apos;#&apos;);console.log(result);// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot; \\B 就是 \\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \\b，剩下的都是 \\B 的。具体说来就是 \\w 与 \\w、 \\W 与 \\W、^ 与 \\W，\\W 与 $ 之间的位置。比如上面的例子，把所有 \\B 替换成 “#”： 123var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\\B/g, &apos;#&apos;);console.log(result);// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot; 2.2.3. (?=p) 和 (?!p)(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。比如 (?=l)，表示 “l” 字符前面的位置，例如：123var result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);console.log(result);// =&gt; &quot;he#l#lo&quot; 而 (?!p) 就是 (?=p) 的反面意思，比如：123var result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);console.log(result);// =&gt; &quot;#h#ell#o#&quot; 二者的学名分别是 positive lookahead 和 negative lookahead。中文翻译分别是正向先行断言和负向先行断言。ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。具体是 (?&lt;=p) 和 (?&lt;!p)。也有书上把这四个东西，翻译成环视，即看看右边和看看左边。但一般书上，没有很好强调这四者是个位置。比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。 2.3. 位置的特性对于位置的理解，我们可以理解成空字符 “”。也等价于： 1&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot; 因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的：123var result = /^^hello$$$/.test(&quot;hello&quot;);console.log(result);// =&gt; true 甚至可以写成更复杂的:123var result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test(&quot;hello&quot;);console.log(result);// =&gt; true 也就是说字符之间的位置，可以写成多个。 TIP 把位置理解空字符，是对位置非常有效的理解方式。 2.4. 相关案例2.4.1. 不匹配任何东西的正则1/.^/ 2.4.2 数字的千位分隔符表示法12345678比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。var regex = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;var result = &quot;12345678&quot;.replace(regex, &apos;,&apos;)console.log(result);// =&gt; &quot;12,345,678&quot;result = &quot;123456789&quot;.replace(regex, &apos;,&apos;);console.log(result);// =&gt; &quot;123,456,789&quot; github上 demo 5.2、添加千分位 千位分隔符的完整攻略 2.4.2.4. 支持其他形式12345var string = &quot;12345678 123456789&quot;,regex = /(?!\\b)(?=(\\d&#123;3&#125;)+\\b)/g;var result = string.replace(regex, &apos;,&apos;)console.log(result);// =&gt; &quot;12,345,678 123,456,789&quot; 其中 (?!\\b) 怎么理解呢？要求当前是一个位置，但不是 \\b 前面的位置，其实 (?!\\b) 说的就是 \\B。因此最终正则变成了：/\\B(?=(\\d{3})+\\b)/g。 2.4.2.5. 格式化12345function format (num) &#123;return num.toFixed(2).replace(/\\B(?=(\\d&#123;3&#125;)+\\b)/g, &quot;,&quot;).replace(/^/, &quot;$$ &quot;);&#125;;console.log( format(1888) );// =&gt; &quot;$ 1,888.00&quot; 2.4.3. 验证密码问题（TODO Read again）密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。那么，我们就来挑战一下。看看我们对位置的理解是否深刻。（(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。） // 扩展： 密码中必须包含字母、数字、特称字符，至少8个字符，最多30个字符。 Array.apply(null, {length: 10})和Array(10)有什么区别? 关于apply，Array.apply(null, {length:5})怎么理解 第三章 正则表达式括号的作用NOTE match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match返回的数组格式是不一样的。 3.2.1. 提取数据123456// 提取日期var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;console.log( string.match(regex) );console.log( regex.exec(string) ); // 这里的结果一样。// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;] 同时，也可以使用构造函数的全局属性 $1 至 $9 来获取：12345678var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;06&quot;console.log(RegExp.$3); // &quot;12&quot; 3.2.2. 替换比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？12345var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result);// =&gt; &quot;06/12/2017&quot; 其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式：1234var result = string.replace(regex, function () &#123;return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); 12345// 也等价于var result = string.replace(regex, function (match, year, month, day) &#123;return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); 3.3. 反向引用除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。(\\1,\\2)这类123456789var regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;var string1 = &quot;2017-06-12&quot;;var string2 = &quot;2017/06/12&quot;;var string3 = &quot;2017.06.12&quot;;var string4 = &quot;2016-06/12&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // false 3.3.1. 括号嵌套怎么办？以左括号（开括号）为准。1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 该正则图形化(%5Cd(%5Cd)))%5C1%5C2%5C3%5C4%24) 在线正则测试12^((\\d)(\\d([a-z])))\\1\\2\\3\\4$12a12a12aa 3.3.2. \\10 表示什么呢？另外一个疑问可能是，即 \\10 是表示第 10 个分组，还是 \\1 和 0 呢？答案是前者，虽然一个正则里出现 \\10 比较罕见。测试如下：1234var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;var string = &quot;123456789# ######&quot;console.log( regex.test(string) );// =&gt; true TIP 如果真要匹配 \\1 和 0 的话，请使用 (?:\\1)0 或者 \\1(?:0)。 3.3.3. 引用不存在的分组会怎样？因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 \\2，就匹配 “\\2”。注意 “\\2” 表示对 “2” 进行了转义。1234var regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/;console.log( regex.test(&quot;\\1\\2\\3\\4\\5\\6\\7\\8\\9&quot;) );console.log( &quot;\\1\\2\\3\\4\\5\\6\\7\\8\\9&quot;.split(&quot;&quot;) );// Chrome 浏览器打印的结果（不同的浏览器和版本，打印的结果可能不一样） 3.3.4. 分组后面有量词会怎样？分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。1234var regex = /(\\d)+/;var string = &quot;12345&quot;;console.log( string.match(regex) );// =&gt; [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;] 同理对于反向引用，也是这样的。测试如下：12345var regex = /(\\d)+ \\1/;console.log( regex.test(&quot;12345 1&quot;) );// =&gt; falseconsole.log( regex.test(&quot;12345 5&quot;) );// =&gt; true 3.4. 非捕获括号之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支。如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)。 3.5. 相关案例3.5.1. 字符串 trim 方法模拟第一种，匹配到开头和结尾的空白符，然后替换成空字符。12345function trim(str) &#123;return str.replace(/^\\s+|\\s+$/g, &apos;&apos;);&#125;console.log( trim(&quot; foobar &quot;) );// =&gt; &quot;foobar&quot; 第二种，匹配整个字符串，然后用引用来提取出相应的数据：12345function trim (str) &#123;return str.replace(/^\\s*(.*?)\\s*$/g, &quot;$1&quot;);&#125;console.log( trim(&quot; foobar &quot;) );// =&gt; &quot;foobar 当然，前者效率高。 3.5.2. 将每个单词的首字母转换为大写1234567unction titleize (str) &#123; return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) &#123; return c.toUpperCase(); &#125;);&#125;console.log( titleize(&apos;my name is epeli&apos;) );// =&gt; &quot;My Name Is Epeli&quot; 3.5.3. 驼峰化12345678function camelize (str) &#123; return str.replace(/[-_\\s]+(.)?/g, function (match, c) &#123; return c ? c.toUpperCase() : &apos;&apos;; &#125;);&#125;console.log( camelize(&apos;-moz-transform&apos;) );// =&gt; &quot;MozTransform&quot;// 这里c不需要判断。&apos;&apos;.toUpperCase() === &apos;&apos;; // true 3.5.4. 中划线化12345function dasherize (str) &#123; return str.replace(/([A-Z])/g, &apos;-$1&apos;).replace(/[-_\\s]+/g, &apos;-&apos;).toLowerCase(); &#125;console.log( dasherize(&apos;MozTransform&apos;) );// =&gt; &quot;-moz-transform&quot; 3.5.5. HTML 转义和反转义12345678910111213141516// 将HTML特殊字符转换成等值的实体function escapeHTML (str) &#123; var escapeChars = &#123; &apos;&lt;&apos; : &apos;lt&apos;, &apos;&gt;&apos; : &apos;gt&apos;, &apos;&quot;&apos; : &apos;quot&apos;, &apos;&amp;&apos; : &apos;amp&apos;, &apos;\\&apos;&apos; : &apos;#39&apos; &#125;; return str.replace(new RegExp(&apos;[&apos; + Object.keys(escapeChars).join(&apos;&apos;) +&apos;]&apos;, &apos;g&apos;), function (match) &#123; return &apos;&amp;&apos; + escapeChars[match] + &apos;;&apos;; &#125;);&#125;console.log( escapeHTML(&apos;&lt;div&gt;Blah blah blah&lt;/div&gt;&apos;) );// =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;; 其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：12345678910111213141516171819// 实体字符转换为等值的HTML。function unescapeHTML (str) &#123; var htmlEntities = &#123; nbsp: &apos; &apos;, lt: &apos;&lt;&apos;, gt: &apos;&gt;&apos;, quot: &apos;&quot;&apos;, amp: &apos;&amp;&apos;, apos: &apos;\\&apos;&apos; &#125;; return str.replace(/\\&amp;([^;]+);/g, function (match, key) &#123; if (key in htmlEntities) &#123; return htmlEntities[key]; &#125; return match; &#125;);&#125;console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );// =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot; 通过 key 获取相应的分组引用，然后作为对象的键。 3.5.6. 匹配成对标签要求匹配12&lt;title&gt;regular expression&lt;/title&gt;&lt;p&gt;laoyao bye bye&lt;/p&gt; 匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;，匹配一个闭标签，可以使用 &lt;\\/[^&gt;]+&gt;，但是要求匹配成对标签，那就需要使用反向引用，如：1234567var regex = /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/;var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // false 疑惑：为什么这里没有用.匹配呢，或者说为啥没用.?阻止贪婪匹配模式（惰性模式）呢 4. 第四章 正则表达式回溯法原理学习正则表达式，是需要懂点儿匹配原理的。而研究匹配原理时，有两个字出现的频率比较高：“回溯”。 4.1. 没有回溯的匹配假设我们的正则是 /ab{1,3}c/，而当目标字符串是 “abbbc” 时，就没有所谓的“回溯”。 4.2. 有回溯的匹配如果目标字符串是”abbc”，中间就有回溯。 图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 “b”，准备尝试第三个时，结果发现接下来的字符是 “c”。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 “c”。当然，此时整个表达式匹配成功了。图中的第 6 步，就是“回溯”。 再举一个例子：/ab{1,3}bbc/ 目标字符串是”abbbc”，匹配过程是：/“.*”/目标字符串是：”abc”de， 图中省略了尝试匹配双引号失败的过程。可以看出 . 是非常影响效率的。为了减少一些不必要的回溯，可以把正则修改为 /“[^”]“/。 4.3. 常见的回溯形式正则表达式匹配字符串的这种方式，有个学名，叫回溯法。 本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。道理，我们是懂了。那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？ 4.3.1 贪婪量词之前的例子都是贪婪量词相关的。 此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？答案是，先下手为强！因为深度优先搜索。测试如下：1234var string = &quot;12345&quot;;var regex = /(\\d&#123;1,3&#125;)(\\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;] 4.3.2 惰性量词虽然惰性量词不贪，但也会有回溯的现象。比如正则式：/^\\d{1,3}?\\d{1,3}$/目标字符串是 “12345”。 知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \\d{1,3}? 匹配的字符是 “12”，是两个数字，而不是一个。 4.3.3 分支结构我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 “candy”，得到的结果是 “can”，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 比如：/^(?:can|candy)$/ 目标字符串是’candy’ 上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。 4.4. 本章小结其实回溯法，很容易掌握的。简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。• 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。• 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动机”的简写。而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。大部分语言中的正则都是 NFA，为啥它这么流行呢？答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。 5. 第五章 正则表达式的拆分5.1. 结构和操作符JavaScript 正则表达式中，都有哪些结构呢？字符字面量、字符组、量词、锚、分组、选择分支、反向引用。 其中涉及到的操作符有：操作符描述 操作符 优先级转义符 \\ 1括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2量词限定符 {m}、{m,n}、{m,}、?、*、+ 3位置和序列 ^、$、\\元字符、一般字符 4管道符（竖杠） | 5 5.2. 注意要点5.2.1 匹配字符串整体问题比如要匹配目标字符串 “abc” 或者 “bcd” 时，如果一不小心，就会写成 /^abc|bcd$/。而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是。 开始-abcbcd-结束应该是：/^(abc|bcd)$/ 5.2.2 量词连缀问题 每个字符为 “a、”b”、”c” 任选其一， 字符串的长度是 3 的倍数。/^[abc]{3}+$/，这样会报错，说 + 前面没什么可重复的。应该为：/([abc]{3})+/ 5.2.3 元字符转义问题所谓元字符，就是正则中有特殊含义的字符。所有结构里，用到的元字符总结如下：^、$、.、*、+、?、|、\\、/、(、)、[、]、{、}、=、!、:、- ,当匹配上面的字符本身时，可以一律转义：1234var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var regex = /\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,/;console.log( regex.test(string) );// =&gt; true 其中 string 中的 \\ 字符也要转义的。另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身：1234var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var string2 = &quot;\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,&quot;;console.log( string == string2 );// =&gt; true 现在的问题是，是不是每个字符都需要转义呢？否，看情况。 5.2.3.1. 字符组中的元字符跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然会把整个字符组，看成反义字符组。12345var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var regex = /[\\^$.*+?|\\\\/\\[\\]&#123;&#125;=!:\\-,]/g;console.log( string.match(regex) );// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;,&quot;-&quot;, &quot;,&quot;] 5.2.3.2. 匹配 “[abc]” 和 “{3,5}”我们知道 [abc]，是个字符组。如果要匹配字符串 “[abc]” 时，该怎么办？可以写成 /[abc]/，也可以写成 /[abc]/只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。 同理，要匹配字符串 “{3,5}”，只需要把正则写成 /{3,5}/ 即可。另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 “{,n}”，测试如下：1234var string = &quot;&#123;,3&#125;&quot;;var regex = /&#123;,3&#125;/g;console.log( string.match(regex)[0] );// =&gt; &quot;&#123;,3&#125;&quot; 5.2.3.3. 其余情况比如 =、!、:、-、, 等符号，只要不在特殊结构中，并不需要转义。但是，括号需要前后都转义的，如 /(123)/。至于剩下的 ^、$、.、*、+、?、|、\\、/ 等字符，只要不在字符组内，都需要转义的。 5.3. 案例分析5.3.1 身份证正则表达式是：/^(\\d{15}|\\d{17}[\\dxX])$/ 5.3.2 IPV4 地址正则表达式是：1/^((0&#123;0,2&#125;\\d|0?\\d&#123;2&#125;|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.)&#123;3&#125;(0&#123;0,2&#125;\\d|0?\\d&#123;2&#125;|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])$/ 这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：((…).){3}(…)其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是3位数.3位数.3位数.3位数然后再来分析 (…)：(0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5]) 6. 第六章 正则表达式的构建6.1. 平衡法则构建正则有一点非常重要，需要做到下面几点的平衡：1.• 匹配预期的字符串2.• 不匹配非预期的字符串3.• 可读性和可维护性4.• 效率 6.2. 构建正则前提比如匹配这样的字符串：1010010001…。虽然很有规律，但是只靠正则就是无能为力。 6.2.2. 是否有必要使用正则？要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串 API 解决的简单问题，就不该正则出马。 比如，从日期中提取出年月日，虽然可以使用正则：1234var string = &quot;2017-07-01&quot;;var regex = /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;console.log( string.match(regex) );// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;] 其实，可以使用字符串的 split 方法来做，即可：1234var string = &quot;2017-07-01&quot;;var result = string.split(&quot;-&quot;);console.log( result );// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;] 比如，判断是否有问号，虽然可以使用：123var string = &quot;?id=xx&amp;act=search&quot;;console.log( string.search(/\\?/) );// =&gt; 0 其实，可以使用字符串的 indexOf 方法：123var string = &quot;?id=xx&amp;act=search&quot;;console.log( string.indexOf(&quot;?&quot;) );// =&gt; 0 比如获取子串，虽然可以使用正则：123var string = &quot;JavaScript&quot;;console.log( string.match(/.&#123;4&#125;(.+)/)[1] );// =&gt; Script 其实，可以直接使用字符串的 substring 或 substr 方法（语言精粹中推荐使用slice,substr是在ES5规范附则里。）来做：123var string = &quot;JavaScript&quot;;console.log( string.substring(4) );// =&gt; Script 6.2.3. 是否有必要构建一个复杂的正则？6.2.3. 是否有必要构建一个复杂的正则？比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。在第2章里，我们写出了正则是1/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/ 123456789101112其实可以使用多个小正则来做：var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;var regex2 = /^[0-9]&#123;6,12&#125;$/;var regex3 = /^[A-Z]&#123;6,12&#125;$/;var regex4 = /^[a-z]&#123;6,12&#125;$/;function checkPassword (string) &#123; if (!regex1.test(string)) return false; if (regex2.test(string)) return false; if (regex3.test(string)) return false; if (regex4.test(string)) return false; return true;&#125; 6.3. 准确性所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。这里提到了“预期”二字，那么我们就需要知道目标的组成规则。 6.3.1. 匹配固定电话比如要匹配如下格式的固定电话号码：1230551888888880551-88888888(0551)88888888 1/^(0\\d&#123;2,3&#125;-?|\\(0\\d&#123;2,3&#125;\\))[1-9]\\d&#123;6,7&#125;$/ 这就是一个平衡取舍问题，一般够用就行。 6.3.2. 匹配浮点数要求匹配如下的格式：1231.23、+1.23、-1.2310、+10、-10.2、+.2、-.2 上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：/^[+-]?(\\d+)?(.\\d+)?$/此正则看似没问题，但这个正则也会匹配空字符 “”。因为目标字符串的形式关系不是要求每部分都是可选的。/^[+-]?(\\d+.\\d+|\\d+|.\\d+)$/ 6.4. 效率保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。正则表达式的运行分为如下的阶段： • 1. 编译；• 2. 设定起始位置；• 3. 尝试匹配；• 4. 匹配失败的话，从下一位开始继续第 3 步；• 5. 最终结果：匹配成功或失败 当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。 6.4.1. 使用具体型字符组来代替通配符，来消除回溯而在第三阶段，最大的问题就是回溯。因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。 6.4.2. 使用非捕获型分组因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。 6.4.3. 独立出确定字符例如，/a+/ 可以修改成 /aa*/。 6.4.4. 提取分支公共部分比如，/^abc|^def/ 修改成 /^(?:abc|def)/。又比如， /this|that/修改成 /th(?:is|at)/。这样做，可以减少匹配过程中可消除的重复。 6.4.5. 减少分支的数量，缩小它们的范围/red|read/ 可以修改成 /rea?d/。此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。 7. 第七章 正则表达式编程7.1. 正则表达式的四种操作正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。 7.1.1. 验证比如，判断一个字符串中是否有数字。使用 search：12345var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!~string.search(regex) );// ~0 === -1// =&gt; true 1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( regex.test(string) );// =&gt; true 使用 match：1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!string.match(regex) );// =&gt; true 使用 exec：1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!regex.exec(string) );// =&gt; true 其中，最常用的是 test。 7.1.2. 切分匹配上了，我们就可以进行一些操作，比如切分。所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。 7.1.3. 提取虽然整体匹配上了，但有时需要提取部分匹配的数据。此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。这里，还是以日期为例，提取出年月日。注意下面正则中的括号：使用 match：使用 exec：使用 test：12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;regex.test(string);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; 使用 search：12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;string.search(regex);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; 使用 replace：12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;var date = [];string.replace(regex, function (match, year, month, day) &#123;date.push(year, month, day);&#125;);console.log(date);// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] 其中，最常用的是 match。 7.1.4. 替换找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。 7.2. 相关 API 注意要点从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：123456String#searchString#splitString#matchString#replaceRegExp#testRegExp#exec 7.2.1. search 和 match 的参数问题我们知道字符串实例的那 4 个方法参数都支持正则和字符串。但 search 和 match，会把字符串转换为正则的。replace和split不会。 7.2.2. match 返回结果的格式问题match 返回结果的格式，与正则对象是否有修饰符 g 有关。1234567var string = &quot;2017.06.27&quot;;var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;] 没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。有 g，返回的是所有匹配的内容。当没有匹配时，不管有无 g，都返回 null。 7.2.3. exec 比 match 更强大当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配：其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。比如第一次匹配了 “2017”，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配的位置是 4。从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环： 7.2.4. 修饰符 g，对 exex 和 test 的影响上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。 7.2.5. test 整体匹配时需要使用 ^ 和 $这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。如果，要整体匹配，正则前后需要添加开头和结尾：123456console.log( /123/.test(&quot;a123b&quot;) );// =&gt; trueconsole.log( /^123$/.test(&quot;a123b&quot;) );// =&gt; falseconsole.log( /^123$/.test(&quot;123&quot;) );// =&gt; true 7.2.6. split 相关注意事项split 方法看起来不起眼，但要注意的地方有两个的。第一，它可以有第二个参数，表示结果数组的最大长度：123var string = &quot;html,css,javascript&quot;;console.log( string.split(/,/, 2) );// =&gt;[&quot;html&quot;, &quot;css&quot;] 第二，正则使用分组时，结果数组中是包含分隔符的：123var string = &quot;html,css,javascript&quot;;console.log( string.split(/(,)/) );// =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;] 7.2.7. replace 是很强大的《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： 属性 描述$1,$2,…,$99 匹配第 1-99 个 分组里捕获的文本$&amp; 匹配到的子串文本$` 匹配到的子串的左边文本$’ 匹配到的子串的右边文本$$ 美元符号记忆中语言精粹中有列举更多。再例如，把 “2+3=5”，变成 “2+3=2+3=5=5”:123var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);console.log(result);// =&gt; &quot;2+3=2+3=5=5 我们对最后这个进行一下说明。要把 “2+3=5”，变成 “2+3=2+3=5=5”，其实就是想办法把 = 替换成=2+3=5=，其中，$&amp; 匹配的是 =， $匹配的是 2+3，$&#39; 匹配的是 5。因此使用 &quot;$&amp;$$&amp;$’$&amp;” 便达成了目的。当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：123456&quot;1234 2345 3456&quot;.replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function (match, $1, $2, index, input) &#123;console.log([match, $1, $2, index, input]);&#125;);// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;] 此时我们可以看到 replace 拿到的信息，并不比 exec 少。 7.2.8. 使用构造函数需要注意的问题一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 \\。 7.2.9. 修饰符ES5 中修饰符，共 3 个：g,i,m当然正则对象也有相应的只读属性：1234567var regex = /\\w/img;console.log( regex.global );console.log( regex.ignoreCase );console.log( regex.multiline );// =&gt; true// =&gt; true// =&gt; true 7.2.10. source 属性正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source属性。它什么时候有用呢？比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么：1234var className = &quot;high&quot;;var regex = new RegExp(&quot;(^|\\\\s)&quot; + className + &quot;(\\\\s|$)&quot;);console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串&quot;(^|\\\\s)high(\\\\s|$)&quot; 7.2.11. 构造函数属性构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的属性（有兼容性问题）： 静态属性 描述 简写形式RegExp.input 最近一次目标字符串 RegExp[“$_”]RegExp.lastMatch 最近一次匹配的文本 RegExp[“$&amp;”]RegExp.lastParen 最近一次捕获的文本 RegExp[“$+”]RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”]RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[“$’”] 7.3. 真实案例7.3.1. 使用构造函数生成正则表达式123456789101112131415161718192021&lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt;&lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt;&lt;p&gt;3333&lt;/p&gt;&lt;script&gt;function getElementsByClassName (className) &#123;var elements = document.getElementsByTagName(&quot;*&quot;);var regex = new RegExp(&quot;(^|\\\\s)&quot; + className + &quot;(\\\\s|$)&quot;);var result = [];for (var i = 0; i &lt; elements.length; i++) &#123;var element = elements[i];if (regex.test(element.className)) &#123;result.push(element)&#125;&#125;return result;&#125;var highs = getElementsByClassName(&apos;high&apos;);highs.forEach(function (item) &#123;item.style.color = &apos;red&apos;;&#125;);&lt;/script&gt; 7.3.2. 使用字符串保存数据一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：123456789var utils = &#123;&#125;;&quot;Boolean|Number|String|Function|Array|Date|RegExp|Object|Error&quot;.split(&quot;|&quot;).forEach(function (item) &#123;utils[&quot;is&quot; + item] = function (obj) &#123;return &#123;&#125;.toString.call(obj) == &quot;[object &quot; + item + &quot;]&quot;;&#125;;&#125;);console.log( utils.isArray([1, 2, 3]) );// =&gt; true 7.3.3. if 语句中使用正则替代 &amp;&amp;比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）：123456789101112131415161718var readyRE = /complete|loaded|interactive/;function ready (callback) &#123;if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123;callback()&#125;else &#123;document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;callback()&#125;,false);&#125;&#125;;ready(function () &#123;alert(&quot;加载完毕！&quot;)&#125;); 7.3.4. 使用强大的 replace因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何东西。12345678910111213function compress (source) &#123;var keys = &#123;&#125;;source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123;keys[key] = (keys[key] ? keys[key] + &apos;,&apos; : &apos;&apos;) + value;&#125;);var result = [];for (var key in keys) &#123;result.push(key + &apos;=&apos; + keys[key]);&#125;return result.join(&apos;&amp;&apos;);&#125;console.log( compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;) );// =&gt; &quot;a=1,3&amp;b=2,4&quot; 完。84/89","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"github使用小技巧","slug":"20170921-github tips","date":"2017-09-21T15:15:52.000Z","updated":"2017-09-21T15:44:17.404Z","comments":true,"path":"2017/09/21/20170921-github tips/","link":"","permalink":"https://lxchuan12.github.io/2017/09/21/20170921-github tips/","excerpt":"","text":"大多数开发者都有github账号，但github这些日常小技巧估计不知道。1、subscribe订阅github周报，每周会把你关注的开发语言和关注的人的动态等发邮件给你：每天github的热点2、快捷键：在github某个项目面板（页面），按shift+?，可以看到所有支持的快捷键。其中常用的主要有。 T，搜索文件S:定位到搜索输入框GC:跳转到code面板GI:跳转到issue面板GP:跳转到 pull request面板GW:跳转到 Wiki搜索issue和pull request时可以使用过滤器。比如：is:open回答输入时，可以用#号来匹配相应的issue.3、Code Line可以标注一些代码。按住shift,选择行号。对应的代码就高亮了。对应链接加上了hash#L1-L214、octotree chrome插件github可以像编辑器目录文件形式。octotree chrome插件地址如果翻墙苦难，可以直接下载dist目录下chrome.crx，拖拽到chrome浏览器插件即可安装。","categories":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/tags/github/"}],"keywords":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/categories/github/"}]},{"title":"JavaScript 对象所有API解析","slug":"20170817-Object API","date":"2017-08-17T15:51:52.000Z","updated":"2018-06-12T14:31:58.615Z","comments":true,"path":"2017/08/17/20170817-Object API/","link":"","permalink":"https://lxchuan12.github.io/2017/08/17/20170817-Object API/","excerpt":"","text":"首发于segmentfault:JavaScript 对象所有API解析 之前看到【深度长文】JavaScript数组所有API全解密和JavaScript字符串所有API全解密这两篇高质量的文章。发现没写对象API解析（估计是博主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。 创建对象的两种方式：12var o = new Object();var o = &#123;&#125;; // 推荐 该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：1234var o = new Object(&apos;something&apos;);o.constructor; // ƒ String() &#123; [native code] &#125;var n = new Object(123);n.constructor; // ƒ Number() &#123; [native code] &#125; 一、Object构造器的成员Object.prototype该属性是所有对象的原型（包括 Object对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。比如：123var s = new String(&apos;xuanyuan&apos;);Object.prototype.custom = 1;console.log(s.custom); // 1 二、Object.prototype 的成员Object.prototype.constructor该属性指向用来构造该函数对象的构造器，在这里为Object()123Object.prototype.constructor === Object; // truevar o = new Object();o.constructor === Object; // true Object.prototype.toString(radix)该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数radix，该参数radix，该参数的默认值为10。12345var o = &#123;prop:1&#125;;o.toString(); // &apos;[object object]&apos;var n = new Number(255);n.toString(); // &apos;255&apos;n.toString(16); // &apos;ff&apos; Object.prototype.toLocaleString()该方法的作用与toString()基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如Date(),Number(),Array(),它们的值都会以本地化的形式输出。当然，对于包括Object()在内的其他大多数对象来说，该方法与toString()是基本相同的。在浏览器环境下，可以通过BOM对象Navigator的language属性（在IE中则是userLanguage）来了解当前所使用的语言：1navigator.language; //&apos;en-US&apos; Object.prototype.valueOf()该方法返回的是用基本类型所表示的this值，如果它可以用基本类型表示的话。如果Number对象返回的是它的基本数值，而Date对象返回的是一个时间戳（timestamp）。如果无法用基本数据类型表示，该方法会返回this本身。1234567891011121314// Objectvar o = &#123;&#125;;typeof o.valueOf(); // &apos;object&apos;o.valueOf() === o; // true// Numbervar n = new Number(101);typeof n; // &apos;object&apos;typeof n.vauleOf; // &apos;function&apos;typeof n.valueOf(); // &apos;number&apos;n.valueOf() === n; // false// Datevar d = new Date();typeof d.valueOf(); // &apos;number&apos;d.valueOf(); // 1503146772355 Object.prototype.hasOwnProperty(prop)该方法仅在目标属性为对象自身属性时返回true,而当该属性是从原型链中继承而来或根本不存在时，返回false。1234var o = &#123;prop:1&#125;;o.hasOwnProperty(&apos;prop&apos;); // trueo.hasOwnProperty(&apos;toString&apos;); // falseo.hasOwnProperty(&apos;formString&apos;); // false Object.prototype.isPrototypeOf(obj)如果目标对象是当前对象的原型，该方法就会返回true，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。1234var s = new String(&apos;&apos;);Object.prototype.isPrototypeOf(s); // trueString.prototype.isPrototypeOf(s); // trueArray.prototype.isPrototypeOf(s); // false Object.prototype.propertyIsEnumerable(prop)如果目标属性能在for in循环中被显示出来，该方法就返回true123var a = [1,2,3];a.propertyIsEnumerable(&apos;length&apos;); // falsea.propertyIsEnumerable(0); // true 三、在ES5中附加的Object属性在ES3中，除了一些内置属性（如：Math.PI），对象的所有的属性在任何时候都可以被修改、插入、删除。在ES5中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。ES5中引入了属性描述符的概念，我们可以通过它对所定义的属性有更大的控制权。这些属性描述符（特性）包括： value——当试图获取属性时所返回的值。writable——该属性是否可写。enumerable——该属性在for in循环中是否会被枚举configurable——该属性是否可被删除。set()——该属性的更新操作所调用的函数。get()——获取属性值时所调用的函数。另外，数据描述符（其中属性为：enumerable，configurable，value，writable）与存取描述符（其中属性为enumerable，configurable，set()，get()）之间是有互斥关系的。在定义了set()和get()之后，描述符会认为存取操作已被 定义了，其中再定义value和writable会引起错误。以下是ES3风格的属性定义方式：12var person = &#123;&#125;;person.legs = 2; 以下是等价的ES5通过数据描述符定义属性的方式：1234567var person = &#123;&#125;;Object.defineProperty(person, &apos;legs&apos;, &#123; value: 2, writable: true, configurable: true, enumerable: true&#125;); 其中， 除了value的默认值为undefined以外，其他的默认值都为false。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为true。或者，我们也可以通过ES5的存储描述符来定义：123456789101112var person = &#123;&#125;;Object.defineProperty(person, &apos;legs&apos;, &#123; set:function(v) &#123; return this.value = v; &#125;, get: function(v) &#123; return this.value; &#125;, configurable: true, enumerable: true&#125;);person.legs = 2; 这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容ES3方面所做的考虑。例如，跟添加Array.prototype属性不一样，我们不能再旧版的浏览器中使用shim这一特性。另外，我们还可以（通过定义nonmalleable属性），在具体行为中运用这些描述符：123456var person = &#123;&#125;;Object.defineProperty(person, &apos;heads&apos;, &#123;value: 1&#125;);person.heads = 0; // 0person.heads; // 1 (改不了)delete person.heads; // falseperson.heads // 1 (删不掉) Object.defineProperty(obj, prop, descriptor) (ES5)具体用法可参见上文，或者查看MDN。MDN Object.defineProperty(obj, descriptor) Vue.js文档：如何追踪变化 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 Object.defineProperties(obj, props) (ES5)该方法的作用与defineProperty()基本相同，只不过它可以用来一次定义多个属性。比如：1234567891011var glass = Object.defineProperties(&#123;&#125;, &#123; &apos;color&apos;: &#123; value: &apos;transparent&apos;, writable: true &#125;, &apos;fullness&apos;: &#123; value: &apos;half&apos;, writable: false &#125;&#125;);glass.fullness; // &apos;half&apos; Object.getPrototypeOf(obj) (ES5)之前在ES3中，我们往往需要通过Object.prototype.isPrototypeOf()去猜测某个给定的对象的原型是什么，如今在ES5中，我们可以直接询问改对象“你的原型是什么？”123Object.getPrototypeOf([]) === Array.prototype; // trueObject.getPrototypeOf(Array.prototype) === Object.prototype; // trueObject.getPrototypeOf(Object.prototype) === null; // true Object.create(obj, descr) (ES5)该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。123456789101112var parent = &#123;hi: &apos;Hello&apos;&#125;;var o = Object.create(parent, &#123; prop: &#123; value: 1 &#125;&#125;);o.hi; // &apos;Hello&apos;// 获得它的原型Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototypeObject.getPrototypeOf(o); // &#123;hi: &quot;Hello&quot;&#125; // 说明o的原型是&#123;hi: &quot;Hello&quot;&#125;o.hasOwnProperty(&apos;hi&apos;); // false 说明hi是原型上的o.hasOwnProperty(&apos;prop&apos;); // true 说明prop是原型上的自身上的属性。 现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在ES3中可是做不到的。12var o = Object.create(null);typeof o.toString(); // &apos;undefined&apos; Object.getOwnPropertyDesciptor(obj, property) (ES5)该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。12Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125; Object.getOwnPropertyNames(obj) (ES5)该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用Object.keys()来单独返回可枚举的属性。12345678Object.getOwnPropertyNames(Object.prototype);// [&quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;]Object.keys(Object.prototype);// []Object.getOwnPropertyNames(Object);// [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;prototype&quot;, &quot;assign&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getOwnPropertyDescriptors&quot;, &quot;getOwnPropertyNames&quot;, &quot;getOwnPropertySymbols&quot;, &quot;is&quot;, &quot;preventExtensions&quot;, &quot;seal&quot;, &quot;create&quot;, &quot;defineProperties&quot;, &quot;defineProperty&quot;, &quot;freeze&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;isFrozen&quot;, &quot;isSealed&quot;, &quot;keys&quot;, &quot;entries&quot;, &quot;values&quot;]Object.keys(Object);// [] Object.preventExtensions(obj) (ES5)Object.isExtensible(obj) (ES5)preventExtensions()方法用于禁止向某一对象添加更多属性，而isExtensible()方法则用于检查某对象是否还可以被添加属性。12345678910var deadline = &#123;&#125;;Object.isExtensible(deadline); // truedeadline.date = &apos;yesterday&apos;; // &apos;yesterday&apos;Object.preventExtensions(deadline);Object.isExtensible(deadline); // falsedeadline.date = &apos;today&apos;;deadline.date; // &apos;today&apos;// 尽管向某个不可扩展的对象中添加属性不算是一个错误操作，但它没有任何作用。deadline.report = true;deadline.report; // undefined Object.seal(obj) (ES5)Object.isSeal(obj) (ES5)seal()方法可以让一个对象密封，并返回被密封后的对象。seal()方法的作用与preventExtensions()基本相同，但除此之外，它还会将现有属性设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用defineProperty()）重新配置这些属性，例如不能将一个可枚举的属性改成不可枚举。123456789101112var person = &#123;legs:2&#125;;// person === Object.seal(person); // trueObject.isSealed(person); // trueObject.getOwnPropertyDescriptor(person, &apos;legs&apos;);// &#123;value: 2, writable: true, enumerable: true, configurable: false&#125;delete person.legs; // false (不可删除，不可配置)Object.defineProperty(person, &apos;legs&apos;,&#123;value:2&#125;);person.legs; // 2person.legs = 1;person.legs; // 1 (可写)Object.defineProperty(person, &quot;legs&quot;, &#123; get: function() &#123; return &quot;legs&quot;; &#125; &#125;);// 抛出TypeError异常 Object.freeze(obj) (ES5)Object.isFrozen(obj) (ES5)freeze()方法用于执行一切不受seal()方法限制的属性值变更。Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。12345678910var deadline = Object.freeze(&#123;date: &apos;yesterday&apos;&#125;);deadline.date = &apos;tomorrow&apos;;deadline.excuse = &apos;lame&apos;;deadline.date; // &apos;yesterday&apos;deadline.excuse; // undefinedObject.isSealed(deadline); // true;Object.isFrozen(deadline); // trueObject.getOwnPropertyDescriptor(deadline, &apos;date&apos;);// &#123;value: &quot;yesterday&quot;, writable: false, enumerable: true, configurable: false&#125; (不可配置，不可写)Object.keys(deadline); // [&apos;date&apos;] (可枚举) Object.keys(obj) (ES5)该方法是一种特殊的for-in循环。它只返回当前对象的属性（不像for-in），而且这些属性也必须是可枚举的（这点和Object.getOwnPropertyNames()不同，不论是否可以枚举）。返回值是一个字符串数组。1234567Object.prototype.customProto = 101;Object.getOwnPropertyNames(Object.prototype);// [..., &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;, &quot;customProto&quot;]Object.keys(Object.prototype); // [&apos;customProto&apos;]var o = &#123;own: 202&#125;;o.customProto; // 101Object.keys(o); // [&apos;own&apos;] 四、在ES6中附加的Object属性Object.is(value1, value2) (ES6)该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，而是NaN等于自身。123456Object.is(&apos;xuanyuan&apos;, &apos;xuanyuan&apos;); // trueObject.is(&#123;&#125;,&#123;&#125;); // falseObject.is(+0, -0); // false+0 === -0; // trueObject.is(NaN, NaN); // trueNaN === NaN; // false ES5可以通过以下代码部署Object.is12345678910111213Object.defineProperty(Object, &apos;is&apos;, &#123; value: function() &#123;x, y&#125; &#123; if (x === y) &#123; // 针对+0不等于-0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对 NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); Object.assign(target, …sources) (ES6)该方法用来源对象（source）的所有可枚举的属性复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象target，后面的参数都是源对象（source）。只有一个参数不是对象，就会抛出TypeError错误。1234567891011var target = &#123;a: 1&#125;;var source1 = &#123;b: 2&#125;;var source2 = &#123;c: 3&#125;;obj = Object.assign(target, source1, source2);target; // &#123;a:1,b:2,c:3&#125;obj; // &#123;a:1,b:2,c:3&#125;target === obj; // true// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。var source3 = &#123;a:2,b:3,c:4&#125;;Object.assign(target, source3);target; // &#123;a:2,b:3,c:4&#125; Object.assign只复制自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被复制。1234567Object.assign(&#123;b: &apos;c&apos;&#125;, Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123; enumerable: false, value: &apos;hello&apos; &#125;));// &#123;b: &apos;c&apos;&#125; 属性名为Symbol值的属性，也会被Object.assign()复制。12Object.assign(&#123;a: &apos;b&apos;&#125;, &#123;[Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);// &#123;a: &apos;b&apos;, Symbol(c): &apos;d&apos;&#125; 对于嵌套的对象，Object.assign()的处理方法是替换，而不是添加。12Object.assign(&#123;a: &#123;b:&apos;c&apos;,d:&apos;e&apos;&#125;&#125;, &#123;a:&#123;b:&apos;hello&apos;&#125;&#125;);// &#123;a: &#123;b:&apos;hello&apos;&#125;&#125; 对于数组，Object.assign()把数组视为属性名为0、1、2的对象。12Object.assign([1,2,3], [4,5]);// [4,5,3] Object.getOwnPropertySymbols(obj) (ES6)该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。该方法和 Object.getOwnPropertyNames() 类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。12Object.getOwnPropertySymbols(&#123;a: &apos;b&apos;, [Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);// [Symbol(c)] Object.setPrototypeOf(obj, prototype) (ES6)该方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。__proto__属性用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。123456789101112// ES6写法var obj = &#123; method: function()&#123; // code ... &#125;&#125;;// obj.__proto__ = someOtherObj;// ES5写法var obj = Object.create(someOtherObj);obj.method = function()&#123; // code ...&#125;; 该属性没有写入ES6的正文，而是写入了附录。__proto__前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。而是使用Object.setPrototypeOf()（写操作），Object.getPrototypeOf()（读操作），或Object.create()（生成操作）代替。在实现上，__proto__调用的Object.prototype.__proto__。Object.setPrototypeOf()方法的作用与__proto__作用相同，用于设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。 五、在ES8中附加的Object属性Object.getOwnPropertyDescriptors(obj) (ES8)该方法基本与Object.getOwnPropertyDescriptor(obj, property)用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。123Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;Object.getOwnPropertyDescriptors(Object.prototype); // 可以自行在浏览器控制台查看效果。 Object.values(obj) (ES8)Object.values() 方法与Object.keys类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。123var obj = &#123;a:1,b:2,c:3&#125;;Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]Object.values(obj); // [1,2,3] Object.entries(obj) (ES8)Object.entries() 方法返回一个给定对象自己的可枚举属性[key，value]对的数组，数组中键值对的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致（区别在于一个for-in循环也枚举原型链中的属性）。1234var obj = &#123;a:1,b:2,c:3&#125;;Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]Object.values(obj); // [1,2,3]Object.entries(obj); // [[&apos;a&apos;,1],[&apos;b&apos;,2],[&apos;c&apos;,3]] 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github 小结您可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有Object.prototype.toString()，Object.prototype.hasOwnProperty()， Object.getPrototypeOf(obj)，Object.create()，Object.defineProperty，Object.keys(obj)，Object.assign()。 参考资料MDN Object APIJavaScript面向对象编程指南（第2版）（豆瓣读书链接）阮一峰 ES6标准入门2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"《JavaScript 语言精粹 修订版》 读书笔记","slug":"20170723-JavaScript essence of reading notes","date":"2017-07-23T14:23:52.000Z","updated":"2018-06-12T14:31:49.677Z","comments":true,"path":"2017/07/23/20170723-JavaScript essence of reading notes/","link":"","permalink":"https://lxchuan12.github.io/2017/07/23/20170723-JavaScript essence of reading notes/","excerpt":"","text":"首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记 之前看到这篇文章，前端网老姚浅谈：怎么学JavaScript？，说到怎么学习JavaScript，那就是看书、分析源码。10本书读2遍的好处，应该大于一本书读20遍。看书主动学习，看视频是被动学习。看书和分析源码的时机。但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来学习，那&gt;肯定是必须的，工作本身就是一个学习的过程。怎么把一本书看完呢？很简单，敲。文字加代码都敲。比较认同老姚的说法。去年毕业到现在，我也算是工作一年了，是时候看书查缺补漏了。 于是我就先把这本薄的经典书《JavaScript语言精粹 修订版》豆瓣读书本书简介（总共10章，除去附录，才100页），读完并记录了一些笔记。基本算是摘抄书本的，自己联想到了一些知识和资料也扩展了一下。总体写下来近一万字。读书笔记还可以分享给别人看。回顾时，书不在身边还可以看看自己的笔记。想想这类经典书记一遍动手敲一遍也是很值得的。不过这读书笔记中可能会有一些错别字，阅读时如果发现欢迎指正。 第1章 精华大多数语言都有精华和糟粕。JavaScript令人诡异的事情是，在对这门语言没有的太多了解，甚至对编程都没有太多了解的情况下，你也能用它来完成工作。看到这里不禁想起： 张鑫旭大牛在《我对知乎前端相关问题的十问十答》非计算机专业背景学习JS要点有这一条：所有继承和原型相关内容跳过，注意，是跳过，不要看！没有这些JS一样可以活得很好，你的日常工作一样玩得飞起，当然，你没忍住看了相关知识也没关系，因为你会发现自己看不懂的； JavaScript的函数是（主要）基于词法作用域的顶级对象。 译注：JavaScript中的函数是根据词法来划分作用域的，而不是动态划分作用域的。具体内容参见《JavaScript权威指南》中译第5版相关章节“8.8.1 词法作用域”。JavaScript有非常强大的对象字面量表示法。这种表示法是JSON的灵感来源。原型继承是JavaScript中一个有争议的特性。 《ECMAScript编程语言》第3版定义了JavaScript的标准。ES3标准扩展：颜海镜大牛整理的ES3中文版颜海镜大牛整理的ES5中文版W3c ES5中文版阮一峰大牛的书籍《ES6标准入门2》更多内容可参见这篇文章：ECMAScript 2018 标准导读 一个简单的例子：1234Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125; 书中贯彻始终都会用到这个method方案，作者将会在第4章解释它。 第2章 语法本章主要用铁路图（语法图）表示语法。主要有：空白、标识符、数字、字符串、语句、表达式、字面量、函数。typeof 运算符产生的值有&#39;number&#39;, &#39;string&#39;,&#39;boolean&#39;,&#39;undefined&#39;,&#39;function&#39;,&#39;object&#39;。如果运算数是一个数组或者是null,那么结果是&#39;object&#39;,这其实是不对的。 第3章 对象JavaScript简单数据类型包括数字、字符串、布尔值，null值和undefined值。其他所有值都是对象。数组、字符串和布尔值“貌似”对象，因为它们拥有方法（包装对象），但它们是不可变的。对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的所有字符串，属性值可以是除了undefined值之外的任何值。 JavaScript包含一种原型链的特性，允许对象继承到另一个对象的属性。正确地使用它能减少对象初始化时的消耗的时间和内存。检索.,[]两种检索方式，推荐点.表示法。尝试重undefined的成员属性中取值将会导致TypeError异常，这时可以通过&amp;&amp;来避免错误。更新如果属性名已经存在对象里。那么属性的值会被替换。如果之前没有拥有那个属性名，那么该属性将被扩充到对象中。引用对象通过引用来传递。它们永远不会被复制。原型所有通过对象字面量创建的对象都链接到Object.prototype。创建新对象时，可以选择某个对象作为它的原型。1234567if (typeof Object.create !== &apos;function&apos;) &#123; Object.create = function(o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F(); &#125;;&#125; 原型连接只有在检索值的时候才被用到。如果尝试去获取对象的某个属性值，但对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到终点Object.prototype。如果想要的属性完全不存在原型链中，那么结果就是 undefined值。这个过程称为委托。原型关系是一种动态的关系。反射原型链上的所有属性都会产生值。有两种方案可以处理掉对象上不需要的属性。①程序检查时丢弃值为函数的属性。但有可能有些值确实是函数，所以该方法不可靠。②使用hasOwnProperty方法，如果是对象拥有独有的属性，则返回true。该方法不会检查原型链。枚举① for in可以遍历一个对象中所有的属性名。但包含函数和一些不关心的原型中属性。而且顺序不确定，可以用 hasOwnProperty方法和typeof排除函数。②for 循环不会出现for in那些情况。删除delete运算符可以用来删除对象的属性。减少全局变量的污染可以把全局性的资源纳入一个名称空间之下。这样做能减少冲突。 第4章 函数函数用于①代码复用②信息隐藏③组合调用。一般来说，所谓编程，就是将一组需求分节成一组函数与数据结构的技能。JavaScript的函数就是对象。函数对象连接到Function.prototype(该原型对象本身连接到Object.prototype)。每个函数在创建时会附加两个隐藏属性，函数的上下文和实现函数行为的代码。每个函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值为该函数的对象。函数字面量函数字面量包括4个部分。①保留字function②函数名，可以省略，③一组参数④一组语句。函数字面量可以出现在任何允许表达式出现的地方。一个内部函数除了可以访问自己的参数和变量，同时也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个连接到外部上下文的连接。这被称为闭包。调用除了声明时定义的形式参数，每一个函数还接收两个附加的参数：this和argument。在JavaScript中一共有四种调用模式。①方法调用模式，②函数调用模式③构造器调用模式④apply调用模式。 （this指向问题一直困扰很多人。我一般是这样记的，谁调用this就指向谁。） 方法调用模式对象的方法执行,this指向该对象。比如：1234567var myObj = &#123; value: 0, showValue: function() &#123; console.log(&apos;value:&apos;, this.value); &#125;&#125;myObj.showValue(); // value: 0 函数调用模式1234567var add = function(a,b) &#123; return a + b;&#125;add(3,4); //7window.add(3,4); //7// 这种this被绑定到全局对象（window）。// 可以理解是window.add(3,4); 有种简单的办法就是var that = this;把this存储下。例：123456789101112131415var myObj = &#123; value: 0, age: 20, showValue: function() &#123; console.log(&apos;value:&apos;,this.value); var that = this; var showAge = function() &#123; // window上没有age，所以是undefined console.log(&apos;这里的this是window ---age:&apos;, this.age); // undefined console.log(&apos;age:&apos;, that.age); // 20 &#125; showAge(); &#125;&#125;myObj.showValue(); // 0， undefined， 构造器调用模式JavaScript是一门基于原型继承的语言。如果在一个函数前面带上new 来调用。那么背地利将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。new 前缀也会改变return 语句的行为。例：1234567var Quo = function (string) &#123; this.status = string;&#125;Quo.prototype.get_status = function () &#123; return this.status; &#125;var myQuo = new Quo(&apos;confused&apos;); // &apos;confused&apos; 一个函数，如果创建的目的就是希望结合new 前缀来调用。那么它就被称为构造器函数。按照约定，它们保存在以大写函数命名的变量里。如果调用构造器函数时没有在前面加上new,可能会发生非常糟糕的事情，既没有编译时的警告，也没有运行时广告，所以大写约定非常重要。作者不推荐这种形式的构造器函数。有更好的替代方式。Apply调用模式JavaScript是一门函数式的面向对象编程语言，所以对象可以拥有方法。apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值。参数arguments，虽然拥有length属性，但不是真正的数组。而是类似数组（array-like）的对象。返回return 可用来是函数提前返回。当return 被执行时，函数立即返回而不再执行余下的语句。一个函数总会返回一个值，如果没指定，那就是返回undefined值。如果函数调用时在前面加上了new 前缀，且返回值不是一个对象，则返回this（该新对象）。异常JavaScript提供了一套异常处理机制。throw语句和try catch,try catch中finally是可选的。扩展类型的功能JavaScript允许给语言的基本类型扩充功能。在第3章中我们已经看到，可以通过Object.prototype添加方法，可以让该方法对所有对象都可用。这样的方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用。 例如：1234Function.prototype.method = function () &#123; this.prototype[name] = func; return this;&#125; 基本类型的原型是公用结构，所以在类库混用时务必小心。一个保险的做法就是只在确认没有该方法时才添加它。123456Function.prototype.methods = function(name, func) &#123; if (!this.prototype[name]) &#123; this.prototype[name] = func; &#125; return this;&#125; 递归递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，递归是用一般的方式去解决每一个子问题。书中举了一个汉诺塔的例子，是程序设计中经典递归问题。详细说明可以参见 百度百科“汉诺塔”词条。一些语言提供了尾递归优化。尾递归是一种在函数的最后执行调用语句的特殊形式的递归。参见Tail call。 ES6版本扩展了尾递归。参见阮一峰老师的《ES6标准入门》中的尾调用优化作用域在编程语言中，作用域控制着变量与参数的可见性和声明周期。书中指出当前JavaScript没有块级作用域。因为没有块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。不过ES6扩展了有块级作用域。闭包作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）。例子：123456&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 123456789101112131415// 点击相应节点时，显示对应的序号。可以使用闭包来解决。var add_the_handlers = function() &#123; var helper = function(i) &#123; return function(e) &#123; alert(i); &#125; &#125; var i; for (i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = helper(i); &#125;&#125;// 扩展 另外可以用let i = 0，或者把nodes类数组转成数组等方案实现。// 闭包特性：1、函数内再嵌套函数，2、内部函数可以调用外层的参数和变量，3、参数和变量不会被垃圾回收机制回收。// 闭包优点 灵活和方便，便于封装。缺点：空间浪费、内存泄露、性能消耗。 回调发起异步请求，提供一个当服务器响应到达时随即出发的回调函数。异步函数立即返回，这样客户端就不会被阻塞。模块我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。举例：给String添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换成对应的字符。12345678910111213141516String.method(&apos;deentityify&apos;, function () &#123; // 字符实体表。它映射字符实体的名字到对应的字符。 var entity = &#123; quot: &apos;&quot;&apos;, lt: &apos;&lt;&apos;, gt: &apos;&gt;&apos; &#125;; // 返回 deentityify方法 return function () &#123; return this.replace(/&amp;([^&amp;;]+);)/g, function (a,b) &#123; var r = entity[b]; return typeof r === &apos;string&apos;? r : a; &#125; &#125;;&#125;()); 模块模式利用了函数作用域和闭包来创建被绑定对象与私有成员的关联，在上面例子中，只有deentityify方法有权访问字符实体表这个数据对象。模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。 单例译注模块模式通常结合单例模式使用。JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化。更多内容参见：单例模式 级联有一些方法没有返回值。如果我们让这些方法返回this而不是undefined，就可以启用级联。在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。比如jQuery获取元素、操作样式、添加事件、添加动画等。柯里化柯里化，是把多参数函数转换为一系列单参数函数并进行调用的技术。更多详情可参见：柯里化函数也是值。柯里化允许我们把函数与传递给它的参数相结合，产生一个新的函数。12var add1 = add.curry(1);document.writeln(add1(6)); JavaScript并没有curry方法，但可以扩展该功能。arguments不是真正的数组，所以使用了Array.prototype.slice方法。12345678Function.method(&apos;curry&apos;,function()&#123; var slice = Array.prototype.slice, args = slice.apply(arguments), that = this; return function() &#123; return that.apply(null, args.concat(slice.apply(arguments))); &#125;&#125;); 记忆函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化称作记忆。比如说，我们想要一个递归函数来计算Fibonacci(斐波那契)数列，它的特点是，前面相邻两项之和等于后一项的值。更多参考：斐波那契。最前面两个数字是0和1。123var fibonacci = function() &#123; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125; 这样虽然能完成工作，但它做了很多无谓的工作。构造一个带有记忆功能的函数：1234567891011var memoizer = function(mome, formula) &#123; var recur = function(n) &#123; var result = meno[n]; if (typeof result !== &apos;number&apos;) &#123; result = formula(recur, n); meno[n] = result; &#125; return result; &#125;; return recur;&#125; 再用这个memoizer函数来定义fibonacci函数，提供其初始的memo数组和formula函数。123var fibonacci = memoizer([0,1],function(recur, n)&#123; return recur(n-1) + recur (n-2);&#125;) 极大的减少了我们的工作量。例如要产生一个记忆的阶乘函数，只需要提供基本的阶乘公式即可：123var factorial = meoizer([1,1], function(recur, n)&#123; return n * recur(n-1);&#125;); 第5章 继承伪类JavaScript的原型存在诸多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。Function构造器产生的函数对象会运行类似这样的一些代码：1this.prototype = &#123;constructor:this&#125; 新函数对象被赋予一个prototype属性，这个prototype对象是存放继承特征的地方。 当采用构造器调用模式，即用new前缀去调用一个函数时，函数执行的方式会被修改。如果new运算符是一个方法而不是一个运算符，它可能像这样执行： 12345678Function.method(&apos;new&apos;,function()&#123; // 创建一个新对象，它继承自构造器函数的原型对象。 var that = Object.create(this.prototype); // 调用构造器函数，绑定 -this- 到新对象上。 var other = this.apply(that,arguments); // 如果它的返回值不是一个对象，就返回该新对象。 return (typeof other === &apos;object&apos; &amp;&amp; other) || that;&#125;); 所有构造器函数都约定命名成大写字母。一种更好的备选方案就是根本不使用new。对象说明符就是指传多个参数时，可以直接传递一个对象。原型可以用Object.create方法构造出更多实例来。函数化迄今为止，我们所看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。我们无法得到私有变量和私有函数。幸运的是，我们有一个更好的选择，那就是应用模块模式。我们从构造一个生成对象的函数开始。我们以小写字母开头来命名。该函数包括以下四个步骤1、创建一个新对象。2、有选择地私有实例变量和方法。3、给这个新对象扩充方法。4、返回那个新对象。以下是一个函数化构造器的伪代码模板12345678var constructor = function (spec, my) &#123; var that, 其他的私有实例变量； my = my || &#123;&#125;; 把共享的变量和函数添加到my中 that = 一个新对象 添加给 that 的特权方法 return that;&#125; 函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们更好的封装和信息隐藏，以及访问父类方法的能力。部件我们可以从一套部件中把对象组装出来。 第6章 数组数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。数组是一种性能出色的数据结构。不幸的是，JavaScript没有像此类数组一样的数据结构。数组字面量对象字面量数组继承了Array.prototype大量有用的方法。而对象字面量是继承自Object.prototype。数组有length属性，而对象没有。长度每个数组都有一个length属性。可以直接设置length的值。设置更大的length不会给数组分配更多的空间，而设小导致所有下标大于等于新length的属性被删除。123var arr = [1,2,3];arr.length = 1;console.log(arr) // [1] 也可以通过length来通过添加值123var arr = [1,2,3];arr[arr.length] = 4;console.log(arr) // [1,2,3,4] 有时用push方法更方便。删除由于JavaScript的数组也是对象，所以delete运算符可以用来从数组中移出元素。移除后，长度不变，原位置上变成了undefined。可以使用Array.prototype.splice方法删除数组。枚举JS数组就是对象，所以for in语句可以用来遍历数据的所有属性。不过，for in无法保证属性顺序。并且可能从原型链中得到意外的属性。for循环可以避免以上问题。容易混淆的地方12typeof [] === &quot;object&quot;; // truetypeof &#123;&#125; === &quot;object&quot;; // true 识别是否是数组。1234// 方法一、var is_array = function (value) &#123; return value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Array;&#125;; 但它在识别从不同窗口（window）或帧（frame）里的构造的数组时会失败。有一个更好的方式：1234// 方法二、var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === &apos;[object Array]&apos;;&#125; 扩展：ES5 提供了Array.isArray()的方法。不过兼容性是IE9+。要做到兼容，可以用如下方法。MDN上提供的。MDN Array.isArray123456// 方法三、if (!Array.isArray)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; &#125;;&#125; 1234567var arr = [];// 方法四arr instanceof Array;// 方法五Array.prototype.isPrototypeOf(arr);// 方法六Object.getPrototypeOf(arr) === Array.prototype; 方法四、instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。方法五、isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。方法六、[Object.getPrototypeOf() 方法返回指定对象的原型（即, 内部[Prototype]]属性的值）。小结：除了方法二、三外，面对复杂的环境，其他的都不能准确的判断是否是数组。方法JavaScript提供了一套数组可用的方法，这些方法是被存储在Array.prototype中的函数。Object.prototype是可以扩充的。Array.prototype也是可以扩充的。ES5中提供的Object.create方法。这方法用在数组是没有意义的，因为它产生的是一个对象，而不是一个数组，产生的对象将继承这个数组的值和方法，但它没有length特殊属性。指定初始值JavaScript的数组通常不会预设值。书中写了一个循环来扩展，生成初始值。扩展：ES6中提供了fill来填充。比如：12345[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(0); // [0,0,0]new Array(3).fill(0); // [0,0,0]// fill方法还可以接受第二、第三个参数，用于指定填充的起始位置和结束位置（不包含）。new Array(3).fill(0,1,2); // [ ,0, ,] 空位不是undefined。空位没有任何值。ES6则是明确将空位转为undefined。 第7章 正则表达式正则表达式对字符串中的信息实现查找、替换和提取操作。可处理正则表达式的方法有regexp.exec、regexp.test、string.match、string.search和string.split。通常来说，正则相较于等效的字符串处理有着显著的性能优势。 一个例子12345// 正则表达式必须写在一行中var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;var url = &quot;http://www.ora.com:80/goodparts?q#fragment&quot;;var result = parse_url.exec(url);// …… 依次匹配到的是：12345678url: &apos;http://www.ora.com:80/goodparts?q#fragment&apos;,scheme: &apos;http&apos;,slash: &apos;//&apos;host: &apos;www.ora.com&apos;port:&apos;80&apos;path:&apos;goodparts&apos;query: &apos;q&apos;hash: &apos;fragment&apos; 个人扩展：这里推荐 在线测试正则表达式的网站regex101，默认是PHP语言，选择JavaScript语言。在线图形化RegExp工具MDN RegExp.prototype.exec()大概解释下这个正则，这里的^ 起始位置，$结束位置() 分组捕获 ?:不捕获.表示除换行以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，点(.)不能识别（ES6中加u修饰符才可识别），+表示一个或多个，*表示零个或多个，?表示0个或一个。[]表示或者，里面符合一个即可。\\d表示数字0-9。不严谨的正则表达式是一个常见的安全漏洞的发源地。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。 再看一个 匹配数字的例子。1234567var parse_number = /^-?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?$/i;parse_number.test(&apos;1&apos;); // trueparse_number.test(&apos;number&apos;); // falseparse_number.test(&apos;98.6&apos;); // trueparse_number.test(&apos;132.21.86.100&apos;); // falseparse_number.test(&apos;123.45E-67&apos;); // trueparse_number.test(&apos;123.45D-67&apos;); // false 结构有两个方法来创建一个RegExp对象。优先考虑的是正则表达式字面量，还有一种方式是new RegExp(&#39;&#39;,&#39;g&#39;)。正则表达式标识：g全局(匹配多次，不同的方法对g标识的处理防范各不相同)，i忽略大小写。m多行元素正则表达式分支|表示或，也表示分支 比如：1&apos;info&apos;.match(/in|int/) // 匹配成功，[&quot;in&quot;, index: 0, input: &quot;info&quot;] 正则表达式序列一个正则表达式序列饱和一个或多个正则表达式因子。每一个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，若没指定，这个因子则只匹配一次。正则表达式因子1\\ / [ ] () &#123; &#125; ? + * | . ^ $ 正则表达式转义\\ 表转义 \\f 分页 \\n 换行 \\r回车 \\t 制表\\u 允许制定一个 Unicode 字符来表示一个十六进制的常量。\\d 等同于[0-9] \\D 取反等同于 [^0-9]\\s Unicode 空白符一个不完全子集。 \\S 与\\s相反\\w [0-9A-Z_a-z] \\W 与其相反 [^0-9A-Z_a-z]\\b 表示 字边界\\1 表示 分组1所捕获的文本的一个引用，所以它能被再次匹配。\\2 表示 指向分组2的引用，\\3 是表示分组3的引用，以此类推。正则表达式分组捕获型()非捕获型?:向前正向匹配?=有一个(?=前缀。它类似于非捕获类型分组，但在这个组匹配后，文本会倒回到它它开始的地方，实际上并不匹配任何东西。也可以理解为匹配位置。向后负向匹配有一个(?!前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。正则表达式字符集正则表达式字符集是一种指定一组字符的便利方式。例如，要匹配一个元音字母，(?:a|e|i|o|u),可以方便的写成[aeiou]。类提供另外两个便利：①指定字符范围所以，一组由32个ASCII的特殊组合，可以写成[!-\\/:-@\\[-{-~]`②类的取反取反1[^!-\\/:-@\\[-`&#123;-~] 正则表达式字符转义字符类内部的转义规则和正则表达式因子的相比稍有不同。下面是在字符类中需要被转义的特殊字符。1- / [ \\ ] 正则表达式量词量词后缀决定正则表达式因子应该被匹配的次数。{3}三次{3,6} 3、4、5、6次{3,}3次或更多次?等同于{0,1}，*等同于{0,}，+等同于{1,}。 第8章 方法Arrayarray.concat(item…)concat 方法产生一个新数组，它包含一份array的浅复制并把一个或多个参数item附加在其后。如果item是数组，那么每个元素分别被添加。后面有和它功能类似的array.push(item...)方法。1234var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];var c = a.concat(b, true);// c =&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,true] 扩展： ES6 有更便捷的扩展运算符...123var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];var c = [...a,true,...b]; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, true, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;] array.join(separator)join方法把一个array构造成一个字符串。separator 默认值就是逗号&#39;,&#39;。如果你想把大量的字符串片段组装成一个字符串，把这些片段放在一个数组中，并用join方法连接起来通常比用+元素运算符连接起来要快。 译注：对于IE6/7，使用join连接大量字符串效率确实优于加号运算符。但目前主流浏览器，包括IE8以后的版本，都对+元素运算符连接字符串做了优化，性能已经显著高于Array.join()。所以目前大多数情况下，建议首选使用+ 连接字符串。更多参看《高性能网站建设进阶指南》中字符串优化相关章节。 array.pop()pop方法移除array中的最后一个元素，并返回这个元素。如果array为空，则返回undefined。1234567var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var c = a.pop(); // a 是 [&apos;a&apos;,&apos;b&apos;] c是 &apos;c&apos;// pop 可以像这样实现。// 这里的 Array.method()在第一章例子中已经定义了，并且贯穿全书。其实就是相当于Array.prototypeArray.method(&apos;pop&apos;, function () &#123; return this.splice(this.length-1,1)[0];&#125;); array.push(item…)与concat不同的是，它会修改array，如果参数item是数组，它会把参数数组作为单个元素整个添加到数组中。并返回这个array的新长度值。12345var a = [1,2,3];var b = [4,5,6];var c = a.push(b,true);// a 是 [1,2,3,[4,5,6],true]// c 是 5 push可以像这样实现：1234567Array.method(&apos;push&apos;, function () &#123; this.splice.apply( this, [this.length,0]. concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); array.reverse()reverse反转array元素顺序，并返回array本身。123var a = [1,2,3];var b = a.reverse();// a 和 b都是 [3,2,1] array.shift()shift移除array的第一个元素并返回这个元素。如果array为空，则返回undefined。shift通常比pop慢的多。12var a = [1,2,3];var c = a.shift(); // a 是[2,3] , c 是1 shift可以这样实现：123Array.method(&apos;shift&apos;, function()&#123; return this.splice(0,1)[0];&#125;); array.slice(start[, end])slice是对array中的一段做浅复制。end是可选的。默认是array.length,如果两个参数任何一个是负数，array.length会和相加。如果start大于array.length,获得一个[],字符串也有Sting.slice这个同名方法。array.sort默认不能给一组数字排序。默认把要被排序的元素都视为字符串。幸运的是，可以使用自己的比较函数替换默认的比较函数。比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。sort方法是不稳定的。JavaScript的sort方法的稳定性根据不同浏览器的实现而不一致。可参见MDN sortarray.splice(start, deleteCount,item…)splice方法从array中移除一个或多个元素，并用新的item替换它们。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// splice 可以像这样实现Array.method(&apos;splice&apos;,function (start, deleteCount) &#123; var max = Math.max, min = Math.min, delta, element, insertCount = max(arguments.length - 2, 0), k = 0, len = this.length, new_len, result = [], shift_count; start = start || 0; if (start &lt; 0) &#123; start += len; &#125; start = max(min(start, len), 0); deleteCount = max(min(typeof deleteCount === &apos;number&apos; ? deleteCount : len, len - start), 0); delta = insertCount - deleteCount; new_len = len + delta; while (k &lt; deleteCount) &#123; element = this[start + k]; if (element !== undefined) &#123; result[k] = element; &#125; k += 1; &#125; shift_count = len - start - deleteCount; if (delta &lt; 0) &#123; k = start + insertCount; while (shift_count) &#123; this[k] = this[k - delta]; k += 1; shift_count -= 1; &#125; this.length = new_len; &#125; else if (delta &gt; 0) &#123; k = 1; while (shift_count) &#123; this[new_len - k] = this[len - k]; k += 1; shift_count -= 1; &#125; this.length = new_len; &#125; for (k = 0; k &lt; insertCount; k += 1) &#123; this[start + k] = arguments[k + 2]; &#125; return result;&#125;); array.unshift(item…)unshift 方法像push方法一样，不过是用于把元素添加到数组的开始部分，返回新array的length。123456// unshift 可以像这样实现Array.method(&apos;unshift&apos;, function()&#123; this.splice.apply(this, [0,0].concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); Functionfunction.apply(thisArg,argArray)apply方法调用function,传递一个会被绑定到this上的对象和一个可选的数组作为参数。 Numbernumber.toExponential(fractionDigits)toExponential方法 把这个number转换成一个指数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。 number.toFixed(fractionDigits)toFixed方法把这个number转换成一个十进制数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。 number.toPrecision(precision)toPrecision方法把这个number转换成一个十进制数形式的字符串。可选参数控制数字的精度。它的值必须在0~21。 number.toString(radix)把number转换成字符串。可选参数控制基数。它的值必须是2~36。默认的radix是以10为基数的。radix参数最常用的是整数，但是它可以用任意的数字。 Objectobject.hasOwnProperty(name)如果这个object包含名为name的属性，那么返回true。原型链中的同名方法不会被检测。这个方法对name就是“hasOwnProperty”时不起作用。 RegExpregexp.exec(string)exec是正则中最强大(和最慢）的方法。如果成功匹配，它会返回一个数组。下标为0 的元素包含正则匹配的子字符串。下标为1的则是分组1捕获的文本。下标为2的则是分组2捕获的文本。以此类推。如果匹配失败则返回null。regexp.test(string)test是最简单(和最快)的方法。匹配成功，返回true,否则返回false。不要对这个方法使用g标识。比如：12345678var reg = /\\w+/g;reg.test(&apos;ab&apos;); // true// 再执行一遍就是false了。reg.test(&apos;ab&apos;); // false// 再执行一遍就是true了。reg.test(&apos;ab&apos;); // true// 再执行一遍又是false了，如此反复，所以用g标识后，看起来很诡异。应该每次匹配开始位置变了。reg.test(&apos;ab&apos;); // false test可以像这样实现：123RegExp.method(&apos;test&apos;, function(string)&#123; return this.exec(string) !== null;&#125;); Stringstring.charAt(pos)返回在string中的pos位置处的字符。 string.charCodeAt(pos)与charAt一样，不过返回整数形式表示字符码位。 string.concat(string)很少用，用+号运算符更方便。 string.indexOf(searchString,position)在string中查找第一个参数，如果被找到返回该字符的位置，否则返回-1。position可设置指定位置开始查找。 string.lastIndexOf(searchString,position)lastIndexOf 方法和indexOf方法类似，不过它是从末尾开始查找，不是从头开始。 string.localeCompare(that)比较两个字符串。类似于array.sort。 string.match(regexp)如果没有g标识，那么调用string.match(regexp)和调用regexp.exec(string)结果相同。如果带有g标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组。 string.replace(searchValue,replaceValue)对string进行查找和替换操作，并返回一个新的字符串。参数searchvalue可以是一个字符串也可以是一个正则表达式对象。参数replaceValue可以是一个字符串或一个函数。 string.search(regexp)和indexOf类似，不过它接收正则为参数。 string.slice(start, end)slice方法复制string的一部分来构造一个新的字符串。如果start参数是负数，它将与string.length相加。end参数是可选的。 string.split(separator,limit)把string分割成片段来创建一个字符串数组。可选参数limit可以限制分割的片段数量。separator参数可以是字符串或者正则。string.substring(start,end)与slice方法一样，不过它不能处理负数参数。string.toLocaleLowerCase()它使用本地化的规则把这个string中的字母转换成小写格式。这个方法主要用在土耳其语上。string.toLocaleUpperCase()它使用本地化的规则把这个string中的字母转换成大写格式。这个方法主要用在土耳其语上。string.toLowerCase()返回新字符串，所有字母转成小写格式。string.toUpperCase()返回新字符串，所有字母转成大写格式。String.fromCharCode(char…)根据一串数字编码返回一个字符串。1var a = String.fromCharCode(67,97,116) // a是&apos;Cat&apos; 第9章 代码风格这一章中，简短的说了一些代码风格。事实证明代码风格在编程中是很重要的。 第10章 优美的特性精简的JavaScript里都是好东西。包括：1、函数是顶级对象；2、基于原型继承的动态作用域；3、对象字面量和数组字面量。 到此，读书笔记已完结。文章有什么不妥之处，欢迎指出~ 关于作者：常以轩辕Rowboat为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。个人博客segmentfault个人主页掘金个人主页知乎github","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/tags/读书笔记/"}],"keywords":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/categories/读书笔记/"}]},{"title":"工作一年后，我有些感悟","slug":"20170602-After a year's work, I had some insights","date":"2017-06-02T14:20:53.000Z","updated":"2018-06-23T14:41:12.801Z","comments":true,"path":"2017/06/02/20170602-After a year's work, I had some insights/","link":"","permalink":"https://lxchuan12.github.io/2017/06/02/20170602-After a year's work, I had some insights/","excerpt":"去年6月1日，入职那天早上下着小雨。在公司取了一个花名：轩辕，后来把网上昵称基本都改成了轩辕Rowboat。还记得那天晚上朋友请我吃小龙虾。 今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。","text":"去年6月1日，入职那天早上下着小雨。在公司取了一个花名：轩辕，后来把网上昵称基本都改成了轩辕Rowboat。还记得那天晚上朋友请我吃小龙虾。 今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。 学习工作从校园到职场 主动认识同事。 虽然不太可能与每一个同事都能相处的特别熟。但对于新人，都会被拉入一些群。这时候，可以加同事QQ或者微信等（同事一般不会拒绝），便于之后沟通交流工作。 这时候有的人能够主动快速得认识团队里的同事。有的人则是入职了很久都不认识对面的同事。 把离别看得平淡了许多。大学毕业后，很多人一晃一年没见，是再正常不过的事了。 同事离职后，即使还在同一个城市，但交集就变少了。 有江湖的地方就有规矩，职场也有。在职场只要用心去发现，能够学到公司的管理方式等。 认清自己的定位 常和别人开玩笑说，自己是来自贫困的小山村的一个大学生，职业是：说的高端一点是前端开发工程师，说的通俗易懂点则是做网站的程序猿。嗯，这就算是一种定位。 像我这样的人几百万。想起一个朋友说：感觉你在IT方面很厉害。我说：你只是认识万千程序猿中的一个而已。 学无止境，提升竞争力 智联招聘网显示：web前端开发是竞争最激烈的职业。 上次听一次segmentfault的讲堂，其中有提到慕课网有很多用户，其中400万是前端开发。 有时候会想我这一年是不是学习方式不对，不够努力，或者说能否再努力一点，是不是能够进入更好的大公司，能够得到更好的成长。 事实证明，自身能力不够，有机遇来了，会抓不住。 比如：之前有面试过淘宝、大搜车等，然而技术一般，没能通过面试。 现实生活我读大学买了电脑考了驾照，四年花了家里4万块左右（从大一暑假买电脑开始算到大四结束，用Excel统计家里打了25200元给我）。而在杭州待一年光吃住就得花近3万块（吃饭按一天40元算，一个月1200，租房1100+）。 最近看的电视剧《欢乐颂2》中，身为90后的程序猿应勤在大上海买了车买了房（好像还提到是全额付款）。现实中在大上海房价均价5.5万/平米，有人分析单靠程序猿那点工资（虽然IT行业相对其他行业薪资高些）是不太可能的。 展望未来看到毕业几年的同事过着怎样的生活，可以推测出几年后的自己大概过着怎样的生活。当然未来的一切都是未知的。但基本能看出自己一年后是过着怎样的生活。 月薪两万的薪资算是很不错了，但是在大城市算刚起步，为什么算刚起步，主要因为房价太高，买个房好几百万。比较优秀的前端开发工程师，工作三年后月薪大概能达到15K—20K，当然各城市不一。再往后，能达到年薪50万左右已经是非常不错了。 如何提高收入，是大家关心的永恒的话题。5月份我们从学校课题组出来的三个同学回学校时，在高铁上上讨论过，毕业一年有什么感觉，大家都一致认为：要想单靠开发这点薪资，在大城市立足，是非常艰难的。然后想着有哪些赚钱之道，都可以去试试，刚毕业一年，还算很早。 主要说到三条。第一条是：加入有潜力的团队初创公司（拿股份）。同学就说到他们老大的事迹，说刚靠程序猿这点工资在大城市过上小资生活是很艰难的，他之前加入阿里后来拿股份才开了现在的公司（大概意思是这样）。 第二条是：拓展自己的人脉，找准风口，好创意，自己组建团队开发出有价值的产品。说到这条我就提到小密圈（付费圈子，我加入一个圈子收费200，有700+人加入，运营一年，就能得到14万的收入。） 我自己也建了一个前端视野的小密圈（免费），发发自己关于前端开发的所见所想，也好沉淀沉淀，没打算怎么推广，但这里还是贴一下二维码，万一有人想加入呢。 。 [前端视野-小密圈-一个人走得快，一群人走得远] 前端视野-小密圈-一个人走得快，一群人走得远还建有一个PPT视野的圈子，这个目前还没发过动态。 第三条则是：发展一项兴趣爱好，打造个人品牌，做到可以赚大钱的地步。（有人刚毕业4K，毕业三年，凭借PPT，开商务PPT训练营收费课程，年薪50万）。他们经常问我可以多接些PPT来做，就可以赚点钱了，我说目前没有时间，也没有渠道，而且我也是只是万千PPT设计师中很渣的一员。 想做到收入更高，除了做好本职工作和提升专业素养外，也需要跳出来看看外面的世界。 上次和同学几人一起玩的时候，有个妹纸说了这句，何以解忧，唯有暴富。让我记忆犹新。 事实上群体中确实有小概率事件发生，比如中个上千万的彩票，但是对于个体，这种事几乎不可能发生。而且有研究表明，中彩票的普通人，一般会在五年后用完这笔财富，最后还是普通人。 所以说：提高自己在各方面的竞争力，比如：为人处事、沟通表达、团队协作等等，这也就是可迁移能力，以不变应对这个变化的世界，才是最重要的。 这是我写在简书的文章：工作一年后，我有些感悟","categories":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/tags/随笔/"},{"name":"感悟","slug":"感悟","permalink":"https://lxchuan12.github.io/tags/感悟/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}]},{"title":"如何破解百度网盘下载限制及网盘搜索技巧","slug":"20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips","date":"2017-03-17T14:52:23.000Z","updated":"2017-06-24T15:22:02.618Z","comments":true,"path":"2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/","link":"","permalink":"https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/","excerpt":"今天两个朋友问我如何选电脑的问题，我说了一些大概流程，需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买。其实我好久没有关注这方面了，毕竟没钱买电脑。晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。","text":"今天两个朋友问我如何选电脑的问题，我说了一些大概流程，需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买。其实我好久没有关注这方面了，毕竟没钱买电脑。晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。大学里也会去图书馆看看纸质的。然后找到 2017年《电脑报》的看了一会。看到一篇《如何破解百度网盘下载限制》的文章，我试过后有效，特来分享整理给大家。在chrome浏览器中，新建一个书签，书签名字随意，书签的网址复制粘贴这段代码：javascript:navigator.__defineGetter__ (&#39;platform&#39;,function(){return &#39;&#39;}); 它的作用是防止下载大文件时唤醒百度网盘客户端。 所以在点击“下载”前，先点击它。待开始下载后，打开浏览器的“下载内容”（快捷键：Ctrl+J），看到正在进行的下载任务选择“复制链接地址”。 右击复制链接地址.png 将地址粘贴到迅雷极速版下载，官方好像不提供下载链接了，这里推荐百度软件中心下载地址http://rj.baidu.com/soft/detail/26860.html ,点击普通下载即可，这样就可以了。 虽然速度不是非常稳定但至少比百度云盘PC客户端几十KB／s快。不建议大家再安装破解版，有钱还是买个会员吧，或者干脆上NAS。 可能有小伙伴好奇我是如何找到2017年的《电脑报》的。 搜百度盘.png 这时分享几个网盘搜索网站： （常用）搜百度盘：http://www.sobaidupan.com 搜索“罗小川chuan”结果.png 搜索“罗小川chuan”结果，可怕，我得赶紧取消一些个人信息的公开分享了。 盘搜网：http://www.pansou.com/搜盘网：http://www.soupan.info/ 之前书签里保存的网盘搜索网站.png 等等，其他就不附链接了。","categories":[{"name":"网盘搜索","slug":"网盘搜索","permalink":"https://lxchuan12.github.io/categories/网盘搜索/"}],"tags":[{"name":"window","slug":"window","permalink":"https://lxchuan12.github.io/tags/window/"},{"name":"skyDrive","slug":"skyDrive","permalink":"https://lxchuan12.github.io/tags/skyDrive/"},{"name":"Baidu","slug":"Baidu","permalink":"https://lxchuan12.github.io/tags/Baidu/"}],"keywords":[{"name":"网盘搜索","slug":"网盘搜索","permalink":"https://lxchuan12.github.io/categories/网盘搜索/"}]},{"title":"简单实用免费的shadowsocks科学上网技巧","slug":"20170306-freess","date":"2017-03-06T15:02:23.000Z","updated":"2018-11-22T16:17:02.150Z","comments":true,"path":"2017/03/06/20170306-freess/","link":"","permalink":"https://lxchuan12.github.io/2017/03/06/20170306-freess/","excerpt":"开发时遇到问题，一般都是使用谷歌搜索，相对百度更加精准一些。比如搜索我的网名轩辕Rowboat，一大堆结果。","text":"开发时遇到问题，一般都是使用谷歌搜索，相对百度更加精准一些。比如搜索我的网名轩辕Rowboat，一大堆结果。 谷歌搜索轩辕Rowboat结果.png 谷歌书签同步，YouTube等等。总是需要科学上网的。一次偶然的机会发现了这个网站，FreeSS-最好用的免费SS提供站点 有时不是很稳定。链接地址有时会变更，现在可以访问(https://ss.freess.org/)，（2018-05-29 更新）（提供免费的ss账号）（免费为它打广告~）觉得好东西要分享给大家，于是写下这篇文章（当然我觉得很多人都会，但还是写了）。 下载shadowsocks（Mac，Android等可以下载相应版本）：windows各版本下载地址：https://github.com/shadowsocks/shadowsocks-windows/releases，这网址一般不会是失效。一般下载最新的Downloads-&gt;Shadowsocks-xxx.zip即可。 Mac，Android等可以在这个链接下载：https://github.com/shadowsocks我下载的是:3.4.3.zip版本 ，软件一直在持续更新，链接可能会失效。解压到电脑任意位置，点击打开Shadowsocks.exe程序，程序图标会出现在右下角。 打开这个网站http://freess.org/ ，配置打开任意一个二维码，鼠标移入你会发现有左右箭头，点击有多个二维码。右键程序图标，弹出菜单中选择“服务器”－“扫描屏幕上的二维码”，扫描成功后会自动配置，菜单中勾选“启用系统代理”即可。这时就可以使用任意浏览器科学上网了。不过这个免费的ss账号（目前2018-05-29可用），只限当天使用，次日得重新扫描。 编辑服务器 配置截图 当然只想用谷歌搜索不一定要科学上网，可以使用谷歌镜像搜索。（网上有一些谷歌镜像站，不过有一定局限性，也有一些可用谷歌学术搜索镜像）。 可能遇到问题：如果碰到打开时提示，版本过低。 版本过低.png 下载安装.netframework下载地址链接 更多使用说明可以查看：官方中文说明文档比如：配合谷歌插件（SwitchyOmega ）共同使用，可以做到系统代理和直接连接，自动切换，就不容易导致开了代理，连接不需要代理的网站异常了。SwitchyOmega插件下载安装地址更多SwitchyOmega插件使用方法，可以查看这篇文章，比较详细shadowsocks配合chrome插件SwitchyOmega 更多安装谷歌浏览器插件的方法可以查看这篇如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？ 更多原理相关可以查看这篇文章Shadowsocks 原理简介及安装指南 最后推荐一个的chrome 的科学上网插件 skyZIP™-Proxy不知道过了多久，后来上面推荐的那个网址 http://ss.freess.org 本身有时候好像就是要科学上网访问的。skyZIP™-Proxy 百度云盘链接: https://pan.baidu.com/s/1LvUkTGhd1m2HT5QJ9dSbwg 密码: 13x4可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何安装可以参照上文推荐的如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？ 上面的skyZIP™-Proxy目前不是很好用，开启时，访问不需要科学上网的网站比较慢。 鉴于很多人访问这篇文章，再推荐下笔者目前用的比较好用的免费的科学上网chrome插件。（2018-11-23 00:15:09 更新）首推这个：谷歌服务助手 也可以用谷歌访问助手。不过这个绑定主页，永久激活，比较麻烦。github上也有破解版谷歌访问助手 破解版。","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lxchuan12.github.io/categories/shadowsocks/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lxchuan12.github.io/tags/shadowsocks/"},{"name":"ss","slug":"ss","permalink":"https://lxchuan12.github.io/tags/ss/"},{"name":"科学上网","slug":"科学上网","permalink":"https://lxchuan12.github.io/tags/科学上网/"},{"name":"freess","slug":"freess","permalink":"https://lxchuan12.github.io/tags/freess/"}],"keywords":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lxchuan12.github.io/categories/shadowsocks/"}]},{"title":"Vue1.0和2.0的区别","slug":"20170212-The difference between vue1.0 and 2","date":"2017-02-12T07:04:23.000Z","updated":"2018-11-23T12:28:30.714Z","comments":true,"path":"2017/02/12/20170212-The difference between vue1.0 and 2/","link":"","permalink":"https://lxchuan12.github.io/2017/02/12/20170212-The difference between vue1.0 and 2/","excerpt":"重新仔细读了下文档，边看边写了一些。1、v-once只渲染一次。2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。全局过滤器和单个过滤器。","text":"重新仔细读了下文档，边看边写了一些。1、v-once只渲染一次。2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。全局过滤器和单个过滤器。1234&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 1&#123;&#123; message | filterA | filterB &#125;&#125; 1&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125; 3、watch允许异步操作。computed做不到。4、新增：v-else-if5、v-if中，使用 key 控制元素的可重用6、v-for (value,index)，$index被废除。 item in items,item of items.123&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 7、track-by=”$index”被废用，用key替代。（就地复用）7.1、template中不能使用this不是。data.a=1,template,直接写a即可。8、2.1.4新增9、2.1.0 新增可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。1234.ctrl.alt.shift.meta 10、修饰符lazy,number,trim11、组件中data 必须是函数123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 123&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 12、自定义事件，废除了events、$dispatch、$broadcast。使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件13、给组件绑定原生事件-修饰符.native1&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt; 使用自定义事件的表单输入组件14、非父子组件通信。15、slot分发内容。16、动态组件，参考：[译]Vue 动态组件17、子组件索引ref123456&lt;div id=&quot;parent&quot;&gt; &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)// 访问子组件var child = parent.$refs.profile 18、使用 v-once 的低级静态组件19、列表过渡,tag,v-movejQuery Event.stopImmediatePropagation() 函数详解 stopImmediatePropagation()函数用于阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/tags/Vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}]},{"title":"2016年度总结，毕业，工作","slug":"20170107-2016-annual-summary","date":"2017-01-07T13:40:38.000Z","updated":"2017-06-24T15:25:20.636Z","comments":true,"path":"2017/01/07/20170107-2016-annual-summary/","link":"","permalink":"https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/","excerpt":"1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。","text":"1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。 时间总是那么的快。2014年开始，就有了写个人年度总结的习惯。如果把2015年定义成PPT年，那么2016年则可以说是开发年。这一年相对比较平凡，还算满意。 2015年的年底，准备好了提前答辩的相关事宜。2016年元旦放假三天，在学校的课题组办公室翻看着微博（微博有时间轴，可以看到每个月都发了什么，这也就是为什么我比较喜欢发微博的原因之一），做着PPT，用思维导图工具Xmind，写着年度总结——《2015年总结，淡化旧标签，无惧未来 》。 翻看2016年的微博，看到大年初三的一条这样写着： 猴年初三（2月10日），去舅舅家拜年。舅舅极力要求我在他家住，说以后工作了，忙着赚钱，更是没什么时间住了。舅妈以为我还是21岁……然而过完年，虚岁就是24岁了，其实明明是22岁半。好吧，确实老了。到了尴尬的年纪。按这样算，还有6年就30岁了……这六年要赚好多钱。 最近听喜马拉雅付费精品中关于年度计划的，提到人生的8个方面,分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。于是根据这个把自己的2016年总结整理了一张思维导图和仿支付宝年账单做了一份年度总结PPT。 2016年度总结思维导图 2016年度总结PPT 未来的路在哪1、看周围同事，基本就能看到自己几年后是过着怎样的生活。试想这样的生活是不是自己想要的，如果不是又将做什么来改变呢。老板有时给我们开会也会问：一个员工加入一家公司终究会离开，你是否会认真考虑【我会在这里干多少年？想成为什么样的人】。2、再看看自己的校友，在移动互联网领域比较出名的有杜瑶，CSS参考手册作者（css.doyoe.com），去哪儿网前端技术总监。猎豹移动副总裁陈勇。柴魁元,乐动卓越科技有限公司CTO等等。3、如果仅从开发这条路来看，很容易看到自己的天花板。而且业界都一致认为，程序员是吃青春饭，看自己身边同事就知道年长的非常少。G20放假那次回家，跟老爸聊天，老爸聊到年轻的时候赚点钱容易，年纪大了就不容易了。何况你这工作吃的是青春饭，以后怎么办。我说：到时候再看，转行吧。比如这篇文章：一位工作十年程序员给的忠告 打造个人品牌（知识型IP）《程序员必读的职业规划书》有提到打造个人品牌；公司年中大会上，我司创始人（前阿里副总裁）也谈到IP；参加的网红经济论坛上更是对网红（IP）有一些深层次的解读；《和秋叶一起学职场技能》书中也有提到如何打造个人品牌。虽然，以前的积累，微博粉丝超过了1千，微信好友快1000，两个QQ的好友基本不重复，超过1400，但这些都是最低层次的无门槛自媒体。 我这名字，在我关注的圈子中，知道比较有名的大咖有小川叔。在公司叫花名（轩辕），于是把我在网络上的各种账号的昵称统一成轩辕Rowboat，也算是打造个人品牌的开始吧。 2016年，这一年出现了很多知识变现的产品，比如：微信公众号打赏，简书打赏，知乎live，分答，在行，微博的问答，喜马拉雅付费精品等。 原是程序员的彭小六就凭借着知识变现这一红利月入6位数。比如：《凭着这3个字，我上个月挣了6位数》也有程序员靠之前人气等多方面的积累，开一次知乎live，分享知识，就能赚1万+。之前在公众号看到的文章，《月入10W真的很难吗？》清华大学毕业阿何的一篇文章：《年轻人，如何挣到自己第一个100万？》文尾总结： 总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤：第一：找到自己的一个特长，把它培养得足够出色第二：找到适合你的特长，又有足够用户注意的平台第三：在这个平台上深耕细作，打造品牌，获得收入每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。 虽然这类文章有点夸大其词，鸡汤文的感觉，但也不无道理。总之这是赚钱思维的一种转变。 PPT圈内，布衣公子从2012年开始分享自己的PPT作品，他的作品影响着很多人。后来收费，一份作品就能卖到上万元。这是他分享他的故事时分享的五个故事。改变我命运的五个故事-布衣公子要在大城市生活，培养一种或几种可以「变现」的能力，并且这些能力不受地域的限制，似乎变得重要起来。 时间也是资源时间管理是永恒的话题，这篇文章写的挺好：毕业三年，你如何与同龄人拉开差距？ 世界发展太快，需要不断学习世界在发展，以前的很多岗位都不存在了。而且未来很多工作可以由机器人来完成，而且机器人比人类做得更优秀。另外年轻人的接触新鲜事物的学习能力相对比较强。那么持续学习，变得更加的重要了。","categories":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/tags/年度总结/"}],"keywords":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}]},{"title":"提高效率的webstorm技巧","slug":"20161207-webstrom-skill","date":"2016-12-07T14:48:18.000Z","updated":"2017-06-24T15:25:56.187Z","comments":true,"path":"2016/12/07/20161207-webstrom-skill/","link":"","permalink":"https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/","excerpt":"webstrom有一些基本的操作1、快速查找2、代码补全3、版本控制4、本地历史5、即时模板6、光标7、代码格式化等","text":"webstrom有一些基本的操作1、快速查找2、代码补全3、版本控制4、本地历史5、即时模板6、光标7、代码格式化等 基本操作双击shift搜索：快速查找。文件，函数名等。 template模板可以设置。 光标定位到相关位置。比如tilte,body每次修改的历史：local history。 多光标的功能。1、查找替换，ctrl+R2、alt+鼠标选择。 3、alt+单击。 4、格式化代码：ctrl+alt+L 菜单，code——reformat code。 5、快捷键可以自定义设置。 可以通过快捷键名称来查找。也可以通过怎么使用来查找快捷键，然后对其进行修改。webstrom预设了许多快捷键，可以自己选择。与原来的IDE快捷键相同。 Emmet详情参见：Emmet：HTML/CSS代码快速编写神器 1、Tab键，缩写的补全2、li中间写完，按enter键，光标直接定位到接下来的一个。3、嵌套结构：> + ^ ()子元素，同级，往上一级，重复，（）4、属性# （id）. （类）[]自定义属性div#container.container $ul&gt;li.item-$5{}文本p{click me}lorem没有意义的文字。用于排版。用法：lorem100注意事项：光标定位在最后（最想展开的）。不能有空格。比如：css中，bt:border-topm10:margin:10px;m10-20:margin:10px 20px;bdrs10:border-radius:10px;df：display：flex; 设置前缀。默认关闭这个开关。可以用其他工具来实现。、html:5,sublime text等编辑器可以安装emmet插件。 进阶操作一——常见快捷键操作，快捷键。 光标放在相对应的标签上，按F1，可以显示相关的描述，关联的站点等。js也是如此，参数列表等。比如 hello world要包裹在一个div中，选择这代码，ctrl+alt+T,选择第一个，输入div就变包裹在div中。 ——71、注释与取消注释ctrl+/2、选择选中子元素，alt+上/下3、粘贴ctrl+shift+V，最近粘贴板中的内容。4、删除当前行，ctrl+退格键。5、当前行上、下面加入一行上面加入一行。ctrl+alt+enter下面加入一行。ctrl+shift+enter.这样不需要刻意定位光标的位置。其实键盘上有（home,end)键。6、折叠代码，ctrl++（展开），ctrl+-(折叠)ctrl+shift++,ctrl+shift+-,所有可以折叠的地方全部折叠。在css中，js,html中都是如此。7、相邻位置代码换位置。alt+shift+上、下键。选中一段代码也可以让其上下移动。8、闭合标签，定位在两个标签位置。ctrl+m键。引号，括号，{}等也适用。window下好像无效。9、前进、后退到上一次编辑的地方。ctrl+alt+左右键。10、转到上一次编辑的地方。ctrl+shift+backspace键。11、最近使用的文件，ctrl+E——81、img标签，知道图片宽和高。方式1、输入路径，宽和高，按住Tab键可以自动补全。方式2、放在图片上，按F1图片预览，固定预览框。或者悬浮在文字上方。方式3、按住shift，鼠标浮在路径上，就可以看到图片的预览了。2、color:#999;色块上点击即可选择修改颜色。亮度（竖向）和透明度（横向）可以调节。 进阶操作二——重命名1、重命名， hello world，把光标放在标签上，ctrl+T,第一个就是重命名。window下试用无效。shift+F6重命名。2、其实直接写即可呀。对话框会显示有相同的地方，右击，排查或包含include，exclude.点击执行，do refactor。侧边有一些功能。2、函数名称，参数重命名。html,css,js中都可以重命名，类名，颜色，可以预览，避免把一些框架库里的相同东西修改了。、文件或文件夹也可以重命名。所有引用的地方也被修改了。 进阶操作三——代码检查webstrom使用了静态代码分析。不仅检查编译错误，而且代码效率低下，未使用的代码，非本地化的字符串，无法解析的代码，内存泄露，甚至编写问题等等。提示分为：错误，警告和正确。红色，橙黄色，或者绿色。一般来说是对整个项目进行检查的。也可以自己配置检查的范围。也可以自己运行检查。–&gt;code-&gt;Inspect code webstrom检查出来的不代表真的有错，还需要人工自己检查。一般在文件中，F2键可以在各个错误中切换。alt+enter，可以看到提示。（右侧的提示）规则自己设置，搜索inspec js是静态的校验。","categories":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/tags/tool/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}]},{"title":"关于我","slug":"about-me","date":"2016-11-20T14:36:52.000Z","updated":"2018-11-22T16:03:40.139Z","comments":true,"path":"2016/11/20/about-me/","link":"","permalink":"https://lxchuan12.github.io/2016/11/20/about-me/","excerpt":"","text":"简介某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。freecodecamp （简称FCC）杭州社区组织者之一。所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。 轩辕Rowboat由来轩辕Rowboat由来：轩辕(之前公司花名)。Rowboat，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），剑未佩妥，出门便是江湖。 家乡在很久很久以前，盘古开天辟地之时，后来…不知道经过了多少年。轩辕Rowboat，出生于江西吉安欧阳修（不知道欧阳修是谁？醉翁之意不在酒，在乎山水之间也。这个应该知道）故里的一个贫困的小山村，究竟有多贫困呢，各地贫困指数不一，就不得而知了。你们只需要知道小马云，就是来自我们的小县城上的一个镇上。百度百科词条：小马云 怎么走上前端路的再后来，我一不小心来到了某世界闻名的陶瓷大学拜师学艺，当然可想而知，没有学闻名于世界的陶瓷相关技艺。拜师学艺期间，遇见两位”师傅”，和其他两名弟子一同学习PHP+MySql，从此开始了我的Web开发学习之路，也有一些成果。机缘巧合，拉了两个山派（社团），再一不小心玩起了PPT，后来发现自己更加喜欢前端，期间又听说有个叫网易的招收前端开发微专业三期弟子，于是走向了这条漫漫前端路。一眨眼，四年过去了。2016年，下山来到了杭州闯江湖。深知时代在迅速发展，需不断学习。欲知更多详情请让鼠标走两步，看此文我是如何踏上前端这条路的。 联系我 知识星球【**前端视野**】二维码，欢迎扫码免费加入 同时也建了一个微信群【前端视野交流群】，欢迎加入（可以加我微信好友，拉您进群）。 主要发表一些前端所见所想，Vue、React、构建工具(比如：gulp、webpack)、设计模式等。一个人走得快，一群人走得远。 为啥要创建这个呢，可以查看这篇文章工作一年后，我有些感悟，同行大概都会有类似感慨。 同时建有一个微信交流群。(2019-06-20更新)欢迎加入。 segmentfault社区，偶尔在SF社区答题，虽然目前只有少得可怜的3.5K声望(2018-10-24更新)。掘金社区，有时也活跃在掘金社区。github，没有star过百，特别有价值的项目，不过有些可能有点价值，你可以瞧瞧。简书，偶尔在简书上写写文章。知乎，偶尔逛逛知乎，目前基本是看帖不回帖。微博，偶尔在微博上更新日常。微信嘛，很显然，一般人不会加我，但万一不是一般人呢，还是写下微信号lxchuan12和放下微信二维码，加友记得注明来源于博客。","categories":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/categories/关于我/"}],"tags":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/tags/关于我/"}],"keywords":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/categories/关于我/"}]},{"title":"数组方法splice和数组去重","slug":"20161029-array-splice-uniq","date":"2016-10-29T14:08:18.000Z","updated":"2016-10-29T15:47:36.020Z","comments":true,"path":"2016/10/29/20161029-array-splice-uniq/","link":"","permalink":"https://lxchuan12.github.io/2016/10/29/20161029-array-splice-uniq/","excerpt":"splice方法有删除、替换、添加的功能。修改原数组……","text":"splice方法有删除、替换、添加的功能。修改原数组…… 语法：array.splice(start, deleteCount[, item1[, item2[, …]]]) start整数，如果大于数组长度，itemN有值则为添加否则不添加。12345var arr=[1,2,3];//arr.splice(4,2);//console.log(arr);//[1,2,3]arr.splice(4,2,2);console.log(arr);//[1,2,3,2] 如果为负数，则从数组末尾倒数第一位。detecount整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。itemN要添加进数组的元素。如果不指定，则 splice() 只删除数组元素。返回值由被删除的元素组成的一个数组。未删除就是返回空数组。 删除123var arr=[1,2,3];arr.splice(1,2);console.log(arr);//[1] 替换123var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.splice(1,2,&apos;2&apos;,&apos;3&apos;);console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;] 添加123var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.splice(1,0,&apos;2&apos;,&apos;3&apos;);console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;，&apos;b&apos;,&apos;c&apos;] 数组去重题目：牛客网数组去重试题为 Array 对象添加一个去除重复项的方法 输入例子：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’, ‘a’, NaN].uniq()输出例子：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’] 解答：12345678910111213Array.prototype.uniq = function () &#123; var hasNaN = false; for(var i=0;i&lt;this.length;i++)&#123; if(this[i]!==this[i])hasNaN=true; for(var j=i+1;j&lt;this.length;j++)&#123; if(this[i]===this[j]||(hasNaN&amp;&amp;this[j]!==this[j]))&#123; this.splice(j,1); j--; &#125; &#125; &#125; return this;&#125; 较复杂的数组，一般思路是先判断类型再做去重。参考资料：MDN:Array.prototype.splice()js删除数组里的某个元素从 JavaScript 数组去重谈性能优化(玉伯)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"(转)背景图片固定不随内容滚动而滚动","slug":"20161016-background-attachment","date":"2016-10-16T14:48:38.000Z","updated":"2016-10-17T12:48:14.594Z","comments":true,"path":"2016/10/16/20161016-background-attachment/","link":"","permalink":"https://lxchuan12.github.io/2016/10/16/20161016-background-attachment/","excerpt":"有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法……","text":"有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法…… 第一种：背景附着属性(background-attachment)，代码如下：123456789101112131415&lt;html&gt;&lt;head&gt;&lt;title&gt;背景附着属性 background-attachment&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg); background-repeat:no-repeat; background-attachment:fixed&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-attachment属性，将背景图片固定，不随内容滚动而滚动。&lt;p&gt;&lt;p&gt;背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。&lt;/p&gt;&lt;p&gt;background-attachment要和background-image一起用。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第二种：背景位置属性(background-position)，代码如下：123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;背景位置属性 background-position&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg);background-repeat:no-repeat; background-position:20px 60px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-position属性。这个属性和background-image属性连在一起使用，决定了背景图片的最初位置。&lt;/p&gt;&lt;p&gt;上面的代码表示背景图片的初始位置距离网页最左面20px，距离网页最上面60px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第三种：背景属性(background)，代码如下：12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;背景属性 background&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background:#99FF00 url(../images/css_tutorials/background.jpg) no-repeat fixed 40px 100px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个属性是设置背景相关属性的一种快捷的综合写法， 包括background-color, background-image, background-repeat, backgroundattachment, background-position。&lt;/p&gt;&lt;p&gt;这个HTML所用的背景属性表示，网页的背景颜色是翠绿色，背景图片是background.jpg图片，背景图片不重复显示，背景图片不随内容滚动而动，背景图片距离网页最左面40px，距离网页最上面100px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 原文：背景图片固定不随内容滚动而滚动源自今日头条2017前端工程师实习生笔试题12345675、下面哪条声明能固定背景图片（）正确答案: A 你的答案: A (正确)background-attachment:fixed;background-attachment:scroll;background-origin: initial;background-clip: initial; ——————————————————————————置换元素与非置换元素a) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。b) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。 12345674、请选出所有的置换元素（）正确答案: A B C D 你的答案: A B C D (正确)A、imgB、inputC、textareaD、select","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"函数的length属性","slug":"20161009-function-length","date":"2016-10-09T13:30:12.000Z","updated":"2018-11-23T12:25:25.171Z","comments":true,"path":"2016/10/09/20161009-function-length/","link":"","permalink":"https://lxchuan12.github.io/2016/10/09/20161009-function-length/","excerpt":"看《ES6标准入门》中提到函数的length属性，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……","text":"看《ES6标准入门》中提到函数的length属性，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……查阅了MDN Function.length是这样描述的： length 是函数对象的一个属性值，指明该函数期望多少个参数，意即形参的个数。数量不包括剩余参数。相比之下，arguments.length 是函数被调用时实际传参的个数。 12345function test(a,b,c) &#123;&#125;test.length // 3function test(a,b,c,d) &#123;&#125;test.length // 4 看起来很简单，但是也有特殊的，如果函数内部是通过arguments 调用参数，而没有实际定义参数的话，length只会的得到0。12function test() &#123; console.log( arguments );&#125;test.length // 0 这个函数确实可以传入参数，而且内部也调用了参数，但是length却无法得知传入的参数的个数。只能在函数执行的时候通过arguments.length得到实参个数。123function test() &#123; console.log( arguments.length );&#125;test(1,2,3); // 输出 3test(1,2,3,4); // 输出 4 所以函数的length属性只能得到他的形参个数，而无法得知实参个数。 参考链接：js小记 function 的 length 属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"正则表达式知识点","slug":"20160922-RegExp","date":"2016-09-22T15:48:12.000Z","updated":"2016-10-23T15:11:22.449Z","comments":true,"path":"2016/09/22/20160922-RegExp/","link":"","permalink":"https://lxchuan12.github.io/2016/09/22/20160922-RegExp/","excerpt":"正则表达式(RegExp)1、什么是正则表达式1.1 什么叫“正则”—规则、模式—强大的字符串匹配工具……","text":"正则表达式(RegExp)1、什么是正则表达式1.1 什么叫“正则”—规则、模式—强大的字符串匹配工具……1.2 正则的写法–new RegExp(“a”,”ig”),需要传参只能用这种方案。–/a/ 2、正则表达式常用方法2.1 test—字符串判断—返回真假—正则.test(字符串)—例子：是否有不是数字的字符2.2 search字符串搜索–返回出现的位置–字符串.search(正则)–忽略大小写：i——ignore2.3 match获取匹配的项目,–返回数组–量词：+–全局匹配：g——global–例子：找出所有数字2.4 replace替换所有匹配–返回替换后的字符串–字符串.replace(正则,想替换的)–例子：敏感词过滤-例子：统计字符串中每个字符的出现频率/**统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率 不限制 key 的顺序 输入的字符串参数不会为空 忽略空白字符输入例子:count(‘hello world’)输出例子:{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}*/123456789function count_2(str) &#123; var obj = &#123;&#125;; // \\S:非空白符 str.replace(/\\S/g,function(s)&#123; !obj[s]?obj[s]=1:obj[s]++; &#125;) return obj;&#125;console.log(count_2(&apos;hello world&apos;)); –匹配子项–例子：日期格式化 3、正则表达式字符类3.1 任意字符-[abc]–例子：o[usb]t——obt、ost、out3.2 范围-[a-z]、[0-9]–例子：id[0-9]——id0、id53.3 排除-[^a]–例子：o[^0-9]t——oat、o?t、o t3.4 组合-[a-z0-9A-Z]实例：偷小说过滤HTML标签–自定义innerText方法 4、转义字符转义字符.（点）——任意字符\\d（[0-9]）、\\w（[a-zA-Z0-9_]）、\\s（空白符） 、\\b（单词边界）\\D（[^\\d]）、\\W（[^\\w]）、\\S（[^\\s]） 、\\B（[^\\b]）\\1 重复子项例子–获取class元素–找重复项最多的字符和个数 5、量词5.1 什么是量词出现的次数{n,m}，至少出现n次，最多m次例子：查找QQ号5.2 常用量词{m,n}:m到n次{n,}:至少n次{n}:正好n次*:任意次 {0,}？:零次或一次 {0,1}+:一次或任意次{1,} 正则收尾^ 开始$ 结束例子–是不是QQ号–去掉前后空格 6、常用正则例子高级表单校验匹配中文：[\\u4e00-\\u9fa5]行首行尾空格：^\\s|\\s$Email：^\\w+@[a-z0-9]+(.[a-z]+){1,3}$ 网址：[a-zA-z]+://[^\\s]*QQ号：[1-9][0-9]{4,9}邮政编码：[1-9]\\d{5}身份证：[1-9]\\d{14}|[1-9]\\d{17}|[1-9]\\d{16}x 7、正则与面向对象把方法包在一个空间里有人管他叫——命名空间在公司里，把同一类方法，包在一起JSON的使用把之前的方法，包在一起 参考链接MDN RegExp","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"RegExp","slug":"RegExp","permalink":"https://lxchuan12.github.io/tags/RegExp/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"gitflow工作流","slug":"20160920-gitflow workflow","date":"2016-09-20T09:30:32.000Z","updated":"2016-09-27T15:06:56.002Z","comments":true,"path":"2016/09/20/20160920-gitflow workflow/","link":"","permalink":"https://lxchuan12.github.io/2016/09/20/20160920-gitflow workflow/","excerpt":"记得今年6月份参加了一次coding技术小馆杭州站的活动，讲的就是git和gitflow相关的。讲师当场也写代码。那是第一次gitflow工作流。那时在想我什么时候也能在舞台上讲开发技术……","text":"记得今年6月份参加了一次coding技术小馆杭州站的活动，讲的就是git和gitflow相关的。讲师当场也写代码。那是第一次gitflow工作流。那时在想我什么时候也能在舞台上讲开发技术……今天就碰到一个关于gitflow工作流的问题。使用sourceTree软件时，建立工作流。一般来说，是切换到master上。再建立工作流。我不小心，直接在develop分支上建了工作流。切换到master分支上。再打hotfix(修复补丁)时，发现无法成功。 谷歌搜索发现解决方案： 1、找到项目当前文件夹中的.git/config，把配置文件中的gitflow*相关的全部删除。2、关闭再重新打开SourceTree。3、重新在master上建立工作流，再打hotfix。发现成功了。 参考链接：Git 工作流程Git Flow 在团队中的最佳实践 – SourceTree的使用Smart branching with SourceTree and Git-flow","categories":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/categories/git/"}]},{"title":"camelCase()转驼峰方法实现","slug":"20160915-camelCase","date":"2016-09-15T09:30:32.000Z","updated":"2017-06-04T11:42:10.400Z","comments":true,"path":"2016/09/15/20160915-camelCase/","link":"","permalink":"https://lxchuan12.github.io/2016/09/15/20160915-camelCase/","excerpt":"今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……","text":"今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……12345678910111213141516171819202122232425// 字符串操作方式function camelCase_1(str)&#123; var i=1, arr = str.split(&apos;-&apos;), len = str.split(&apos;-&apos;).length; var result = arr[0]; for(;i&lt;len;i++)&#123; result += arr[i].substring(0,1).toUpperCase()+arr[i].substring(1); &#125; return result;&#125;function camelCase_2(str)&#123; var arr = str.split(&apos;-&apos;); for (var i=1;i&lt;arr.length;i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substring(1); &#125; return arr.join(&apos;&apos;);&#125;// 正则方式// 分组概念 $0 代表整体，$1 第一个匹配子项function camelCase_3(str)&#123; return str.replace(/-(\\w)/g,function($0,$1)&#123; return $1.toUpperCase(); &#125;);&#125; 再看下jquery实现方案：123456//str.replace(/^-ms-/,&apos;ms-&apos;)是有IE下有，-ms-前缀的，比如转换成msTransform，而其他转换成首字母大写，如：WebkitTransformfunction camelCase_2(str)&#123; return str.replace(/^-ms-/,&apos;ms-&apos;).replace(/-([\\da-z])/gi,function(all,letter)&#123; return letter.toUpperCase(); &#125;);&#125; 再看zeptojs实现方案：12345//zepto.js实现方式：没处理-ms-，兼容性IE10+，但依旧有很多IE10依旧要加-ms-前缀的css3属性。为啥zeptojs没实现呢，难道还没碰到这个bug？//并且，空字符串写toUpperCase()依旧是空字符串。所以不需要写三目运算。function camelCase_3(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : &apos;&apos; &#125;)&#125; 测试：123456789101112var webkitstr = &apos;-webkit-transfrom&apos;;var msstr = &apos;-ms-transfrom&apos;;console.log(camelCase_1(webkitstr));//WebkitTransfromconsole.log(camelCase_1(msstr)); //MsTransfromconsole.log(camelCase_2(webkitstr));//WebkitTransfromconsole.log(camelCase_2(msstr)); //MsTransfromconsole.log(camelCase_3(webkitstr));//WebkitTransfromconsole.log(camelCase_3(msstr)); //MsTransfromconsole.log(camelCase_4(webkitstr)); //WebkitTransfromconsole.log(camelCase_4(msstr)); //msTransfromconsole.log(camelCase_5(webkitstr));//WebkitTransfromconsole.log(camelCase_5(msstr)); //MsTransfrom 看到这里，其实很想给zepto提pull request的。但还是没有提。 小结：分析jquery/zeptojs源码，发现能学到很多。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"jquery","slug":"jquery","permalink":"https://lxchuan12.github.io/tags/jquery/"},{"name":"zepto","slug":"zepto","permalink":"https://lxchuan12.github.io/tags/zepto/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"window.location-浏览器定位和导航","slug":"20160912-window.location","date":"2016-09-12T14:55:32.000Z","updated":"2017-06-19T14:16:43.207Z","comments":true,"path":"2016/09/12/20160912-window.location/","link":"","permalink":"https://lxchuan12.github.io/2016/09/12/20160912-window.location/","excerpt":"平时用window.location.href比较多。但却经常会忽略window.location下的其他属性……","text":"平时用window.location.href比较多。但却经常会忽略window.location下的其他属性……并且很多时候需要对链接问号后面字符串做处理，一般使用split()分割，再取。而实际上，有window.location.search可以获取。一图胜千言![图解url] url: 统一资源定位符 (Uniform Resource Locator, URL)href: 当前页面的urlprotocol: 协议hostname: 主机名port: 端口号host: 主机名+端口号pathname: 当前页面的路径和文件名origin:协议+主机名加端口号（新API）MDN location ![图解location]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://lxchuan12.github.io/tags/BOM/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"jQuery的几种写法探析","slug":"20160911-Several-writing-of-jquery","date":"2016-09-11T13:41:23.000Z","updated":"2016-09-11T13:55:03.058Z","comments":true,"path":"2016/09/11/20160911-Several-writing-of-jquery/","link":"","permalink":"https://lxchuan12.github.io/2016/09/11/20160911-Several-writing-of-jquery/","excerpt":"写法一：123$(function()&#123; //code here&#125;);","text":"写法一：123$(function()&#123; //code here&#125;); 写法二：123$(document).ready(function()&#123; //code here&#125;); 写法三：123$().ready(function()&#123; //code here&#125;) 默认参数就是document，所以可以省略不写。写法四：123(function($)&#123; //code here&#125;)(jQuery); 这种写法的最大好处是形成闭包。在内部定义的函数和变量只能在此范围内有效。形成是否函数函数、私有变量的概念。不会与其他类库，框架产生冲突。以上四种方法都是同一个意思，一般来说使用写法一比较多。此外，1234567$(window).load = function()&#123;&#125;//等价于：window.onload = function()&#123; //code here&#125; (JS中的事件，不加on，比如单击事件：click,双击事件：dblclick) window.onload = function(){}与$(funtion(){})两者的区别是：$(funtion(){})：1、在DOM加载完成后就可以可以对DOM进行操作。一般情况一个页面响应加载的顺序是：域名解析-加载html-加载js和css-加载图片和视频等其他信息。那么Dom Ready应该在“加载js和css”和“加载图片等其他信息”之间，就可以操作Dom了。2、能多次使用，按序执行。window.onload = function(){}：1、在网页中所有元素(包括元素的所有关联文件)完全加载到浏览器后才执行，即JavaScript 此时可以访问网页中的所有元素。2、不能多次使用，后者会覆盖前者。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/tags/jQuery/"}],"keywords":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/categories/jQuery/"}]},{"title":"CSS3 媒体查询media","slug":"20160909-CSS3-@media","date":"2016-09-09T12:50:42.000Z","updated":"2018-11-23T12:23:13.344Z","comments":true,"path":"2016/09/09/20160909-CSS3-@media/","link":"","permalink":"https://lxchuan12.github.io/2016/09/09/20160909-CSS3-@media/","excerpt":"CSS3 媒体查询media，其实CSS2也有media，只是基本不用……","text":"CSS3 媒体查询media，其实CSS2也有media，只是基本不用……1234567891011@media only screen and (max-width:375px)&#123; .box&#123; background:#f00!important; /*加上！important才有效。*/ &#125;&#125;.box&#123; width:100px; height:100px; background:#000;&#125; 媒体查询@media需要配合meta标签使用才有效。简版：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 完整版：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt; 其中minimal-ui表示参考链接：iOS 7.1的Safari为meta标签新增minimal-ui属性，在网页加载时隐藏地址栏与导航栏iOS 8 removed “minimal-ui” viewport property, are there other “soft fullscreen” solutions?取值：123456789@media screen and (max-width:320px)&#123; /*视窗宽度&lt;=320px*/&#125;@media screen and (min-width:769px)&#123; /*视窗宽度&gt;=769px*/&#125;@media screen and (min-width:769px) and (max-width:1000px)&#123; /*769px&lt;=视窗宽度&lt;=1000px*/&#125; 几道判断题：1、媒体查询条件中，（max-width:320px）表示的是：A. 当视窗宽度小于等于320px时。2、要做响应式网站，就必须设置viewportA. √3、device-width是viewport的默认宽度B、×4、viewport的默认宽度就是屏幕的水平分辨率B、×","categories":[{"name":"CSS3","slug":"CSS3","permalink":"https://lxchuan12.github.io/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://lxchuan12.github.io/tags/CSS3/"},{"name":"media","slug":"media","permalink":"https://lxchuan12.github.io/tags/media/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"https://lxchuan12.github.io/categories/CSS3/"}]},{"title":"我是如何踏上前端这条路的","slug":"20160907-How-do-I-set-foot-on-the-front-end-of-the-road","date":"2016-09-07T13:48:12.000Z","updated":"2018-11-16T12:52:19.526Z","comments":true,"path":"2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/","link":"","permalink":"https://lxchuan12.github.io/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/","excerpt":"感觉最近我是如何XXX的这类标题挺火的。杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。","text":"感觉最近我是如何XXX的这类标题挺火的。杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。1、刚好可以对现在大四迷茫的学弟学妹们，有些指引。2、还可以借此回忆下大学生活。3、锻炼自己写长文的逻辑能力。当然，学习是座大山，人们沿着不同的路登山，分享着自己看到的风景，别人不一定看得到你看到的风景，体会得了你的心情。 接触前端2012年，那年大一，只记得上学期参加了四个社团，参加社团的各种活动，比较忙，另外自己收集一些电子书放到我那一点都不智能的手机上看。下学期，我所在的社团计算机协会（后文简称计协），当时教网页制作（嗯，那时不叫前端开发），当然我报名去参加了。比我们大一级的学长用着Dreamweaver软件 给我们教学，超链接，图片，音乐，视频，FLASH等。总之感觉很有趣。也要我们做出一些作品，交作业。但那时我并没有电脑。所以就没做。 江西省网页制作与设计技能大赛大二任职计协会长，举办各类活动。也没怎么学习前端开发之类的知识。学习方面好像也就是平时上上课而已，再就是学习电脑方面的技巧，帮助别人解决电脑问题，为此也写了挺多这类技术文章。比如：【教程】Ｕ盘、硬盘安装原版win7、8.1、10系统,近期上网拨号客户端出现拨号异常、711错误解决方案。在大学，懂点电脑，会装几个软件，重装个系统，在别人眼中就会被看做是大神，并且很受欢迎。后来实在忙，就写了篇文章：对不起，我不能帮你修电脑了转眼间，就到了2014年4月（大二下学期），我所在的信息学院，组织参加省级网页大赛，同时派老师给予培训指导。这时，老师N每周四（或五）给我们上了几周课，主要讲HTML和CSS，还给我们他录制的视频，当时觉得老师好厉害。后来让我们出作品，我们就找设计（陶美）学院的学生给我们设计网页视觉稿。虽然她们学的是设计，但也不是很懂网页设计这块。于是我就自己参照一个视觉比较好的网站，自己仿照着写了一个。当时还是比较忙，只有晚上有时间，所以总共八个页面，好像写了将近10天。主要用了HTML，CSS，js，jquery。现在放在github上，点击可以访问，时尚影楼,那时并不是很懂js和jquery。后来比赛结果出来了，竟然是省级一等奖。其实一等奖有挺多的。这次网页赛，我们学校获得了很多奖项。大二末，图书馆一老师找到我们，想让我们暑假回去学点PHP，开学好让我们上手，帮他做项目。我们信息学院邀请了10级计科的H学长，给我们这些迷茫的学弟学妹开了一次经验分享会，说到腾讯招人的标准。因为他就是课题组研发部的一员。说到课题组研发部的各种好处，跟着里面的老师L学习PHP，学到60％就够找好工作了。总之意思就是要进课题组学习。大二暑假，家里没网，我就在学校，下载好各种PHP学习资源，暑假就在家看着PHP相关的视频等，一套PHP视频也是100多集，基本看完了，也写了些代码。当时也学了javascript，一套JS视频100多集没有看完。其实到后来基本都忘了。另外，大二暑假，线上面试了乔布简历，通过成为了乔布简历校园大使。 加入课题组研发部大三上学期，卸任了计协会长，本以为这是大学最后一个职务，谁知这只是第一个。同学A，同学B跟着图书馆老师做PHP的项目。而我此时看着没啥事，就玩起了PPT，新媒体运营，又相继任职了校园网络中心团队的队长（关于这个我也写了篇文章谈一谈校园网管这一工作，一直任职到大四上学期）。校友总会志愿团常务团长（后来由于组织性质缘故，2014年11月，不到两个月就默认退出了），乔布简历江西省副主管，那时班上竞选班干，班主任说我们计协会长卸任了怎么不竞选一个职务。我说不用了，我并没有说还有这么多职务。上学期刚开始不久，我们专业老师也邀请了11级的学长学姐分享他们的一些经验。后来我们成立了信管学习小组，规定时间来主教自习。主要是为了学习网站开发。但后来效果不佳，我也较忙，就散了。PPT水平在涨进，主要体现在我做的优秀班集体评选PPT上，传说就是凭借这次展示，让学校领导记住了做PPT还有这么好的人，后来（2015年5月13日）就被找去做更名大学工作汇报PPT，再后来就有了这张图 PPT制作主要经历:，也写了一些关于PPT制作的文章，比如：要做PPT，一直找不到资源？。开发水平并没有多少涨进。大三下学期，我和同学A，B一起加入了课题组学习，做任务。5月19日，成立了移动互联协会，又任职移动互联协会首届会长，一直任职到大四上学期。成立这社团，主要目的就是为了培养开发，后来给学弟学妹们培训HTML，CSS,和PPT，PS等，感觉他们真幸福。现在回想起来，在课题组，老师好像真的没给我什么实质性的开发任务。好像就让我做些与开发不那么相关的事情。可能是我个人原因。4月，九家培训机构到我们信息学院做宣讲，他们的目的很明显，就是招人去培训。下午跟千锋教育的老师聊了挺久，主要是了解了他们机构是如何授课等。当然，他们极力希望我能去他们的好程序员班，但我肯定不会考虑培训。当时听完，晚上总结了一张图![从校园宣讲会我学到了什么]。 到学期末（6月），让我和同学A一起做设计学院网站（给了设计稿），用迅时CMS搭建网站后台（Asp.net）。主要是我做。那时相当于隔了一年多，要重新捡起HTML，CSS，JS。连引入的jquery和自己写的JS顺序都能弄反，连Jquery的选项卡都写不来。熬了几次夜，在同学A和老师的指导下。终于完成了。这时，我开始感受到，就业压力，我究竟要往哪条路走。是新媒体运营（PPT），或者是PHP开发，还是前端开发？如果走新媒体运营（PPT），那么要开个微信公众号，写PPT相关文章，PPT演界网卖模板，等等。 真正意义上开始学前端开发大三暑假，课题组业务需求，我和同学A，B，都留在课题组做任务学习。前期我还在学PHP，后来室友L，在杭州暑假实习，他说前端也比较火。刚好又在网易云课堂，看到网易推出前端微专业第二期。价格一千多。虽然对于在更名大学办公室做PPT和做网络中心团队队长赚了少许钱的我来说，不是很贵，但上学期报名了驾照（3K+），所以就买不起了。但那时我就确定了方向，前端开发，因为入门相对容易，并且所见即所得，喜欢视觉交互，和之前玩PPT是同样注重视觉交互和逻辑。另外在PHP方面根本没做什么项目。要走前端，原生JavaScript必学！于是在知乎上看到说智能社的JS视频《精通JavaScript开发》，这套课程不错。那时就没多想，先看完这套课程再学其他的。很多时候，你想学的太多，都在同时学，往往效果不好，而是先学什么再学什么。记得那时，晚上9点断网，他们在打牌，我回去后在看下载好的视频。学完这条课程后，感觉有些提升，至少熟练了下写代码。学完这套后，就在慕课网学习其他前端相关知识。8月，课题组组建了一支团队，参加互联网+大赛，当时学校比较重视这次比赛，召集参赛者在学校机房培训，解决吃住问题（在教工食堂吃了10多天），我一不小心又成了临时班长，协助就业处的老师处理相关事务。我还负责团队赛项目计划书的撰写和PPT制作。后来我们团队（指尖上的陶艺项目）依次进入校赛，省赛，国赛，最后10月份到吉林大学（吉林长春）参赛国赛，获得国赛金奖（前30）和最佳创意奖，载誉归来之时，学校领导在校门口接我们，学校党委书记说奖励我们团队10万元。刚开始以为不会分到没多少钱。后来就有钱买课程了。双十一期间，就买了网易云课堂的前端开发微专业第三期，系统的学习前端开发。另外还买了妙味课堂的视频课程学习。有人说，你要学知识，把市面上这类书都买下来，看懂并消化。那你肯定就有提升了。11月，老师N让我做学工处的网站，同样是Asp.net的后台。这次就没做多久，也没做设计学院网站那么痛苦。12月，开始做毕业设计，是用php+mySql做第二课堂管理系统。1月5日，提前答辩通过。 大四寒假开发水平那么差的我，当然是不忘抓住这段时间，提升自己的。看妙味课堂的视频。学着前端微专业，看课程，查资料，讨论区讨论，做作业，改作业。提交作业有截止日期。感觉这段时间挺充实的。也在考虑大四下学期是否去学校，校内实习，还是去公司实习。老师L是推荐我去公司实习，能学挺多。虽然11月份参加了学校的招聘会，有公司问我用过Bootstrap吗，我说没有。后来有几家公司，叫我去实习，我没去。主要是以下考虑：1、公司前端团队好，实习则好。不好，不如自学。2、自己不足还有很多，希望能继续学完前端开发微专业，获得优秀学员，也许能进好一点的公司。3、毕竟不考研，以后有的是工作时间，还不如继续享受下最后一学期的校园生活。 大四最后一个学期开学伊始，我和同学A，B都没去公司实习，重新来到了课题组。刚去不久，老师N就推荐我去南昌，算是实习，说有搞PHP的愿意带一个人一起做项目。后来委婉的拒绝了。因为已经不想走PHP开发路线，想走前端开发路线。但本学期，老师交给我的任务依旧是PHP开发的。第二课堂管理系统（PHP+MySql，CI框架）。因为不是很赶，我就前端微专业，百度前端技术学院任务，（妙味课堂的vip视频）三线并行。4月初，完成了前端微专业大作业，获得优秀学员证书。在学校，上班是996（早上9点上班，晚上9点下班，中午休息1-2小时）。周日老师不在办公室，而我一般在（同学A，B不在）。因为我太Low了，所以只好多花点时间学习。有段时间，都是24点前提交完代码，才去刷牙洗脸睡觉。晚上躺着睡前还在牛客网刷题，或者看视频，或者看前端开发类电子书。 面试，入职杭州一家移动互联网公司4月底投简历，5月劳动节一过，我和同学A就来杭州面试。我求职还算顺利，面试了3天，共9家。有的给了offer，就选了一家我认为比较合适的。6月1日入职杭州一家阿里高管出来创业的移动互联网公司，公司和阿里一样使用花名，我自己挑选了一个，叫轩辕。于是把网上各种昵称，改成了轩辕Rowboat。 轩辕Rowboat由来：轩辕(公司花名)。Rowboat，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），剑未佩妥，出门便是江湖。 公司使用的技术主要有：HTML5，模板语言（velocity，thymeleaf,handlebarsjs，underscorejs，lodash工具库等），CSS3，Less，Sass，JS，JQuery，zeptojs，bootstrap，angularjs，vuejs，git，gulp，webpack，ES6等（React，nodejs暂时没用到）。不知不觉就写了挺多字，感觉一路走来，在网易云课堂购买了付费课程（office，前端微专业等）两千左右（已赚回），当没有时间，有钱时，可以选择付费学习，投资学习，回报很大。技术提升需要一定的过程，脚踏实地走好每一步，先定好一个个小目标，然后去一一实现。看过很多前端大神成长路线，也是从刚开始啥都不会，一步一步变成前端大神的。","categories":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}],"tags":[{"name":"self-growth","slug":"self-growth","permalink":"https://lxchuan12.github.io/tags/self-growth/"},{"name":"前端","slug":"前端","permalink":"https://lxchuan12.github.io/tags/前端/"}],"keywords":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}]},{"title":"由JavaScript一道面向对象题引发的思考","slug":"20160830-js-oop-prototype-constructor","date":"2016-08-30T15:09:00.000Z","updated":"2018-11-23T12:21:23.177Z","comments":true,"path":"2016/08/30/20160830-js-oop-prototype-constructor/","link":"","permalink":"https://lxchuan12.github.io/2016/08/30/20160830-js-oop-prototype-constructor/","excerpt":"一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了","text":"一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了123456789101112131415161718function Person()&#123; this.name = &quot;lxchuan12&quot;;&#125;var rowboat = new Person();Person.prototype.age=20;Person.prototype=&#123;a:1,b:2&#125;;//Person.prototype.constructor = Person;console.log(rowboat.name);//&quot;lxchuan12&quot;console.log(rowboat.age);//20console.log(rowboat.a);//undefinedconsole.log(rowboat.b);//undefinedconsole.log(rowboat);console.log(Person.prototype.name);//undefinedconsole.log(Person.prototype.age);//undefinedconsole.log(Person.prototype.a);//1console.log(Person.prototype.b);//2console.log(Person.prototype.constructor);//function Object() &#123; [native code] &#125;console.log(Person.prototype);//Object &#123;a: 1, b: 2&#125; 问题：他不明白，为什么rowboat.age为20。但Person.prototype.age却为undefined。 解答：我把代码在jsbin运行后，为之解答。Person.prototype={a:1,b:2};这种写法是赋值，与Person.prototype.age=20;写法不同，不经意间把constructor指向原本为Person的，改为了Object（一般来说，需要修正指向。Person.prototype.constructor = Person）。 控制台输出对象 相当于prototype下只有a,b两个值了。所以Person.prototype.age则是undefined。但rowboat.age是原型上的，可以找到，所以是20。所谓原型查找：查找的是构造器查找的原型，构造器是指向一个function(){},里面没有a和b. 参考资料：《JavaScript高级程序设计》——对象学习笔记 小结：学习js面对对象编程相关知识,对了解js语言很有帮助。另外，有人说，能写组件，做组件开发说明达到了中级水平。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"oop","slug":"oop","permalink":"https://lxchuan12.github.io/tags/oop/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"sass基本特性-运算","slug":"20160829-Sass-basic-characteristics-of-computing","date":"2016-08-29T13:26:28.000Z","updated":"2018-11-23T12:23:03.633Z","comments":true,"path":"2016/08/29/20160829-Sass-basic-characteristics-of-computing/","link":"","permalink":"https://lxchuan12.github.io/2016/08/29/20160829-Sass-basic-characteristics-of-computing/","excerpt":"CSS中目前只有calc()能做运算，但是在Sass中，可以做各种数学运算……","text":"CSS中目前只有calc()能做运算，但是在Sass中，可以做各种数学运算…… 1、加法123.box&#123; width: 20px + 8in;&#125; 编译出来的CSS:123.box &#123; width: 788px;&#125; 1in = 96px; 当em,rem等相对当前字体，于px在一起不能运算，会报错，如:123.box&#123; width: 20px + 8em;&#125; 不过如果其中一个不同单位，那么会以另一个带单位的为准，如：1234567.box&#123; width: 20px + 8;&#125;.box2&#123; width: 20em + 8;&#125; 编译出来的CSS为:1234567.box &#123; width: 28px;&#125;.box2 &#123; width: 28em;&#125; 2、减法12345678$container: 960px;$sidebar-width: 220px;$gap-width: 20px;.content&#123; width: $container - $sidebar-width - $gap-width; float: left;&#125; 编译出来的CSS：123456.content &#123; width: 720px; float: left; &#125; 减法和加法一样，不支持em,rem等相对当前字体大小的单位与px进行计算。 3、乘法 乘法运算时，只需要其中一个带单位即可，如果都带有单位会报错,如:123.box&#123; width: 20px * 20px&#125; 编译时会报错。 而:123.box&#123; width: 20px * 20;&#125; 编译出来的CSS：123.box&#123; width: 400px;&#125; 与加减法一样，不同类型的单位运算时会报错。 4、除法 Sass的乘法运算规则也适用于除法运算，不过除法运算有特殊之处，因为”/”符号在CSS中已经作为一种符号使用，因此在Sass中直接使用”/”作为处好时，将不会生效，编译时既不会报错，也不会得到我们想要的效果。 如:123.box&#123; width: 100px / 2;&#125; 编译出来的CSS:123.box &#123; width: 100px / 2;&#125; 要修正这个文字，只需要给运算的外面添加一对小括号即可。123.box&#123; width: (100px / 2);&#125; 编译出来的CSS为:123.box &#123; width: 50px;&#125; 除了小括号以外，如果除了 “/” 外，还有其它的运算符号，那么也会被当作除号看待。123.box &#123; width: 100px / 2 + 20px; &#125; 编译出来的CSS为：123.box &#123; width: 70px;&#125; 另外，如果是用变量进行除法运算，”/”也会自动被识别为除法。 如:12345$width: 960px;.col &#123; width: $width / 10;&#125; 编译出来的CSS为:1234.col &#123; width: 96px; &#125; 综合上述，”/ ”符号被当作除法运算符时有以下几种情况： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。如果数值被圆括号包围。如果数值是另一个数学表达式的一部分。在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值。 关于单位计算的问题，同物理倒是非常像。 如果不想记”/”的规则，那么在想作为除法使用是，加上一个括号即可。 5、颜色运算 所有的运算都支持颜色值。如:123p &#123; color: #010203 + #040506;&#125; 编译出的CSS为:123p &#123; color: #050709;&#125; 同样颜色值也支持乘法运算:123p &#123; color: #010203 * 2;&#125; 编译出来的CSS:123p &#123; color: #020406;&#125; 运算规则和二进制乘法相同，依次与每一位相乘。个人觉得颜色值的运算意义不是很大。 6、字符运算 在Sass中可以用”+”号对字符串进行拼接，如:123456789$content: &quot;Hello&quot; + &quot; &quot; + &quot;Sass!&quot;;.box&#123; &amp;:after&#123; content: $content; &#125; &amp;:before&#123; content: &quot; #&#123;$content&#125; &quot;; &#125;&#125; 编译出来的CSS为:123456.box:after &#123; content: &quot;Hello Sass!&quot;; &#125;.box:before &#123; content: &quot; Hello Sass! &quot;; &#125; 除了在变量中做字符连接运算之外，还可以直接通过 +，把字符连接在一起：1234567div&#123; cursor: e + -resize;&#125;span&#123; cursor: &quot;e&quot; + &quot;-resize&quot;;&#125; 编译出来的CSS为:1234567div &#123; cursor: e-resize;&#125;span &#123; cursor: &quot;e-resize&quot;; &#125; ==注意==:如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 也就是说始终与加号左边的保持一致:1234p:before &#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125; 编译出来的CSS为:1234p:before &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 根据慕课网sass入门篇整理","categories":[{"name":"SASS","slug":"SASS","permalink":"https://lxchuan12.github.io/categories/SASS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://lxchuan12.github.io/tags/SASS/"}],"keywords":[{"name":"SASS","slug":"SASS","permalink":"https://lxchuan12.github.io/categories/SASS/"}]},{"title":"js如何判断对象为空","slug":"20160827-Judge-null-object-by-javascript","date":"2016-08-27T14:46:23.000Z","updated":"2018-11-23T12:25:53.469Z","comments":true,"path":"2016/08/27/20160827-Judge-null-object-by-javascript/","link":"","permalink":"https://lxchuan12.github.io/2016/08/27/20160827-Judge-null-object-by-javascript/","excerpt":"vuejs项目中，遇到要判断data中的对象是否为空……","text":"vuejs项目中，遇到要判断data中的对象是否为空……12345678910111213141516171819202122var vm = new Vue(&#123; el:&apos;#demo&apos;, data:&#123; msg:&apos;hello&apos;, ms:&#123;&#125; &#125;, created ()&#123; let that = this; console.log(that.ms); console.log(that.msg); console.log(that.ms === null);//false if(that.ms)&#123;//true console.log(1);//1, &#125;; console.log(that.ms === undefined);//false for(var attr in that.ms)&#123; console.log(attr); console.log(&apos;2&apos;); &#125; //console.log(&apos;3&apos;); &#125;&#125;); 点击查看详情vuejs jquery有工具方法$.isEmptyObject(),查看源码发现这样实现的。1234567isEmptyObject:function(obj)&#123; var name; for(name in obj)&#123; return false; &#125; return true;&#125; 这是利用了for in无法循环到系统自带的属性值。123456789//比如：function Watch()&#123;&#125;//Watch.prototype.constructor = Watch;//系统自己生成。写出来这句也无法用for in循环到。for (var attr in Watch.prototype)&#123; console.log(&apos;can not console&apos;);//无法输出。&#125;//如果自己写,则可以输出show.Watch.prototype.show = function()&#123;&#125; 这时想起了js中数组遍历for与for in区别(强烈建议不要使用for in遍历数组)$.isPlainObject()方法：判断”纯粹的对象”，就是该对象是通过”{}”或”new Object”创建的。$.isPlainObject( document.location ) ); // false(在IE中返回true) 参考资料：汤姆大叔博客 小结:js一切皆为对象，了解面对对象编程很有好处。能研究一遍jquery源码,定能更上一层楼。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"iPhone safari可以通过访问链接来打开微信","slug":"20160820-safari-open-wechat","date":"2016-08-20T15:35:26.000Z","updated":"2016-08-22T15:33:42.580Z","comments":true,"path":"2016/08/20/20160820-safari-open-wechat/","link":"","permalink":"https://lxchuan12.github.io/2016/08/20/20160820-safari-open-wechat/","excerpt":"今天发现：iPhone safari可以可以通过访问链接来打开微信。而安卓手机不行。不多说，直接show the code……","text":"今天发现：iPhone safari可以可以通过访问链接来打开微信。而安卓手机不行。不多说，直接show the code…… 1234let ua = window.navigator.userAgent.toLowerCase();if ((ua.indexOf(&apos;iphone&apos;)&gt;-1)&amp;&amp;(ua.indexOf(&apos;safari&apos;)&gt;-1))&#123; window.location.href = &apos;weixin:http://weixin.qq.com&apos;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"},{"name":"wechat","slug":"wechat","permalink":"https://lxchuan12.github.io/tags/wechat/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"(转)一种代码量更少的(micro clearfix)清除浮动的hack","slug":"20160819-css-micro clearfix-hack","date":"2016-08-19T15:24:12.000Z","updated":"2018-11-23T12:26:22.400Z","comments":true,"path":"2016/08/19/20160819-css-micro clearfix-hack/","link":"","permalink":"https://lxchuan12.github.io/2016/08/19/20160819-css-micro clearfix-hack/","excerpt":"clearfix hack做为一种无需借助额外标签清除浮动的方法已经人尽皆知了，本文给出一种优化方案，可以进一步减少所需css的数量……","text":"clearfix hack做为一种无需借助额外标签清除浮动的方法已经人尽皆知了，本文给出一种优化方案，可以进一步减少所需css的数量…… Demo: Micro clearfix hack Known support: Firefox 3.5+, Safari 4+, Chrome, Opera 9+, IE 6+ micro clearfix基于 Thierry Koblentz’s “clearfix reloadedreloaded优化而来，适用于现代浏览器（modern browsers） 下面是micro clearfix的代码片段1234567891011.cf:before,.cf:after &#123; content: &quot; &quot;; display: table; &#125;.cf:after &#123; clear: both;&#125;.cf &#123; *zoom: 1;&#125; “micro clearfix”生成伪类元素，并将其display属性设置为table，这样就会创建一个匿名table-cell，同时生成了新的BFC，这样意味着:before伪类会阻止上边距折叠，:after伪类用于清除浮动，好处是不用隐藏产生的内容了，所需要的css代码就变少了。 为了清除浮动包含:before选择器是没必要的，但是:before的加入可以阻止top-margins折叠，这样有两个好处： 同其他使用BFC方式清除浮动一样，确保了视觉上的一致，例如使用overflow:hiddenIE 6/7中使用zoom:1 时，确保了视觉上的一致N.B.: 有一个细节：IE 6/7中在新的BFC中浮动元素的下边距是不会包含在内的，进一步的描述可以看这里： Better float containment in IE using CSS expressions.content:” “的使用避免了一个Opera的bug，如果contenteditable属性同时出现在元素中时，这个bug会在待清除元素周围生成空格。一种可选的修复方案是使用 font:0/0 a，多谢Sergio Cerrutti测试出这个bug 转载于：一种代码量更少的(micro clearfix)清除浮动的hack 英文版：A new micro clearfix hack，转载标明出处，谢谢！","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"},{"name":"clearfix","slug":"clearfix","permalink":"https://lxchuan12.github.io/tags/clearfix/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"vuejs生态，自顶而下学习","slug":"20160818-chat","date":"2016-08-18T15:24:12.000Z","updated":"2016-09-30T15:59:10.756Z","comments":true,"path":"2016/08/18/20160818-chat/","link":"","permalink":"https://lxchuan12.github.io/2016/08/18/20160818-chat/","excerpt":"由于我git比较活跃，有幸收到大搜车前端leader芋头（前端乱炖网站创始人，颜文字APP）的邮件，并与之交流。","text":"由于我git比较活跃，有幸收到大搜车前端leader芋头（前端乱炖网站创始人，颜文字APP）的邮件，并与之交流。小芋头君的知乎主页.大搜车前端团队博客. 大概整理： 1、自顶而下学习，看vuejs文章，熟悉其生态圈，怎么产生的，解决了什么问题。不是会写，就行。很多人看完vuejs教程都会写。 比如angularjs，双向绑定，vuejs是单向绑定，虽然也可以双向绑定。2、自我管理，自我规划，自我提升。综合能力。3、追新，有些人工作了几年就不学新东西，这样没提升。4、前端工程化，（打包工具只是其中一小部分）。5、目前重要的不是学ES6，而是把基础夯实。 这让我想起：知乎上一个提问大学毕业做前端工作感觉最近遇到了瓶颈，不知道该如何提升自己？ 作者：林獺链接：https://www.zhihu.com/question/49164656/answer/114625869来源：知乎著作权归作者所有，转载请联系作者获得授权。 首先，正视自己的能力。前端的新技术，不是门坎较低、就是给人一种容易掌握的错觉。Less/Sass 不谈，你学了 Angular，懂得 data-binding、router 等背后的实现原理吗？你虽会用 Node 搭建一个本地 server，但懂得 I/O 流程、HTTP 和操作系统知识吗？你能不诉诸书本和搜索引擎，写出几个 JS 设计模式和继承模式吗？你能完全脱离 jQuery 来操纵 DOM 和 Ajax 吗？你知道怎么写 CSS 选择器能让浏览器解释速度最快吗？你会在开发过程中，下意识地追求 HTTP 请求最少吗？……如果你不能的话，那就需要重新审视自己，是否被一时的自我成就和满足所障目，而忘却了技术最重要的永远是基础。如果你能的话，恭喜你，你已经不止是合格的前端了。这样的话，你要怎么做才能走出平阳、找到归宿呢？我的建议是积累经验——积累工作和项目的经验，闲时继续学习并深入新技术。你的工作效率高、闲时多，这是好事。我毕业后第一份工作也是如此，领导缺乏技术嗅觉，技术路线过时老旧。我是这么应对的：凭越发娴熟的技能，加快工作速度，换来学习的时间。接着，主动把你的新技能移植到公司项目中。例如 Gulp、Less/Sass，都是开发环境下的利器，开发环境下你想怎么用就怎么用，外人只看到生产代码；甚或 Angular——遇到独力负责的中重量级项目，主动考虑此类 MVC 框架的可行性；有时不是项目和领导不允许使用新框架，而是自己不愿走出舒适圈、缺乏实践自信。（业余时间，用你的 Gulp、Angular 写一些个人项目放在 GitHub 上，配以 Node mock server 甚至 Redis 数据库，有助理解前后端交互和数据库的组织，也增加面试的资本。）当你「利用」这个公司，积累了新老技术的实践经验后，便是另谋高就的时机了。你的简历不仅会有上述技能，还会有「一力为旧公司引入任务构建、工作流等新技术」之类的 impressing 字眼。在投简历时，开始考虑实质回报以外更深层的东西。你可以询问对方，贵团队的前端技术栈为何，未来的技术规划为何。因为接下来的新工作，在你的职场生涯中，是最能影响你的技术修炼的——你将第一次名正言顺地学习技术、并将其付诸实践、甚至有同样技术路线的同事大牛带领。对比上一家，事半功倍。 小结：坚持学习，自我提升；重视基础！努力争取能进好团队，学习更快。","categories":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}],"tags":[{"name":"self-growth","slug":"self-growth","permalink":"https://lxchuan12.github.io/tags/self-growth/"}],"keywords":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}]},{"title":"弹窗（modal）垂直水平居中","slug":"20160817-modal-center","date":"2016-08-17T15:07:15.000Z","updated":"2018-11-23T12:22:48.014Z","comments":true,"path":"2016/08/17/20160817-modal-center/","link":"","permalink":"https://lxchuan12.github.io/2016/08/17/20160817-modal-center/","excerpt":"今天发现{margin:0 auto}竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了……","text":"今天发现{margin:0 auto}竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了…… 弹窗垂直水平居中：方法1：12345678910.modal&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; margin-left:-125px; margin-top:-50px;&#125; 小结:fixed，支持到IE7，IE6不支持。modal定宽定高。 方法2：12345678910.modal&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125; 小结:不支持IE9+，modal不需定宽定高，手机端可用。（发现如果有其他的transform，好像先执行其他的，在移动到中心。）另外，发现{margin:0 auto}:12345678910.modal&#123; position:fixed; width:250px; left:0; right:0; top:40%; bottom:auto; margin:0 auto; background:#ececec;&#125; 竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"js手机号码正则表达式","slug":"20160816-reg-phone-num","date":"2016-08-16T15:06:16.000Z","updated":"2018-11-23T12:26:48.978Z","comments":true,"path":"2016/08/16/20160816-reg-phone-num/","link":"","permalink":"https://lxchuan12.github.io/2016/08/16/20160816-reg-phone-num/","excerpt":"前端做了手机号的限制，但有的号码通过了前端验证，但依旧数据无法保存成功，但又没错误提示。与后台联调发现，原来是后端也做了限制，还不一样……","text":"前端做了手机号的限制，但有的号码通过了前端验证，但依旧数据无法保存成功，但又没错误提示。与后台联调发现，原来是后端也做了限制，还不一样……1.前端验证var reg = /^1\\d{10}$/; 2.后端验证var reg = /^1[3|4|5|7|8][0-9]{9}$/; //验证规则不知其合理性，普适性，于是搜索了下。 3.最后采用： var reg = /^1\\d{10}$/; //验证规则var phoneNum = ‘18296821923’;//手机号码var flag = reg.test(phoneNum); //true 4.参考资料：JS最新手机号码检验正则表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"https://lxchuan12.github.io/tags/RegExp/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"new Date()的浏览器兼容性问题","slug":"20160813-tip-js-new-date","date":"2016-08-13T14:03:29.000Z","updated":"2018-11-23T12:27:00.585Z","comments":true,"path":"2016/08/13/20160813-tip-js-new-date/","link":"","permalink":"https://lxchuan12.github.io/2016/08/13/20160813-tip-js-new-date/","excerpt":"兼容性问题var date = new Date(‘2016-08-13 13:25:50’).getTime();这种chrome下没问题，但ie和firefox下是NaN,在Safari下也有问题……","text":"兼容性问题var date = new Date(‘2016-08-13 13:25:50’).getTime();这种chrome下没问题，但ie和firefox下是NaN,在Safari下也有问题…… var date = new Date(‘2016-08-13 13:25:50’).getTime(); 这么写的时候所有浏览器都没有问题。 所以遇到兼容的时候：这样就可以将上面那种格式yyyy-MM-dd改为yyyy/MM/dd 再去转换 var date = new Date((‘2016-08-13 13:25:50’).replace(new RegExp(“-“,”g”),”/“)).getTime() 另外：+new Date()=== new Date().getTime();true.123456789101112&lt;div id=&quot;d&quot;&gt;&lt;/div&gt;&lt;div id=&quot;getTime&quot;&gt;&lt;/div&gt;&lt;div id=&quot;type&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var d1 = document.getElementById(&apos;d&apos;); var getTime1 = document.getElementById(&apos;getTime&apos;); var type1 = document.getElementById(&apos;type&apos;); var date = new Date(&apos;2016-08-13 13:25:50&apos;); d.innerHTML = date.toString(); d.innerHTML = date.getTime(); type1.innerHTML = typeof date.toString();&lt;/script&gt; 参考文章：JS原生Date类型方法的一些冷知识javascript中new Date()的浏览器兼容性问题js new Date(“2016-07-01 08:00:00”) 格式在IE内核浏览器中显示NaN的问题","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"date","slug":"date","permalink":"https://lxchuan12.github.io/tags/date/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"Vue js两次请求","slug":"20160812-vue-route request","date":"2016-08-12T14:59:16.000Z","updated":"2018-11-23T12:27:46.310Z","comments":true,"path":"2016/08/12/20160812-vue-route request/","link":"","permalink":"https://lxchuan12.github.io/2016/08/12/20160812-vue-route request/","excerpt":"当使用vue-resource发送注册的POST请求时，Fiddler捕获到了2次请求，第1次是由浏览器发送的OPTIONS预请求，第2次才是实际的POST请求……","text":"当使用vue-resource发送注册的POST请求时，Fiddler捕获到了2次请求，第1次是由浏览器发送的OPTIONS预请求，第2次才是实际的POST请求……这和使用$.ajax时是不一样的，因为$.ajax会将非GET请求的Content-Type设置为application/x-www-form-urlencoded，而vue-resource发送POST请求的Content-Type为application/json;charset=UTF-8。 1.全局启用：1Vue.http.options.emulateJSON = true 2.局部启用启用了emulateJSON选项后，使得POST请求的Content-Type变为application/x-www-form-urlencoded1234this.$http.post(this.registerUrl, this.registerModel ,&#123; emulateJSON : true&#125;) .then( (response) =&gt; &#123; this.msg = ‘注册成功！‘ &#125;) 3.参考资料：参考官方文档$.ajax和vue-resource实现OAuthVue.js——vue-resource全攻略","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/tags/Vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"https://lxchuan12.github.io/categories/Vue/"}]},{"title":"chrome跨域设置","slug":"20160811-chrome-settings","date":"2016-08-11T14:55:38.000Z","updated":"2016-10-19T15:29:34.907Z","comments":true,"path":"2016/08/11/20160811-chrome-settings/","link":"","permalink":"https://lxchuan12.github.io/2016/08/11/20160811-chrome-settings/","excerpt":"今天用vuejs,与后端联调,发现用localhost或者本机ip访问本地资源，和后端接口资源，没有数据，google发现是chrome的安全机制，不允许跨域……","text":"今天用vuejs,与后端联调,发现用localhost或者本机ip访问本地资源，和后端接口资源，没有数据，google发现是chrome的安全机制，不允许跨域…… 解决方案：浏览器版本：chrome 52。1、在桌面找到chrome浏览器快捷图标并点击鼠标右键的属性一栏。(或者任务栏选中chrome右击——google chrome右击属性) 2、在属性页面中的目标输入框里加上 –args –disable-web-security.–args可省略。或者试试：–disable-web-security –user-data-dir 3、点击应用和确定后关闭属性页面，并打开chrome浏览器即可。 使用本机ip地址加端口号，访问本地资源。","categories":[{"name":"调试技巧","slug":"调试技巧","permalink":"https://lxchuan12.github.io/categories/调试技巧/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://lxchuan12.github.io/tags/chrome/"}],"keywords":[{"name":"调试技巧","slug":"调试技巧","permalink":"https://lxchuan12.github.io/categories/调试技巧/"}]},{"title":"清除IE下input的默认叉","slug":"20160810-ms-clear","date":"2016-08-10T15:00:38.000Z","updated":"2018-11-23T12:21:02.854Z","comments":true,"path":"2016/08/10/20160810-ms-clear/","link":"","permalink":"https://lxchuan12.github.io/2016/08/10/20160810-ms-clear/","excerpt":"IE10下的Input Text和谷歌下面的 input search 一旦输入内容，会在最右端出现一个叉号，点击后，内容就会自动清空，input password有小眼睛，点击显示密码。看似方便，其实有些场景并不需要，需要写代码清除掉……","text":"IE10下的Input Text和谷歌下面的 input search 一旦输入内容，会在最右端出现一个叉号，点击后，内容就会自动清空，input password有小眼睛，点击显示密码。看似方便，其实有些场景并不需要，需要写代码清除掉……1234567891011121314151617181920212223242526/*--清除谷歌浏览器下的 text 叉号*/input::-webkit-text-cancel-button&#123; display: none;&#125; input[type=text]::-ms-clear&#123; display: none;&#125;/*--清除IE下的 search 叉号*//*当然如果想清除所有的input的话 ，只需把[type=search]去掉即可。*/input::-webkit-search-cancel-button&#123; display: none;&#125; input[type=search]::-ms-clear&#123; display: none;&#125;/* 小眼睛 */input[type=password]::-ms-reveal&#123; display:none;&#125; 待完善……","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"line-height学习笔记","slug":"20160808-line-height","date":"2016-08-08T15:28:23.000Z","updated":"2016-08-09T15:09:26.569Z","comments":true,"path":"2016/08/08/20160808-line-height/","link":"","permalink":"https://lxchuan12.github.io/2016/08/08/20160808-line-height/","excerpt":"line-height看似简单，其实还是有挺多不知道的奥妙。比如line-height:300%,line-height:3,有什么不同……","text":"line-height看似简单，其实还是有挺多不知道的奥妙。比如line-height:300%,line-height:3,有什么不同…… 形式化语法1normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; 取值normal取决于用户代理。桌面浏览器（包括火狐浏览器）使用默认值，约为1.2，这取决于元素的 font-family。 所用的值是无单位数值乘以元素的 font size。计算出来的值与使用数值指定的一样。大多数情况下，使用这种方法设置line-height是首选方法，在继承情况下不会有异常的值。 指定 用于计算 line box 的高度。查看 获取可能的单位。 与元素自身的字体大小有关。计算出的值是给定的百分比值乘以元素计算出的字体大小。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;line-height&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;p&#123;margin:10px;background:#ddd;&#125;p+p&#123;margin-left:40px;&#125;body&#123;font-size:30px;&#125;.m-demo&#123;line-height:40px;&#125;.m-demo p&#123;background:#ddd;&#125;.m-demo .p1&#123;line-height:3em;&#125;.m-demo .p2&#123;line-height:300%;&#125;.m-demo .p3&#123;line-height:3;&#125;.m-demo2&#123;line-height:300%;&#125;.m-demo2 p&#123;background:#fbb;&#125;.m-demo2 .p1&#123;font-size:16px;&#125;.m-demo3&#123;line-height:3;&#125;.m-demo3 p&#123;background:#0dd;&#125;.m-demo3 .p1&#123;font-size:16px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;m-demo&quot;&gt; &lt;p&gt;行高：line-height:40px;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;行高：line-height:3em;&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;行高：line-height:300%;&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;行高：line-height:3;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;m-demo2&quot;&gt; &lt;p&gt;行高：line-height:300%;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;字体大小：font-size:16px;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;m-demo3&quot;&gt; &lt;p&gt;行高：line-height:3;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;字体大小：font-size:16px;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 自己的理解：1、normal由浏览器决定，一般是1.1到1.2之间，1.14左右。 2、最近遇到，安卓浏览器显示placeholder 垂直不居中，去掉line-height即可。或者line-height:normal。 3、font-size:30px;line-height:3em;(90px),line-height:300px;(90px),line-height:3;(90px)百分比和数字的区别：number是直接继承。（推荐使用无单位数值给line-height赋值）比如：m-demo2行高是90px;m-demo3行高是48px; 参见：MDN line-height参见：CSS3在线手册参见：css2.1规范 感悟，多查规范，看MDN。善用google搜索。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"(转)30个你必须记住的CSS选择器","slug":"20160807-The 30 CSS Selectors you Must Memorize","date":"2016-08-07T15:10:41.000Z","updated":"2016-09-08T13:57:25.487Z","comments":true,"path":"2016/08/07/20160807-The 30 CSS Selectors you Must Memorize/","link":"","permalink":"https://lxchuan12.github.io/2016/08/07/20160807-The 30 CSS Selectors you Must Memorize/","excerpt":"概述也许你了解了基本的 id,class和descendant选择器，并且整天都在调用，如果是这样的话，那你正在错过拥有灵活性更大的选择器。这篇文章里面提到的大部分选择器都是在CSS3标准下的，所以它们只能在相应最新版本的浏览器中才能生效，你完全应该把这些都记在你聪明的脑袋里面……","text":"概述也许你了解了基本的 id,class和descendant选择器，并且整天都在调用，如果是这样的话，那你正在错过拥有灵活性更大的选择器。这篇文章里面提到的大部分选择器都是在CSS3标准下的，所以它们只能在相应最新版本的浏览器中才能生效，你完全应该把这些都记在你聪明的脑袋里面…… 1. ** { margin: 0; padding: 0; } 在我们看比较高级的选择器之前，应该认识下这个众所周知的清空选择器。星号(*)会将页面上所有每一个元素都选到。许多开发者都用它来清空margin和padding。当然你在练习的时候使用这个没问题，但是我不建议在生产环境中使用它。它会给浏览器凭添许多不必要的东西。 *也可以用来选择某元素的所有子元素: #container * { border: 1px solid black; } 它会选中#container下的所有元素。当然，我还是不建议你去使用它。DEMO 兼容性： IE6+ Firefox Chrome Safari Opera 2.#X#container { width: 960px; margin: auto; } 在选择器中使用#可以用id来定位某个元素。大家通常都会这么使用，使用的时候大家还是得相当小心的。 需要问自己一下：我是不是必须要给这个元素来赋值个id来定位它呢？ id选择器是很严格的并且你没办法去复用它。如果可以的话，首先试试用标签名字，HTML5中的新元素，或者是伪类。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 3. .X.error { color: red; } 这是个class选择器。它跟id选择器不同的是，它可以定位多个元素。当你想对多个元素进行样式修饰的时候就可以使用class。当你要对某个特定的元素进行修饰那就是用id来定位它。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 4.X Yli a { text-decoration: none; } 下一个常用的就是descendant(后代)选择器(后代指所有后代，儿子、孙子后代等)。如果你想更加具体的去定位元素，你可以使用它。例如，假如，你不需要定位所有的a元素，而只需要定位li标签下的a标签？这时候你就需要使用descendant选择器了。 专家提示：如果你的选择器像X Y Z A B.error这样，那你就错了。时刻都提醒自己，是否真的需要对那么多元素修饰。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 5.Xa { color: red; } ul { margin-left: 0; } 如果你想定位页面上所有的某标签，不是通过id或者是’class’，这简单，直接使用类型选择器。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 6.X:visited 和 X:linka:link {color:red;} a:visited {color: purple;} 我们使用:link这个伪类来定位所有还没有被访问过的链接。另外，我们也使用:visited来定位所有已经被访问过的链接。DEMO 兼容性: IE7+ Firefox Chrome Safari Opera 7.X + Yul+p{ color:red; } 这被称作相邻选择符。它将只选择紧贴在X元素之后Y元素。上面的例子，仅每一个ul之后的第一个段落元素的文本为红色。DEMO 兼容性: IE7+ Firefox Chrome Safari Opera 8.X&gt;Ydiv#container &gt; ul{ border :1px solid black; } X Y和X &gt; Y之间的不同点是后者只选择直接子代。例如，考虑如下的标记。 &lt;div id=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt; List Item &lt;ul&gt; &lt;li&gt; Child &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 选择符#container &gt; ul将只选择id为container的div的直接子代ul。它不匹配更深层的li的子代的ul。因此，使用子代选择符有性能上的优势。事实上，这同样适用于基于css选择器的javascript引擎。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 9.X~Yul ~ p { color: red; } 这是兄弟选择符和X + Y一样，然而，它没有约束。与相邻选择符（ul + li）仅选择前一个选择符后面的第一个元素比起来，兄弟选择符更宽泛。它会选择，我们上面例子中更在ul后面的任何p元素。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 10.X[title]a[title] { color: green; } 被称为属性选择器，在我们上面的例子里，这只会选择有title属性的锚标签。没有此属性的锚标签将不受影像。但如果你需要更多的特性怎么办呢？呵呵……DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 11. X[href=”foo”]a[href=&quot;http://net.tutsplus.com&quot;] { color: #1f6053; /* nettuts green */ } 上面的代码段将给所有href属性为http://net.tutsplus.com的锚标签添加样式；他们将会显示为我们的品牌绿色。所有其他的锚标签将不受影响。 注意我们将href值用引号包裹。记住，当使用javascript的css选择符引擎时也这么做。如果可能的话，尽可能使用css3选择符代替非官方的方法。 这工作的很好，但有点不够灵活。如果链接确实直接连接到Nettus+还好，但是，也许路径是到nettust的相对路径呢？在这种情况下，我们可以使用一点正则表达式语法。 DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 12. X[href*=”nettuts”]a[href*=&quot;tuts&quot;] { color: #1f6053; /* nettuts green */ } 来了不是~这就是我们需要的代码。*号指定了包含该属性的值必须包含定义的值。就是说，这句代码包含了href值为 nettuts.com，net.tutsplus.com或者tutsplus.com。记住这个描述过于宽泛，如果是某个锚点标签链接到某个连接中带有tuts非Envato的网站（tutsplus属于Envato旗下网站）呢？因此你需要更多特性来限制，分别使用^和&amp;来限定字符串的开始和结束。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 13. X[href^=”http”]a[href^=&quot;http&quot;] { background: url(path/to/external/icon.png) no-repeat; padding-left: 10px; } 有没有想过某些网站是如何定义一个图标的链接的？我确定你肯定看到过。这些链接很容易让你跳转到另一个网站。使用^(carat)符灰常简单啦。这个符号常常在正则表达式中表示字符串的开始。如果我们想指向所有以”http”开头的”href”属性的锚点的话，我们就可以使用类似于上面的那段代码啦。 注意啦，我们不需要搜索”http://“,完全没必要，因为我们还要包含以https://开头的链接呢。 如果我们想为所有链接到图片的链接定义样式咋办？这种情况下，我们得搜索字符串的结束了不是。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 14. X[href$=”.jpg”]a[href$=&quot;.jpg&quot;] { color: red; } 又来了，我们还是使用正则表达式符号，$(dolor)，来作为字符串的结束标记。这种情况下，我们就会搜索所有url以.jpg为结尾的锚点啦。记住记住这种情况下gif和png格式的图片不会被选择哦。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 15. X[data-*=”foo”]a[data-filetype=&quot;image&quot;] { color: red; } 回顾最近一条，我们如何能包含各种图片类型:png,jpeg,jpg,gif?很容易想到，我们能通过多个选择器来不是，像这样： a[href$=&quot;.jpg&quot;], a[href$=&quot;.jpeg&quot;], a[href$=&quot;.png&quot;], a[href$=&quot;.gif&quot;] { color: red; } 不过，这样很蛋疼，效率极低。另一个解决办法是使用自定义属性。如果我们加了一种自己的 data-filetype 属性给每一个链接到图片的锚点的话呢？&lt;a href=&quot;path/to/image.jpg&quot; data-filetype=&quot;image&quot;&gt; Image Link &lt;/a&gt;这样关联后，我们就能使用标准的属性选择器来指定这些链接啦。看下面：DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 16. X[foo~=”bar”]a[data-info~=&quot;external&quot;] { color: red; } a[data-info~=&quot;image&quot;] { border: 1px solid black; } 这儿有个鲜为人知的特殊技巧，绝对让你印象时刻。~(tilda)符，它可以帮助我们指向那些以空格隔开多个值的属性的元素（真拗口，这翻译我自己都看不懂，水平问题）以我们第15条的自定义属性为例，上面的代码中我们创建了 data-info属性，这个属性可以定义以空格分隔的多个值。这样，这个链接本身就是个icon，并且指向的也是一个图片链接，像下面这样。&lt;a href=&quot;path/to/image.jpg&quot; data-info=&quot;external image&quot;&gt; Click Me, Fool &lt;/a&gt;有了这样适当的标记，通过使用 ~ 属性选择器的技巧，我们就可以指向任何具有着两种属性的任何一种啦。 /* Target data-info attr that contains the value &quot;external&quot; */ a[data-info~=&quot;external&quot;] { color: red; } /* And which contain the value &quot;image&quot; */ a[data-info~=&quot;image&quot;] { border: 1px solid black; } 很棒，不是吗？DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 17. X:checkedinput[type=radio]:checked { border: 1px solid black; } 这种伪类只会匹配已经被选中的单选元素。就是这么简单。DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari *Opera 18. X:afterinput[type=radio]:checked { border: 1px solid black; } before 和 after 伪类也很蛋疼。貌似人们每天都能找到或者发明一些新办法来有效地使用它们。它们很容易控制选择器周围的内容。很多第一次使用是因为他们需要对clear-fix进行改进。 .clearfix:after { content: &quot;&quot;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; } .clearfix { *display: inline-block; _height: 1%; } 这个改进使用了:after伪类元素来在元素后增加一个空间，然后清除它。这个牛X的技巧你应该收藏到工具包里，特别是当overflow:hidden方法无能为力的时候。想看看其他创造性的用法：访问我滴创建阴影的窍门 通过Css3选择器的标准说明书，你应该有技巧地使用这些伪类语法——双冒号::。不过为了兼容，浏览器会接受一个双引号。 兼容性 *IE8+ *Firefox *Chrome *Safari *Opera 19. X:hoverdiv:hover { background: #e3e3e3; } 我去，这个你必须懂。典型的官方形式的用户触发伪类。听起来会有点迷惑，不过实际上并非如此。想在用户在某个元素上面悬停时定义个特别的样式？这个属性就是做这个的。 记住啦，较old版本的IE，只能在锚点标签后使用这个hover。 这个选择器你用得最多的情况，估计可能就是在锚点的悬停时加个border-bottom啦。 a:hover { border-bottom: 1px solid black; } 小贴士： border-bottom:1px solid black;比 text-decoration:underline;好看一点哦。（真的？我去） 兼容性 *IE6+ (In IE6, :hover must be applied to an anchor element) *Firefox *Chrome *Safari *Opera 20. X:not(selector)div:not(#container) { color: blue; } not伪类灰常有用。例如我要选择所有的div，除了有id为container的。上面那个代码片段就能完美的实现。如果我想选择除了p以外的所有元素，我可以这么做： *:not(p) { color: green; } DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari *Opera 21. X::pseudoElementp::first-line { font-weight: bold; font-size: 1.2em; } 我们可以使用伪元素（以::为表示）来定义元素的样式。例如第一行，第一个字符，记住啦，这种方法只能应用于同级元素才有效。 伪元素由两个冒号组成：:: 指定p的第一个字符的样式 p::first-letter { float: left; font-size: 2em; font-weight: bold; font-family: cursive; padding-right: 2px; } 这段代码会找到所有段落，然后再从中定义这些段落的第一个字符。这常常使用在仿报纸的文章首字母样式。 指定p的首行样式 p::first-line { font-weight: bold; font-size: 1.2em; } 同样，这个::first-line伪元素会像我们期望的那样，只定义段落的第一行的样式。DEMO 兼容性 *IE6+ *Firefox *Chrome *Safari *Opera 22. X:nth-child(n)li:nth-child(3) { color: red; } 想想那些没法从元素堆中选择元素的日子。nth-child伪类解决了这个问题。请注意 nth-child接收整数和变量，不过不是从0开始的，如果你想选定第二个li，使用 li:nth-child(2).我们甚至使用这个办法来选择任意的子元素。例如，我们可以用 li:nth-child(4n)来完成4为倍数的所有元素的选择。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari *Opera 23. X:nth-last-child(n)li:nth-last-child(2) { color: red; } 如果我有灰常多的li在ul里面，我只想要最后3个li怎么办？不必使用li:nth-child(397),你可以使用nth-last-child伪类。这种技巧和第六条几乎一样有效，不过两者的不同之处在于它从结束开始收集，用回溯的方式进行。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 24. X:nth-of-type(n)ul:nth-of-type(3) { border: 1px solid black; } 你应该有很多时候想要元素类型来选择元素而不是通过孩子。想象一下标记5个无序列表（UL）。如果你想定义第三个ul，并且没有一个唯一的id来找到它，你就可以使用 nth-of-type(3)伪类了。在上面这个代码段中，只有第三个ul才会有黑色的边框。DEMO兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 25. X:nth-last-of-type(n)ul:nth-last-of-type(3) { border: 1px solid black; } 没错，我们一样可以使用nth-last-of-type来从结束开始回溯这个选择器，来找到我们想要的元素。 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 26. X:first-childul li:first-child { border-top: none; } 这个结构的伪类让我们可以选择某个元素的第一个子孩子。你通常可以使用这个办法来删除第一个或者最后一个元素的边框。例如，你有一系列的rows，每一个都有border-top 和border-bottom。这种情况下，第一行和最后一行看起来会灰常怪。很多设计师会使用first和last类来弥补这个缺陷。相反，你可以使用这些伪类来解决这些问题。DEMO 兼容性 *IE7+ *Firefox 3.5+ *Chrome *Safari 27. X:last-childul &gt; li:last-child { color: green; } 与first-child相反，last-child会选择父节点的最后一个子节点。 例子 我们建立一些例子来示范这些类的可能的用法。我们会建立一种风格来展示。标记 List Item List Item List Item 没啥特别的，就是一个简单的序列。 CSS ul { width: 200px; background: #292929; color: white; list-style: none; padding-left: 0; } li { padding: 10px; border-bottom: 1px solid black; border-top: 1px solid #3c3c3c; } 图片 这个样式会设置一个背景，删除浏览器默认的ul的padding值，并定义边框给每一个li来提供一点深度。 如上图所示，唯一的问题是最上面的边框和最下面的边框看起来有点儿怪。让我们来使用:first-child和:last-child来解决这个问题。 li:first-child { border-top: none; } li:last-child { border-bottom: none; } 图片 看上图，解决了不是。DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari 是滴，IE8支持 first-child 不过不支持last-child。 28. X:only-childdiv p:only-child { color: red; } 实话说，你很可能会发现你不会经常使用 only-child伪类。尽管如此，它确实有用，你应该需要它。它可以帮助你选择是父节点的独生子（没别的孩子啦）的元素。例如，使用上面的代码，只有是div的唯一子孩子的p段落才会定义其颜色为red。让我们来假定下面的标记。 &lt;div&gt;&lt;p&gt; My paragraph here. &lt;/p&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt; Two paragraphs total. &lt;/p&gt; &lt;p&gt; Two paragraphs total. &lt;/p&gt; &lt;/div&gt; 这样，第二个div的p标签的内容不会被选中。只有第一个div的p才会被选中。 DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari 29. X:only-of-typeli:only-of-type { font-weight: bold; } 这种结构的伪类有几种灰常聪明的用法。它可以选定在其父节点内没有兄弟节点的元素。例如，我们可以选择只有一个li作为其子孩子的ul。首先，取决于你想怎样完成这一目标。你可以使用 ul li，不过，这回选择所有li元素。唯一的办法是使用only-of-type。 ul &gt; li:only-of-type { font-weight: bold; } DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 30. X:first-of-typefirst-of-type 伪类可以让你选择该类型的第一个兄弟节点。 一个测试 为了更好地理解它，让我们来测试一下啊。拷贝下面的标记到你的编辑器。 现在，别急着往下读，试试看如何能只选择’LIST ITEM 2’?如果你搞定了（或者放弃了），继续读。 解决办法1 有很多办法能搞定这个测试。我们回顾其中一小部分。以使用first-of-type开始。 ul:first-of-type &gt; li:nth-child(2) { font-weight: bold; } 这个代码段本质上表示，“找到第一个无序列表，然后找到这里面的li，然后，继续使用过滤器直到找到第二个li。 解决办法2 另一个可行的办法是毗邻选择器。 p + ul li:last-child { font-weight: bold; } 在这个方案中，我们找到p的临近节点ul，然后找到ul的li的最后一个孩子。解决办法3 我们可以随心所欲滴选择这些选择器。 ul:first-of-type li:nth-last-child(1) { font-weight: bold; } 这次，我们取到第一个ul，然后找到第一个元素，不过是从最后一个开始数。哈哈。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari *Opera 结论如果你仍在为解决old浏览器的缺陷而纠结，如IE6。在使用这些新的选择器方面，你仍然需要非常小心。不过，别因为这个阻碍了你对这些新玩意儿的学习。别虐待自己。确保关注这里的兼容性列表。应一方面，你可以使用 Dean Edward’s excellent IE9.js script 来为旧浏览器提供新的选择器支持。（我去。cool）其次，当使用javascript库时，如流行的jQuery，最好尽可能使用这些css3本身的选择器而不是使用库的自定义方法/选择器。这能让你的代码更快哦，因为这些选择器引擎本身就能被浏览器解析，而不是用这些库选择器。感谢阅读，希望你能学到一两个技巧。 #译者注本文为翻译文章，原文为“The 30 CSS Selectors you Must Memorize” 本文转载于颜海镜的博客","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://lxchuan12.github.io/tags/CSS选择器/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"最近碰到的兼容性问题","slug":"20160806-tips","date":"2016-08-06T13:12:38.000Z","updated":"2016-08-07T15:32:49.338Z","comments":true,"path":"2016/08/06/20160806-tips/","link":"","permalink":"https://lxchuan12.github.io/2016/08/06/20160806-tips/","excerpt":"","text":"1、transfrom:translate3d(),兼容性:-webkit-安卓4.4+2、删除节点，elem.remove(),安卓4.2.2不支持。解决方案：elem.parentNode.removeChild(elem);","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/tags/前端开发/"},{"name":"兼容性","slug":"兼容性","permalink":"https://lxchuan12.github.io/tags/兼容性/"}],"keywords":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}]},{"title":"搭建hexo博客，记录前端开发","slug":"20160806-hexo","date":"2016-08-06T08:40:38.000Z","updated":"2016-08-20T15:51:54.470Z","comments":true,"path":"2016/08/06/20160806-hexo/","link":"","permalink":"https://lxchuan12.github.io/2016/08/06/20160806-hexo/","excerpt":"虽然有在简书上使用markdown写法发布一些文章，但不是前端相关的，主要是一些电脑技巧，PPT，读书笔记等。早就有想着搭建自己的博客，记录在前端开发的路上学到的知识……","text":"虽然有在简书上使用markdown写法发布一些文章，但不是前端相关的，主要是一些电脑技巧，PPT，读书笔记等。早就有想着搭建自己的博客，记录在前端开发的路上学到的知识……有人说，写博客，不要太在乎有多少阅读量。重要的是，写博客是自己对一些知识的理解，并且能写出来，这本身就是一种整理和成长。其实有记录自己前端开发所学知识，不过是保存在为知笔记上。现在看来，也可以写博客分享出来。 总之，慢慢坚持写博客。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lxchuan12.github.io/tags/hexo/"},{"name":"F2E","slug":"F2E","permalink":"https://lxchuan12.github.io/tags/F2E/"}],"keywords":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}]}]}