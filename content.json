{"meta":{"title":"轩辕Rowboat的博客","subtitle":"前端路上 | PPT爱好者 | 所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。","description":"轩辕Rowboat，某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。","author":"轩辕Rowboat","url":"https://lxchuan12.github.io"},"pages":[{"title":"tags","date":"2016-08-29T14:57:25.000Z","updated":"2016-08-29T14:58:46.027Z","comments":false,"path":"tags/index.html","permalink":"https://lxchuan12.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你不知道的JavaScript上卷-读书笔记","slug":"20171026-you don't know js-1","date":"2017-10-26T15:36:52.000Z","updated":"2017-10-30T15:26:38.775Z","comments":true,"path":"2017/10/26/20171026-you don't know js-1/","link":"","permalink":"https://lxchuan12.github.io/2017/10/26/20171026-you don't know js-1/","excerpt":"","text":"前言：你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之后， 无论什么技术、 框架和流行词语你都能轻松理解。使用代码示例可以在这里下载本书第一部分“作用域和闭包” 随附的资料（代码示例、 练习题等） ：http://bit.ly/1c8HEWF。可以在这里下载本书第二部分“this 和对象原型” 随附的资料（代码示例、 练习题等） ：http://bit.ly/ydkjs-this-code要了解更多 O’Reilly 图书、 培训课程、 会议和新闻的信息， 请访问以下网站：http://www.oreilly.com我们在 Facebook 的地址如下： http://facebook.com/oreilly请关注我们的 Twitter 动态： http://twitter.com/oreillymedia我们的 YouTube 视频地址如下： http://www.youtube.com/oreillymedia要查看“你不知道的 JavaScript” 系列丛书中的全部图书， 请访问：http://YouDontKnowJS.com 第一部分 作用域和闭包知其然， 也要知其所以然。 第一章 作用域是什么分词/词法分析（Tokenizing/Lexing）这个过程会将由字符组成的字符串分解成（对编程语言来说） 有意义的代码块， 这些代码块被称为词法单元（token）。 例如， 考虑程序 var a = 2;。 这段程序通常会被分解成为下面这些词法单元： var、 a、 =、 2 、 ;。 空格是否会被当作词法单元， 取决于空格在这门语言中是否具有意义。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"JavaScript正则表达式迷你书-阅读笔记","slug":"20171012-JavaScript regex mini books reading record","date":"2017-10-12T15:45:52.000Z","updated":"2017-10-21T15:52:11.460Z","comments":true,"path":"2017/10/12/20171012-JavaScript regex mini books reading record/","link":"","permalink":"https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/","excerpt":"","text":"正则可视化工具正则可视化工具-regexper正则在线测试工具-regex101 勘误：2.4.2.5. 格式化$ 1888.00 -&gt; $ 1,888.00 3.3.1. 括号嵌套怎么办？最后的是 \\4，找到第3个开括号 -&gt; 最后的是 \\4，找到第4个开括号 3.5.6. 匹配成对标签其中开标签 &lt;[\\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt; -&gt; 其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt; 5.1. 结构和操作符在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构—&gt;按照原文：这里的因此应该不标红。 6.3.2. 匹配浮点数因此整个正则是这三者的或的关系，提取公众部分后是：—-&gt;公共部分 [《JavaScript 正则表达式迷你书》问世了！]（https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social） 记录一些学到的1. 第一章 正则表达式字符匹配攻略1.2.1. 范围表示法因为连字符有特殊用途，那么要匹配 “a”、”-“、”z” 这三者中任意一个字符，该怎么做呢？不能写成 [a-z]，因为其表示小写字符中的任何一个字符。可以写成如下的方式：[-az] 或 [az-] 或 [a-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 1.2.3. 常见的简写形式如果要匹配任意字符怎么办？可以使用 [\\d\\D]、[\\w\\W]、[\\s\\S] 和 [^] 中任何的一个。 1.3.2. 贪婪匹配与惰性匹配其中 /\\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。 1.4. 多选分支但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 “goodbye” 字符串时，结果是 “good”： 1234var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;good&quot;] 1234var regex = /goodbye|good/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;goodbye&quot;] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 1.5.1. 匹配 16 进制颜色值1234var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;console.log( string.match(regex) );// =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;] 1.5.2. 匹配时间12345var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;console.log( regex.test(&quot;23:59&quot;) );console.log( regex.test(&quot;02:07&quot;) );// =&gt; true// =&gt; true 如果也要求匹配 “7:9”，也就是说时分前面的 “0” 可以省略。此时正则变成： 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test(&quot;23:59&quot;) );console.log( regex.test(&quot;02:07&quot;) );console.log( regex.test(&quot;7:9&quot;) );// =&gt; true// =&gt; true// =&gt; true 1.5.3. 匹配日期123var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;console.log( regex.test(&quot;2017-06-10&quot;) );// =&gt; true 1.5.4. window 操作系统文件路径123456789var regex = /^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?$/;console.log( regex.test(&quot;F:\\\\study\\\\javascript\\\\regex\\\\regular expression.pdf&quot;) );console.log( regex.test(&quot;F:\\\\study\\\\javascript\\\\regex\\\\&quot;) );console.log( regex.test(&quot;F:\\\\study\\\\javascript&quot;) );console.log( regex.test(&quot;F:\\\\&quot;) );// =&gt; true// =&gt; true// =&gt; true// =&gt; true 1.5.5. 匹配 id12345// 解决之道，可以使用惰性匹配：var regex = /id=&quot;.*?&quot;/var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;console.log(string.match(regex)[0]);// =&gt; id=&quot;container&quot; 当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下： 12345var regex = /id=&quot;[^&quot;]*&quot;/var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;console.log(string.match(regex)[0]);// =&gt; id=&quot;container&quot;// 思考：id里有特殊字符呢。 2. 第二章 正则表达式位置匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 2.2. 如何匹配位置呢？在 ES5 中，共有 6 个锚：^、$、\\b、\\B、(?=p)、(?!p) 2.2.1. ^ 和 $^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。 2.2.2. \\b 和 \\B\\b 是单词边界，具体就是 \\w 与 \\W 之间的位置，也包括 \\w 与 ^ 之间的位置，和 \\w 与 $ 之间的位置。比如考察文件名 “[JS] Lesson_01.mp4” 中的 \\b，如下：123var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\\b/g, &apos;#&apos;);console.log(result);// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot; \\B 就是 \\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \\b，剩下的都是 \\B 的。具体说来就是 \\w 与 \\w、 \\W 与 \\W、^ 与 \\W，\\W 与 $ 之间的位置。比如上面的例子，把所有 \\B 替换成 “#”： 123var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\\B/g, &apos;#&apos;);console.log(result);// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot; 2.2.3. (?=p) 和 (?!p)(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。比如 (?=l)，表示 “l” 字符前面的位置，例如：123var result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);console.log(result);// =&gt; &quot;he#l#lo&quot; 而 (?!p) 就是 (?=p) 的反面意思，比如：123var result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);console.log(result);// =&gt; &quot;#h#ell#o#&quot; 二者的学名分别是 positive lookahead 和 negative lookahead。中文翻译分别是正向先行断言和负向先行断言。ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。具体是 (?&lt;=p) 和 (?&lt;!p)。也有书上把这四个东西，翻译成环视，即看看右边和看看左边。但一般书上，没有很好强调这四者是个位置。比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。 2.3. 位置的特性对于位置的理解，我们可以理解成空字符 “”。也等价于： 1&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot; 因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的：123var result = /^^hello$$$/.test(&quot;hello&quot;);console.log(result);// =&gt; true 甚至可以写成更复杂的:123var result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test(&quot;hello&quot;);console.log(result);// =&gt; true 也就是说字符之间的位置，可以写成多个。 TIP 把位置理解空字符，是对位置非常有效的理解方式。 2.4. 相关案例2.4.1. 不匹配任何东西的正则1/.^/ 2.4.2 数字的千位分隔符表示法12345678比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。var regex = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;var result = &quot;12345678&quot;.replace(regex, &apos;,&apos;)console.log(result);// =&gt; &quot;12,345,678&quot;result = &quot;123456789&quot;.replace(regex, &apos;,&apos;);console.log(result);// =&gt; &quot;123,456,789&quot; github上 demo 5.2、添加千分位 千位分隔符的完整攻略 2.4.2.4. 支持其他形式12345var string = &quot;12345678 123456789&quot;,regex = /(?!\\b)(?=(\\d&#123;3&#125;)+\\b)/g;var result = string.replace(regex, &apos;,&apos;)console.log(result);// =&gt; &quot;12,345,678 123,456,789&quot; 其中 (?!\\b) 怎么理解呢？要求当前是一个位置，但不是 \\b 前面的位置，其实 (?!\\b) 说的就是 \\B。因此最终正则变成了：/\\B(?=(\\d{3})+\\b)/g。 2.4.2.5. 格式化12345function format (num) &#123;return num.toFixed(2).replace(/\\B(?=(\\d&#123;3&#125;)+\\b)/g, &quot;,&quot;).replace(/^/, &quot;$$ &quot;);&#125;;console.log( format(1888) );// =&gt; &quot;$ 1,888.00&quot; 2.4.3. 验证密码问题（TODO Read again）密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。那么，我们就来挑战一下。看看我们对位置的理解是否深刻。（(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。） // 扩展： 密码中必须包含字母、数字、特称字符，至少8个字符，最多30个字符。 Array.apply(null, {length: 10})和Array(10)有什么区别? 关于apply，Array.apply(null, {length:5})怎么理解 第三章 正则表达式括号的作用NOTE match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match返回的数组格式是不一样的。 3.2.1. 提取数据123456// 提取日期var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;console.log( string.match(regex) );console.log( regex.exec(string) ); // 这里的结果一样。// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;] 同时，也可以使用构造函数的全局属性 $1 至 $9 来获取：12345678var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;06&quot;console.log(RegExp.$3); // &quot;12&quot; 3.2.2. 替换比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？12345var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result);// =&gt; &quot;06/12/2017&quot; 其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式：1234var result = string.replace(regex, function () &#123;return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); 12345// 也等价于var result = string.replace(regex, function (match, year, month, day) &#123;return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); 3.3. 反向引用除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。(\\1,\\2)这类123456789var regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;var string1 = &quot;2017-06-12&quot;;var string2 = &quot;2017/06/12&quot;;var string3 = &quot;2017.06.12&quot;;var string4 = &quot;2016-06/12&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // false 3.3.1. 括号嵌套怎么办？以左括号（开括号）为准。1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 该正则图形化(%5Cd(%5Cd)))%5C1%5C2%5C3%5C4%24) 在线正则测试12^((\\d)(\\d([a-z])))\\1\\2\\3\\4$12a12a12aa 3.3.2. \\10 表示什么呢？另外一个疑问可能是，即 \\10 是表示第 10 个分组，还是 \\1 和 0 呢？答案是前者，虽然一个正则里出现 \\10 比较罕见。测试如下：1234var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;var string = &quot;123456789# ######&quot;console.log( regex.test(string) );// =&gt; true TIP 如果真要匹配 \\1 和 0 的话，请使用 (?:\\1)0 或者 \\1(?:0)。 3.3.3. 引用不存在的分组会怎样？因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 \\2，就匹配 “\\2”。注意 “\\2” 表示对 “2” 进行了转义。1234var regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/;console.log( regex.test(&quot;\\1\\2\\3\\4\\5\\6\\7\\8\\9&quot;) );console.log( &quot;\\1\\2\\3\\4\\5\\6\\7\\8\\9&quot;.split(&quot;&quot;) );// Chrome 浏览器打印的结果（不同的浏览器和版本，打印的结果可能不一样） 3.3.4. 分组后面有量词会怎样？分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。1234var regex = /(\\d)+/;var string = &quot;12345&quot;;console.log( string.match(regex) );// =&gt; [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;] 同理对于反向引用，也是这样的。测试如下：12345var regex = /(\\d)+ \\1/;console.log( regex.test(&quot;12345 1&quot;) );// =&gt; falseconsole.log( regex.test(&quot;12345 5&quot;) );// =&gt; true 3.4. 非捕获括号之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支。如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)。 3.5. 相关案例3.5.1. 字符串 trim 方法模拟第一种，匹配到开头和结尾的空白符，然后替换成空字符。12345function trim(str) &#123;return str.replace(/^\\s+|\\s+$/g, &apos;&apos;);&#125;console.log( trim(&quot; foobar &quot;) );// =&gt; &quot;foobar&quot; 第二种，匹配整个字符串，然后用引用来提取出相应的数据：12345function trim (str) &#123;return str.replace(/^\\s*(.*?)\\s*$/g, &quot;$1&quot;);&#125;console.log( trim(&quot; foobar &quot;) );// =&gt; &quot;foobar 当然，前者效率高。 3.5.2. 将每个单词的首字母转换为大写1234567unction titleize (str) &#123; return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) &#123; return c.toUpperCase(); &#125;);&#125;console.log( titleize(&apos;my name is epeli&apos;) );// =&gt; &quot;My Name Is Epeli&quot; 3.5.3. 驼峰化12345678function camelize (str) &#123; return str.replace(/[-_\\s]+(.)?/g, function (match, c) &#123; return c ? c.toUpperCase() : &apos;&apos;; &#125;);&#125;console.log( camelize(&apos;-moz-transform&apos;) );// =&gt; &quot;MozTransform&quot;// 这里c不需要判断。&apos;&apos;.toUpperCase() === &apos;&apos;; // true 3.5.4. 中划线化12345function dasherize (str) &#123; return str.replace(/([A-Z])/g, &apos;-$1&apos;).replace(/[-_\\s]+/g, &apos;-&apos;).toLowerCase(); &#125;console.log( dasherize(&apos;MozTransform&apos;) );// =&gt; &quot;-moz-transform&quot; 3.5.5. HTML 转义和反转义12345678910111213141516// 将HTML特殊字符转换成等值的实体function escapeHTML (str) &#123; var escapeChars = &#123; &apos;&lt;&apos; : &apos;lt&apos;, &apos;&gt;&apos; : &apos;gt&apos;, &apos;&quot;&apos; : &apos;quot&apos;, &apos;&amp;&apos; : &apos;amp&apos;, &apos;\\&apos;&apos; : &apos;#39&apos; &#125;; return str.replace(new RegExp(&apos;[&apos; + Object.keys(escapeChars).join(&apos;&apos;) +&apos;]&apos;, &apos;g&apos;), function (match) &#123; return &apos;&amp;&apos; + escapeChars[match] + &apos;;&apos;; &#125;);&#125;console.log( escapeHTML(&apos;&lt;div&gt;Blah blah blah&lt;/div&gt;&apos;) );// =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;; 其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：12345678910111213141516171819// 实体字符转换为等值的HTML。function unescapeHTML (str) &#123; var htmlEntities = &#123; nbsp: &apos; &apos;, lt: &apos;&lt;&apos;, gt: &apos;&gt;&apos;, quot: &apos;&quot;&apos;, amp: &apos;&amp;&apos;, apos: &apos;\\&apos;&apos; &#125;; return str.replace(/\\&amp;([^;]+);/g, function (match, key) &#123; if (key in htmlEntities) &#123; return htmlEntities[key]; &#125; return match; &#125;);&#125;console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );// =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot; 通过 key 获取相应的分组引用，然后作为对象的键。 3.5.6. 匹配成对标签要求匹配12&lt;title&gt;regular expression&lt;/title&gt;&lt;p&gt;laoyao bye bye&lt;/p&gt; 匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;，匹配一个闭标签，可以使用 &lt;\\/[^&gt;]+&gt;，但是要求匹配成对标签，那就需要使用反向引用，如：1234567var regex = /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/;var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // false 疑惑：为什么这里没有用.匹配呢，或者说为啥没用.?阻止贪婪匹配模式（惰性模式）呢 4. 第四章 正则表达式回溯法原理学习正则表达式，是需要懂点儿匹配原理的。而研究匹配原理时，有两个字出现的频率比较高：“回溯”。 4.1. 没有回溯的匹配假设我们的正则是 /ab{1,3}c/，而当目标字符串是 “abbbc” 时，就没有所谓的“回溯”。 4.2. 有回溯的匹配如果目标字符串是”abbc”，中间就有回溯。 图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 “b”，准备尝试第三个时，结果发现接下来的字符是 “c”。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 “c”。当然，此时整个表达式匹配成功了。图中的第 6 步，就是“回溯”。 再举一个例子：/ab{1,3}bbc/ 目标字符串是”abbbc”，匹配过程是：/“.*”/目标字符串是：”abc”de， 图中省略了尝试匹配双引号失败的过程。可以看出 . 是非常影响效率的。为了减少一些不必要的回溯，可以把正则修改为 /“[^”]“/。 4.3. 常见的回溯形式正则表达式匹配字符串的这种方式，有个学名，叫回溯法。 本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。道理，我们是懂了。那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？ 4.3.1 贪婪量词之前的例子都是贪婪量词相关的。 此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？答案是，先下手为强！因为深度优先搜索。测试如下：1234var string = &quot;12345&quot;;var regex = /(\\d&#123;1,3&#125;)(\\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;] 4.3.2 惰性量词虽然惰性量词不贪，但也会有回溯的现象。比如正则式：/^\\d{1,3}?\\d{1,3}$/目标字符串是 “12345”。 知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \\d{1,3}? 匹配的字符是 “12”，是两个数字，而不是一个。 4.3.3 分支结构我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 “candy”，得到的结果是 “can”，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 比如：/^(?:can|candy)$/ 目标字符串是’candy’ 上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。 4.4. 本章小结其实回溯法，很容易掌握的。简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。• 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。• 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动机”的简写。而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。大部分语言中的正则都是 NFA，为啥它这么流行呢？答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。 5. 第五章 正则表达式的拆分5.1. 结构和操作符JavaScript 正则表达式中，都有哪些结构呢？字符字面量、字符组、量词、锚、分组、选择分支、反向引用。 其中涉及到的操作符有：操作符描述 操作符 优先级转义符 \\ 1括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2量词限定符 {m}、{m,n}、{m,}、?、*、+ 3位置和序列 ^、$、\\元字符、一般字符 4管道符（竖杠） | 5 5.2. 注意要点5.2.1 匹配字符串整体问题比如要匹配目标字符串 “abc” 或者 “bcd” 时，如果一不小心，就会写成 /^abc|bcd$/。而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是。 开始-abcbcd-结束应该是：/^(abc|bcd)$/ 5.2.2 量词连缀问题 每个字符为 “a、”b”、”c” 任选其一， 字符串的长度是 3 的倍数。/^[abc]{3}+$/，这样会报错，说 + 前面没什么可重复的。应该为：/([abc]{3})+/ 5.2.3 元字符转义问题所谓元字符，就是正则中有特殊含义的字符。所有结构里，用到的元字符总结如下：^、$、.、*、+、?、|、\\、/、(、)、[、]、{、}、=、!、:、- ,当匹配上面的字符本身时，可以一律转义：1234var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var regex = /\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,/;console.log( regex.test(string) );// =&gt; true 其中 string 中的 \\ 字符也要转义的。另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身：1234var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var string2 = &quot;\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,&quot;;console.log( string == string2 );// =&gt; true 现在的问题是，是不是每个字符都需要转义呢？否，看情况。 5.2.3.1. 字符组中的元字符跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然会把整个字符组，看成反义字符组。12345var string = &quot;^$.*+?|\\\\/[]&#123;&#125;=!:-,&quot;;var regex = /[\\^$.*+?|\\\\/\\[\\]&#123;&#125;=!:\\-,]/g;console.log( string.match(regex) );// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;,&quot;-&quot;, &quot;,&quot;] 5.2.3.2. 匹配 “[abc]” 和 “{3,5}”我们知道 [abc]，是个字符组。如果要匹配字符串 “[abc]” 时，该怎么办？可以写成 /[abc]/，也可以写成 /[abc]/只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。 同理，要匹配字符串 “{3,5}”，只需要把正则写成 /{3,5}/ 即可。另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 “{,n}”，测试如下：1234var string = &quot;&#123;,3&#125;&quot;;var regex = /&#123;,3&#125;/g;console.log( string.match(regex)[0] );// =&gt; &quot;&#123;,3&#125;&quot; 5.2.3.3. 其余情况比如 =、!、:、-、, 等符号，只要不在特殊结构中，并不需要转义。但是，括号需要前后都转义的，如 /(123)/。至于剩下的 ^、$、.、*、+、?、|、\\、/ 等字符，只要不在字符组内，都需要转义的。 5.3. 案例分析5.3.1 身份证正则表达式是：/^(\\d{15}|\\d{17}[\\dxX])$/ 5.3.2 IPV4 地址正则表达式是：1/^((0&#123;0,2&#125;\\d|0?\\d&#123;2&#125;|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.)&#123;3&#125;(0&#123;0,2&#125;\\d|0?\\d&#123;2&#125;|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])$/ 这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：((…).){3}(…)其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是3位数.3位数.3位数.3位数然后再来分析 (…)：(0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5]) 6. 第六章 正则表达式的构建6.1. 平衡法则构建正则有一点非常重要，需要做到下面几点的平衡：1.• 匹配预期的字符串2.• 不匹配非预期的字符串3.• 可读性和可维护性4.• 效率 6.2. 构建正则前提比如匹配这样的字符串：1010010001…。虽然很有规律，但是只靠正则就是无能为力。 6.2.2. 是否有必要使用正则？要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串 API 解决的简单问题，就不该正则出马。 比如，从日期中提取出年月日，虽然可以使用正则：1234var string = &quot;2017-07-01&quot;;var regex = /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;console.log( string.match(regex) );// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;] 其实，可以使用字符串的 split 方法来做，即可：1234var string = &quot;2017-07-01&quot;;var result = string.split(&quot;-&quot;);console.log( result );// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;] 比如，判断是否有问号，虽然可以使用：123var string = &quot;?id=xx&amp;act=search&quot;;console.log( string.search(/\\?/) );// =&gt; 0 其实，可以使用字符串的 indexOf 方法：123var string = &quot;?id=xx&amp;act=search&quot;;console.log( string.indexOf(&quot;?&quot;) );// =&gt; 0 比如获取子串，虽然可以使用正则：123var string = &quot;JavaScript&quot;;console.log( string.match(/.&#123;4&#125;(.+)/)[1] );// =&gt; Script 其实，可以直接使用字符串的 substring 或 substr 方法（语言精粹中推荐使用slice,substr是在ES5规范附则里。）来做：123var string = &quot;JavaScript&quot;;console.log( string.substring(4) );// =&gt; Script 6.2.3. 是否有必要构建一个复杂的正则？6.2.3. 是否有必要构建一个复杂的正则？比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。在第2章里，我们写出了正则是1/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/ 123456789101112其实可以使用多个小正则来做：var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;var regex2 = /^[0-9]&#123;6,12&#125;$/;var regex3 = /^[A-Z]&#123;6,12&#125;$/;var regex4 = /^[a-z]&#123;6,12&#125;$/;function checkPassword (string) &#123; if (!regex1.test(string)) return false; if (regex2.test(string)) return false; if (regex3.test(string)) return false; if (regex4.test(string)) return false; return true;&#125; 6.3. 准确性所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。这里提到了“预期”二字，那么我们就需要知道目标的组成规则。 6.3.1. 匹配固定电话比如要匹配如下格式的固定电话号码：1230551888888880551-88888888(0551)88888888 1/^(0\\d&#123;2,3&#125;-?|\\(0\\d&#123;2,3&#125;\\))[1-9]\\d&#123;6,7&#125;$/ 这就是一个平衡取舍问题，一般够用就行。 6.3.2. 匹配浮点数要求匹配如下的格式：1231.23、+1.23、-1.2310、+10、-10.2、+.2、-.2 上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：/^[+-]?(\\d+)?(.\\d+)?$/此正则看似没问题，但这个正则也会匹配空字符 “”。因为目标字符串的形式关系不是要求每部分都是可选的。/^[+-]?(\\d+.\\d+|\\d+|.\\d+)$/ 6.4. 效率保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。正则表达式的运行分为如下的阶段： • 1. 编译；• 2. 设定起始位置；• 3. 尝试匹配；• 4. 匹配失败的话，从下一位开始继续第 3 步；• 5. 最终结果：匹配成功或失败 当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。 6.4.1. 使用具体型字符组来代替通配符，来消除回溯而在第三阶段，最大的问题就是回溯。因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。 6.4.2. 使用非捕获型分组因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。 6.4.3. 独立出确定字符例如，/a+/ 可以修改成 /aa*/。 6.4.4. 提取分支公共部分比如，/^abc|^def/ 修改成 /^(?:abc|def)/。又比如， /this|that/修改成 /th(?:is|at)/。这样做，可以减少匹配过程中可消除的重复。 6.4.5. 减少分支的数量，缩小它们的范围/red|read/ 可以修改成 /rea?d/。此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。 7. 第七章 正则表达式编程7.1. 正则表达式的四种操作正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。 7.1.1. 验证比如，判断一个字符串中是否有数字。使用 search：12345var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!~string.search(regex) );// ~0 === -1// =&gt; true 1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( regex.test(string) );// =&gt; true 使用 match：1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!string.match(regex) );// =&gt; true 使用 exec：1234var regex = /\\d/;var string = &quot;abc123&quot;;console.log( !!regex.exec(string) );// =&gt; true 其中，最常用的是 test。 7.1.2. 切分匹配上了，我们就可以进行一些操作，比如切分。所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。 7.1.3. 提取虽然整体匹配上了，但有时需要提取部分匹配的数据。此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。这里，还是以日期为例，提取出年月日。注意下面正则中的括号：使用 match：使用 exec：使用 test：12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;regex.test(string);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; 使用 search：12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;string.search(regex);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; 使用 replace：12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;var date = [];string.replace(regex, function (match, year, month, day) &#123;date.push(year, month, day);&#125;);console.log(date);// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] 其中，最常用的是 match。 7.1.4. 替换找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。 7.2. 相关 API 注意要点从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：123456String#searchString#splitString#matchString#replaceRegExp#testRegExp#exec 7.2.1. search 和 match 的参数问题我们知道字符串实例的那 4 个方法参数都支持正则和字符串。但 search 和 match，会把字符串转换为正则的。replace和split不会。 7.2.2. match 返回结果的格式问题match 返回结果的格式，与正则对象是否有修饰符 g 有关。1234567var string = &quot;2017.06.27&quot;;var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;] 没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。有 g，返回的是所有匹配的内容。当没有匹配时，不管有无 g，都返回 null。 7.2.3. exec 比 match 更强大当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配：其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。比如第一次匹配了 “2017”，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配的位置是 4。从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环： 7.2.4. 修饰符 g，对 exex 和 test 的影响上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。 7.2.5. test 整体匹配时需要使用 ^ 和 $这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。如果，要整体匹配，正则前后需要添加开头和结尾：123456console.log( /123/.test(&quot;a123b&quot;) );// =&gt; trueconsole.log( /^123$/.test(&quot;a123b&quot;) );// =&gt; falseconsole.log( /^123$/.test(&quot;123&quot;) );// =&gt; true 7.2.6. split 相关注意事项split 方法看起来不起眼，但要注意的地方有两个的。第一，它可以有第二个参数，表示结果数组的最大长度：123var string = &quot;html,css,javascript&quot;;console.log( string.split(/,/, 2) );// =&gt;[&quot;html&quot;, &quot;css&quot;] 第二，正则使用分组时，结果数组中是包含分隔符的：123var string = &quot;html,css,javascript&quot;;console.log( string.split(/(,)/) );// =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;] 7.2.7. replace 是很强大的《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： 属性 描述$1,$2,…,$99 匹配第 1-99 个 分组里捕获的文本$&amp; 匹配到的子串文本$` 匹配到的子串的左边文本$’ 匹配到的子串的右边文本$$ 美元符号记忆中语言精粹中有列举更多。再例如，把 “2+3=5”，变成 “2+3=2+3=5=5”:123var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);console.log(result);// =&gt; &quot;2+3=2+3=5=5 我们对最后这个进行一下说明。要把 “2+3=5”，变成 “2+3=2+3=5=5”，其实就是想办法把 = 替换成=2+3=5=，其中，$&amp; 匹配的是 =， $匹配的是 2+3，$&#39; 匹配的是 5。因此使用 &quot;$&amp;$$&amp;$’$&amp;” 便达成了目的。当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：123456&quot;1234 2345 3456&quot;.replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function (match, $1, $2, index, input) &#123;console.log([match, $1, $2, index, input]);&#125;);// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;] 此时我们可以看到 replace 拿到的信息，并不比 exec 少。 7.2.8. 使用构造函数需要注意的问题一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 \\。 7.2.9. 修饰符ES5 中修饰符，共 3 个：g,i,m当然正则对象也有相应的只读属性：1234567var regex = /\\w/img;console.log( regex.global );console.log( regex.ignoreCase );console.log( regex.multiline );// =&gt; true// =&gt; true// =&gt; true 7.2.10. source 属性正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source属性。它什么时候有用呢？比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么：1234var className = &quot;high&quot;;var regex = new RegExp(&quot;(^|\\\\s)&quot; + className + &quot;(\\\\s|$)&quot;);console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串&quot;(^|\\\\s)high(\\\\s|$)&quot; 7.2.11. 构造函数属性构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的属性（有兼容性问题）： 静态属性 描述 简写形式RegExp.input 最近一次目标字符串 RegExp[“$_”]RegExp.lastMatch 最近一次匹配的文本 RegExp[“$&amp;”]RegExp.lastParen 最近一次捕获的文本 RegExp[“$+”]RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”]RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[“$’”] 7.3. 真实案例7.3.1. 使用构造函数生成正则表达式123456789101112131415161718192021&lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt;&lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt;&lt;p&gt;3333&lt;/p&gt;&lt;script&gt;function getElementsByClassName (className) &#123;var elements = document.getElementsByTagName(&quot;*&quot;);var regex = new RegExp(&quot;(^|\\\\s)&quot; + className + &quot;(\\\\s|$)&quot;);var result = [];for (var i = 0; i &lt; elements.length; i++) &#123;var element = elements[i];if (regex.test(element.className)) &#123;result.push(element)&#125;&#125;return result;&#125;var highs = getElementsByClassName(&apos;high&apos;);highs.forEach(function (item) &#123;item.style.color = &apos;red&apos;;&#125;);&lt;/script&gt; 7.3.2. 使用字符串保存数据一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：123456789var utils = &#123;&#125;;&quot;Boolean|Number|String|Function|Array|Date|RegExp|Object|Error&quot;.split(&quot;|&quot;).forEach(function (item) &#123;utils[&quot;is&quot; + item] = function (obj) &#123;return &#123;&#125;.toString.call(obj) == &quot;[object &quot; + item + &quot;]&quot;;&#125;;&#125;);console.log( utils.isArray([1, 2, 3]) );// =&gt; true 7.3.3. if 语句中使用正则替代 &amp;&amp;比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）：123456789101112131415161718var readyRE = /complete|loaded|interactive/;function ready (callback) &#123;if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123;callback()&#125;else &#123;document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;callback()&#125;,false);&#125;&#125;;ready(function () &#123;alert(&quot;加载完毕！&quot;)&#125;); 7.3.4. 使用强大的 replace因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何东西。12345678910111213function compress (source) &#123;var keys = &#123;&#125;;source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123;keys[key] = (keys[key] ? keys[key] + &apos;,&apos; : &apos;&apos;) + value;&#125;);var result = [];for (var key in keys) &#123;result.push(key + &apos;=&apos; + keys[key]);&#125;return result.join(&apos;&amp;&apos;);&#125;console.log( compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;) );// =&gt; &quot;a=1,3&amp;b=2,4&quot; 完。84/89","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"github使用小技巧","slug":"20170921-github tips","date":"2017-09-21T15:15:52.000Z","updated":"2017-09-21T15:44:17.403Z","comments":true,"path":"2017/09/21/20170921-github tips/","link":"","permalink":"https://lxchuan12.github.io/2017/09/21/20170921-github tips/","excerpt":"","text":"大多数开发者都有github账号，但github这些日常小技巧估计不知道。1、subscribe订阅github周报，每周会把你关注的开发语言和关注的人的动态等发邮件给你：每天github的热点2、快捷键：在github某个项目面板（页面），按shift+?，可以看到所有支持的快捷键。其中常用的主要有。 T，搜索文件S:定位到搜索输入框GC:跳转到code面板GI:跳转到issue面板GP:跳转到 pull request面板GW:跳转到 Wiki搜索issue和pull request时可以使用过滤器。比如：is:open回答输入时，可以用#号来匹配相应的issue.3、Code Line可以标注一些代码。按住shift,选择行号。对应的代码就高亮了。对应链接加上了hash#L1-L214、octotree chrome插件github可以像编辑器目录文件形式。octotree chrome插件地址如果翻墙苦难，可以直接下载dist目录下chrome.crx，拖拽到chrome浏览器插件即可安装。","categories":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/tags/github/"}],"keywords":[{"name":"github","slug":"github","permalink":"https://lxchuan12.github.io/categories/github/"}]},{"title":"JavaScript 对象所有API解析","slug":"20170817-Object API","date":"2017-08-17T15:51:52.000Z","updated":"2017-08-31T13:47:58.430Z","comments":true,"path":"2017/08/17/20170817-Object API/","link":"","permalink":"https://lxchuan12.github.io/2017/08/17/20170817-Object API/","excerpt":"","text":"首发于segmentfault:JavaScript 对象所有API解析 之前看到【深度长文】JavaScript数组所有API全解密和JavaScript字符串所有API全解密这两篇高质量的文章。发现没写对象API解析（估计是博主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。 创建对象的两种方式：12var o = new Object();var o = &#123;&#125;; // 推荐 该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：1234var o = new Object(&apos;something&apos;);o.constructor; // ƒ String() &#123; [native code] &#125;var n = new Object(123);n.constructor; // ƒ Number() &#123; [native code] &#125; 一、Object构造器的成员Object.prototype该属性是所有对象的原型（包括 Object对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。比如：123var s = new String(&apos;xuanyuan&apos;);Object.prototype.custom = 1;console.log(s.custom); // 1 二、Object.prototype 的成员Object.prototype.constructor该属性指向用来构造该函数对象的构造器，在这里为Object()123Object.prototype.constructor === Object; // truevar o = new Object();o.constructor === Object; // true Object.prototype.toString(radix)该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数radix，该参数radix，该参数的默认值为10。12345var o = &#123;prop:1&#125;;o.toString(); // &apos;[object object]&apos;var n = new Number(255);n.toString(); // &apos;255&apos;n.toString(16); // &apos;ff&apos; Object.prototype.toLocaleString()该方法的作用与toString()基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如Date(),Number(),Array(),它们的值都会以本地化的形式输出。当然，对于包括Object()在内的其他大多数对象来说，该方法与toString()是基本相同的。在浏览器环境下，可以通过BOM对象Navigator的language属性（在IE中则是userLanguage）来了解当前所使用的语言：1navigator.language; //&apos;en-US&apos; Object.prototype.valueOf()该方法返回的是用基本类型所表示的this值，如果它可以用基本类型表示的话。如果Number对象返回的是它的基本数值，而Date对象返回的是一个时间戳（timestamp）。如果无法用基本数据类型表示，该方法会返回this本身。1234567891011121314// Objectvar o = &#123;&#125;;typeof o.valueOf(); // &apos;object&apos;o.valueOf() === o; // true// Numbervar n = new Number(101);typeof n; // &apos;object&apos;typeof n.vauleOf; // &apos;function&apos;typeof n.valueOf(); // &apos;number&apos;n.valueOf() === n; // false// Datevar d = new Date();typeof d.valueOf(); // &apos;number&apos;d.valueOf(); // 1503146772355 Object.prototype.hasOwnProperty(prop)该方法仅在目标属性为对象自身属性时返回true,而当该属性是从原型链中继承而来或根本不存在时，返回false。1234var o = &#123;prop:1&#125;;o.hasOwnProperty(&apos;prop&apos;); // trueo.hasOwnProperty(&apos;toString&apos;); // falseo.hasOwnProperty(&apos;formString&apos;); // false Object.prototype.isPrototypeOf(obj)如果目标对象是当前对象的原型，该方法就会返回true，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。1234var s = new String(&apos;&apos;);Object.prototype.isPrototypeOf(s); // trueString.prototype.isPrototypeOf(s); // trueArray.prototype.isPrototypeOf(s); // false Object.prototype.propertyIsEnumerable(prop)如果目标属性能在for in循环中被显示出来，该方法就返回true123var a = [1,2,3];a.propertyIsEnumerable(&apos;length&apos;); // falsea.propertyIsEnumerable(0); // true 三、在ES5中附加的Object属性在ES3中，除了一些内置属性（如：Math.PI），对象的所有的属性在任何时候都可以被修改、插入、删除。在ES5中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。ES5中引入了属性描述符的概念，我们可以通过它对所定义的属性有更大的控制权。这些属性描述符（特性）包括： value——当试图获取属性时所返回的值。writable——该属性是否可写。enumerable——该属性在for in循环中是否会被枚举configurable——该属性是否可被删除。set()——该属性的更新操作所调用的函数。get()——获取属性值时所调用的函数。另外，数据描述符（其中属性为：enumerable，configurable，value，writable）与存取描述符（其中属性为enumerable，configurable，set()，get()）之间是有互斥关系的。在定义了set()和get()之后，描述符会认为存取操作已被 定义了，其中再定义value和writable会引起错误。以下是ES3风格的属性定义方式：12var person = &#123;&#125;;person.legs = 2; 以下是等价的ES5通过数据描述符定义属性的方式：1234567var person = &#123;&#125;;Object.defineProperty(person, &apos;legs&apos;, &#123; value: 2, writable: true, configurable: true, enumerable: true&#125;); 其中， 除了value的默认值为undefined以外，其他的默认值都为false。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为true。或者，我们也可以通过ES5的存储描述符来定义：123456789101112var person = &#123;&#125;;Object.defineProperty(person, &apos;legs&apos;, &#123; set:function(v) &#123; return this.value = v; &#125;, get: function(v) &#123; return this.value; &#125;, configurable: true, enumerable: true&#125;);person.legs = 2; 这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容ES3方面所做的考虑。例如，跟添加Array.prototype属性不一样，我们不能再旧版的浏览器中使用shim这一特性。另外，我们还可以（通过定义nonmalleable属性），在具体行为中运用这些描述符：123456var person = &#123;&#125;;Object.defineProperty(person, &apos;heads&apos;, &#123;value: 1&#125;);person.heads = 0; // 0person.heads; // 1 (改不了)delete person.heads; // falseperson.heads // 1 (删不掉) Object.defineProperty(obj, prop, descriptor) (ES5)具体用法可参见上文，或者查看MDN。MDN Object.defineProperty(obj, descriptor) Vue.js文档：如何追踪变化 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 Object.defineProperties(obj, props) (ES5)该方法的作用与defineProperty()基本相同，只不过它可以用来一次定义多个属性。比如：1234567891011var glass = Object.defineProperties(&#123;&#125;, &#123; &apos;color&apos;: &#123; value: &apos;transparent&apos;, writable: true &#125;, &apos;fullness&apos;: &#123; value: &apos;half&apos;, writable: false &#125;&#125;);glass.fullness; // &apos;half&apos; Object.getPrototypeOf(obj) (ES5)之前在ES3中，我们往往需要通过Object.prototype.isPrototypeOf()去猜测某个给定的对象的原型是什么，如今在ES5中，我们可以直接询问改对象“你的原型是什么？”123Object.getPrototypeOf([]) === Array.prototype; // trueObject.getPrototypeOf(Array.prototype) === Object.prototype; // trueObject.getPrototypeOf(Object.prototype) === null; // true Object.create(obj, descr) (ES5)该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。123456789101112var parent = &#123;hi: &apos;Hello&apos;&#125;;var o = Object.create(parent, &#123; prop: &#123; value: 1 &#125;&#125;);o.hi; // &apos;Hello&apos;// 获得它的原型Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototypeObject.getPrototypeOf(o); // &#123;hi: &quot;Hello&quot;&#125; // 说明o的原型是&#123;hi: &quot;Hello&quot;&#125;o.hasOwnProperty(&apos;hi&apos;); // false 说明hi是原型上的o.hasOwnProperty(&apos;prop&apos;); // true 说明prop是原型上的自身上的属性。 现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在ES3中可是做不到的。12var o = Object.create(null);typeof o.toString(); // &apos;undefined&apos; Object.getOwnPropertyDesciptor(obj, property) (ES5)该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。12Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125; Object.getOwnPropertyNames(obj) (ES5)该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用Object.keys()来单独返回可枚举的属性。12345678Object.getOwnPropertyNames(Object.prototype);// [&quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;]Object.keys(Object.prototype);// []Object.getOwnPropertyNames(Object);// [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;prototype&quot;, &quot;assign&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getOwnPropertyDescriptors&quot;, &quot;getOwnPropertyNames&quot;, &quot;getOwnPropertySymbols&quot;, &quot;is&quot;, &quot;preventExtensions&quot;, &quot;seal&quot;, &quot;create&quot;, &quot;defineProperties&quot;, &quot;defineProperty&quot;, &quot;freeze&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;isFrozen&quot;, &quot;isSealed&quot;, &quot;keys&quot;, &quot;entries&quot;, &quot;values&quot;]Object.keys(Object);// [] Object.preventExtensions(obj) (ES5)Object.isExtensible(obj) (ES5)preventExtensions()方法用于禁止向某一对象添加更多属性，而isExtensible()方法则用于检查某对象是否还可以被添加属性。12345678910var deadline = &#123;&#125;;Object.isExtensible(deadline); // truedeadline.date = &apos;yesterday&apos;; // &apos;yesterday&apos;Object.preventExtensions(deadline);Object.isExtensible(deadline); // falsedeadline.date = &apos;today&apos;;deadline.date; // &apos;today&apos;// 尽管向某个不可扩展的对象中添加属性不算是一个错误操作，但它没有任何作用。deadline.report = true;deadline.report; // undefined Object.seal(obj) (ES5)Object.isSeal(obj) (ES5)seal()方法可以让一个对象密封，并返回被密封后的对象。seal()方法的作用与preventExtensions()基本相同，但除此之外，它还会将现有属性设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用defineProperty()）重新配置这些属性，例如不能将一个可枚举的属性改成不可枚举。123456789101112var person = &#123;legs:2&#125;;// person === Object.seal(person); // trueObject.isSealed(person); // trueObject.getOwnPropertyDescriptor(person, &apos;legs&apos;);// &#123;value: 2, writable: true, enumerable: true, configurable: false&#125;delete person.legs; // false (不可删除，不可配置)Object.defineProperty(person, &apos;legs&apos;,&#123;value:2&#125;);person.legs; // 2person.legs = 1;person.legs; // 1 (可写)Object.defineProperty(person, &quot;legs&quot;, &#123; get: function() &#123; return &quot;legs&quot;; &#125; &#125;);// 抛出TypeError异常 Object.freeze(obj) (ES5)Object.isFrozen(obj) (ES5)freeze()方法用于执行一切不受seal()方法限制的属性值变更。Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。12345678910var deadline = Object.freeze(&#123;date: &apos;yesterday&apos;&#125;);deadline.date = &apos;tomorrow&apos;;deadline.excuse = &apos;lame&apos;;deadline.date; // &apos;yesterday&apos;deadline.excuse; // undefinedObject.isSealed(deadline); // true;Object.isFrozen(deadline); // trueObject.getOwnPropertyDescriptor(deadline, &apos;date&apos;);// &#123;value: &quot;yesterday&quot;, writable: false, enumerable: true, configurable: false&#125; (不可配置，不可写)Object.keys(deadline); // [&apos;date&apos;] (可枚举) Object.keys(obj) (ES5)该方法是一种特殊的for-in循环。它只返回当前对象的属性（不像for-in），而且这些属性也必须是可枚举的（这点和Object.getOwnPropertyNames()不同，不论是否可以枚举）。返回值是一个字符串数组。1234567Object.prototype.customProto = 101;Object.getOwnPropertyNames(Object.prototype);// [..., &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;, &quot;customProto&quot;]Object.keys(Object.prototype); // [&apos;customProto&apos;]var o = &#123;own: 202&#125;;o.customProto; // 101Object.keys(o); // [&apos;own&apos;] 四、在ES6中附加的Object属性Object.is(value1, value2) (ES6)该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，而是NaN等于自身。123456Object.is(&apos;xuanyuan&apos;, &apos;xuanyuan&apos;); // trueObject.is(&#123;&#125;,&#123;&#125;); // falseObject.is(+0, -0); // false+0 === -0; // trueObject.is(NaN, NaN); // trueNaN === NaN; // false ES5可以通过以下代码部署Object.is12345678910111213Object.defineProperty(Object, &apos;is&apos;, &#123; value: function() &#123;x, y&#125; &#123; if (x === y) &#123; // 针对+0不等于-0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对 NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); Object.assign(target, …sources) (ES6)该方法用来源对象（source）的所有可枚举的属性复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象target，后面的参数都是源对象（source）。只有一个参数不是对象，就会抛出TypeError错误。1234567891011var target = &#123;a: 1&#125;;var source1 = &#123;b: 2&#125;;var source2 = &#123;c: 3&#125;;obj = Object.assign(target, source1, source2);target; // &#123;a:1,b:2,c:3&#125;obj; // &#123;a:1,b:2,c:3&#125;target === obj; // true// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。var source3 = &#123;a:2,b:3,c:4&#125;;Object.assign(target, source3);target; // &#123;a:2,b:3,c:4&#125; Object.assign只复制自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被复制。1234567Object.assign(&#123;b: &apos;c&apos;&#125;, Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123; enumerable: false, value: &apos;hello&apos; &#125;));// &#123;b: &apos;c&apos;&#125; 属性名为Symbol值的属性，也会被Object.assign()复制。12Object.assign(&#123;a: &apos;b&apos;&#125;, &#123;[Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);// &#123;a: &apos;b&apos;, Symbol(c): &apos;d&apos;&#125; 对于嵌套的对象，Object.assign()的处理方法是替换，而不是添加。12Object.assign(&#123;a: &#123;b:&apos;c&apos;,d:&apos;e&apos;&#125;&#125;, &#123;a:&#123;b:&apos;hello&apos;&#125;&#125;);// &#123;a: &#123;b:&apos;hello&apos;&#125;&#125; 对于数组，Object.assign()把数组视为属性名为0、1、2的对象。12Object.assign([1,2,3], [4,5]);// [4,5,3] Object.getOwnPropertySymbols(obj) (ES6)该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。该方法和 Object.getOwnPropertyNames() 类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。12Object.getOwnPropertySymbols(&#123;a: &apos;b&apos;, [Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);// [Symbol(c)] Object.setPrototypeOf(obj, prototype) (ES6)该方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。__proto__属性用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。123456789101112// ES6写法var obj = &#123; method: function()&#123; // code ... &#125;&#125;;// obj.__proto__ = someOtherObj;// ES5写法var obj = Object.create(someOtherObj);obj.method = function()&#123; // code ...&#125;; 该属性没有写入ES6的正文，而是写入了附录。__proto__前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。而是使用Object.setPrototypeOf()（写操作），Object.getPrototypeOf()（读操作），或Object.create()（生成操作）代替。在实现上，__proto__调用的Object.prototype.__proto__。Object.setPrototypeOf()方法的作用与__proto__作用相同，用于设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。 五、在ES8中附加的Object属性Object.getOwnPropertyDescriptors(obj) (ES8)该方法基本与Object.getOwnPropertyDescriptor(obj, property)用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。123Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;Object.getOwnPropertyDescriptors(Object.prototype); // 可以自行在浏览器控制台查看效果。 Object.values(obj) (ES8)Object.values() 方法与Object.keys类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。123var obj = &#123;a:1,b:2,c:3&#125;;Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]Object.values(obj); // [1,2,3] Object.entries(obj) (ES8)Object.entries() 方法返回一个给定对象自己的可枚举属性[key，value]对的数组，数组中键值对的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致（区别在于一个for-in循环也枚举原型链中的属性）。1234var obj = &#123;a:1,b:2,c:3&#125;;Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]Object.values(obj); // [1,2,3]Object.entries(obj); // [[&apos;a&apos;,1],[&apos;b&apos;,2],[&apos;c&apos;,3]] 小结：您可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有Object.prototype.toString()，Object.prototype.hasOwnProperty()， Object.getPrototypeOf(obj)，Object.create()，Object.defineProperty，Object.keys(obj)，Object.assign()。 参考资料MDN Object APIJavaScript面向对象编程指南（第2版）（豆瓣读书链接）阮一峰 ES6标准入门2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"《JavaScript 语言精粹 修订版》 读书笔记","slug":"20170723-JavaScript essence of reading notes","date":"2017-07-23T14:23:52.000Z","updated":"2017-08-12T16:04:49.535Z","comments":true,"path":"2017/07/23/20170723-JavaScript essence of reading notes/","link":"","permalink":"https://lxchuan12.github.io/2017/07/23/20170723-JavaScript essence of reading notes/","excerpt":"","text":"首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记 之前看到这篇文章，前端网老姚浅谈：怎么学JavaScript？，说到怎么学习JavaScript，那就是看书、分析源码。10本书读2遍的好处，应该大于一本书读20遍。看书主动学习，看视频是被动学习。看书和分析源码的时机。但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来学习，那&gt;肯定是必须的，工作本身就是一个学习的过程。怎么把一本书看完呢？很简单，敲。文字加代码都敲。比较认同老姚的说法。去年毕业到现在，我也算是工作一年了，是时候看书查缺补漏了。 于是我就先把这本薄的经典书《JavaScript语言精粹 修订版》豆瓣读书本书简介（总共10章，除去附录，才100页），读完并记录了一些笔记。基本算是摘抄书本的，自己联想到了一些知识和资料也扩展了一下。总体写下来近一万字。读书笔记还可以分享给别人看。回顾时，书不在身边还可以看看自己的笔记。想想这类经典书记一遍动手敲一遍也是很值得的。不过这读书笔记中可能会有一些错别字，阅读时如果发现欢迎指正。 第1章 精华大多数语言都有精华和糟粕。JavaScript令人诡异的事情是，在对这门语言没有的太多了解，甚至对编程都没有太多了解的情况下，你也能用它来完成工作。看到这里不禁想起： 张鑫旭大牛在《我对知乎前端相关问题的十问十答》非计算机专业背景学习JS要点有这一条：所有继承和原型相关内容跳过，注意，是跳过，不要看！没有这些JS一样可以活得很好，你的日常工作一样玩得飞起，当然，你没忍住看了相关知识也没关系，因为你会发现自己看不懂的； JavaScript的函数是（主要）基于词法作用域的顶级对象。 译注：JavaScript中的函数是根据词法来划分作用域的，而不是动态划分作用域的。具体内容参见《JavaScript权威指南》中译第5版相关章节“8.8.1 词法作用域”。JavaScript有非常强大的对象字面量表示法。这种表示法是JSON的灵感来源。原型继承是JavaScript中一个有争议的特性。 《ECMAScript编程语言》第3版定义了JavaScript的标准。ES3标准扩展：颜海镜大牛整理的ES3中文版颜海镜大牛整理的ES5中文版W3c ES5中文版阮一峰大牛的书籍《ES6标准入门2》更多内容可参见这篇文章：ECMAScript 2018 标准导读 一个简单的例子：1234Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125; 书中贯彻始终都会用到这个method方案，作者将会在第4章解释它。 第2章 语法本章主要用铁路图（语法图）表示语法。主要有：空白、标识符、数字、字符串、语句、表达式、字面量、函数。typeof 运算符产生的值有&#39;number&#39;, &#39;string&#39;,&#39;boolean&#39;,&#39;undefined&#39;,&#39;function&#39;,&#39;object&#39;。如果运算数是一个数组或者是null,那么结果是&#39;object&#39;,这其实是不对的。 第3章 对象JavaScript简单数据类型包括数字、字符串、布尔值，null值和undefined值。其他所有值都是对象。数组、字符串和布尔值“貌似”对象，因为它们拥有方法（包装对象），但它们是不可变的。对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的所有字符串，属性值可以是除了undefined值之外的任何值。 JavaScript包含一种原型链的特性，允许对象继承到另一个对象的属性。正确地使用它能减少对象初始化时的消耗的时间和内存。检索.,[]两种检索方式，推荐点.表示法。尝试重undefined的成员属性中取值将会导致TypeError异常，这时可以通过&amp;&amp;来避免错误。更新如果属性名已经存在对象里。那么属性的值会被替换。如果之前没有拥有那个属性名，那么该属性将被扩充到对象中。引用对象通过引用来传递。它们永远不会被复制。原型所有通过对象字面量创建的对象都链接到Object.prototype。创建新对象时，可以选择某个对象作为它的原型。1234567if (typeof Object.create !== &apos;function&apos;) &#123; Object.create = function(o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F(); &#125;;&#125; 原型连接只有在检索值的时候才被用到。如果尝试去获取对象的某个属性值，但对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到终点Object.prototype。如果想要的属性完全不存在原型链中，那么结果就是 undefined值。这个过程称为委托。原型关系是一种动态的关系。反射原型链上的所有属性都会产生值。有两种方案可以处理掉对象上不需要的属性。①程序检查时丢弃值为函数的属性。但有可能有些值确实是函数，所以该方法不可靠。②使用hasOwnProperty方法，如果是对象拥有独有的属性，则返回true。该方法不会检查原型链。枚举① for in可以遍历一个对象中所有的属性名。但包含函数和一些不关心的原型中属性。而且顺序不确定，可以用 hasOwnProperty方法和typeof排除函数。②for 循环不会出现for in那些情况。删除delete运算符可以用来删除对象的属性。减少全局变量的污染可以把全局性的资源纳入一个名称空间之下。这样做能减少冲突。 第4章 函数函数用于①代码复用②信息隐藏③组合调用。一般来说，所谓编程，就是将一组需求分节成一组函数与数据结构的技能。JavaScript的函数就是对象。函数对象连接到Function.prototype(该原型对象本身连接到Object.prototype)。每个函数在创建时会附加两个隐藏属性，函数的上下文和实现函数行为的代码。每个函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值为该函数的对象。函数字面量函数字面量包括4个部分。①保留字function②函数名，可以省略，③一组参数④一组语句。函数字面量可以出现在任何允许表达式出现的地方。一个内部函数除了可以访问自己的参数和变量，同时也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个连接到外部上下文的连接。这被称为闭包。调用除了声明时定义的形式参数，每一个函数还接收两个附加的参数：this和argument。在JavaScript中一共有四种调用模式。①方法调用模式，②函数调用模式③构造器调用模式④apply调用模式。 （this指向问题一直困扰很多人。我一般是这样记的，谁调用this就指向谁。） 方法调用模式对象的方法执行,this指向该对象。比如：1234567var myObj = &#123; value: 0, showValue: function() &#123; console.log(&apos;value:&apos;, this.value); &#125;&#125;myObj.showValue(); // value: 0 函数调用模式1234567var add = function(a,b) &#123; return a + b;&#125;add(3,4); //7window.add(3,4); //7// 这种this被绑定到全局对象（window）。// 可以理解是window.add(3,4); 有种简单的办法就是var that = this;把this存储下。例：123456789101112131415var myObj = &#123; value: 0, age: 20, showValue: function() &#123; console.log(&apos;value:&apos;,this.value); var that = this; var showAge = function() &#123; // window上没有age，所以是undefined console.log(&apos;这里的this是window ---age:&apos;, this.age); // undefined console.log(&apos;age:&apos;, that.age); // 20 &#125; showAge(); &#125;&#125;myObj.showValue(); // 0， undefined， 构造器调用模式JavaScript是一门基于原型继承的语言。如果在一个函数前面带上new 来调用。那么背地利将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。new 前缀也会改变return 语句的行为。例：1234567var Quo = function (string) &#123; this.status = string;&#125;Quo.prototype.get_status = function () &#123; return this.status; &#125;var myQuo = new Quo(&apos;confused&apos;); // &apos;confused&apos; 一个函数，如果创建的目的就是希望结合new 前缀来调用。那么它就被称为构造器函数。按照约定，它们保存在以大写函数命名的变量里。如果调用构造器函数时没有在前面加上new,可能会发生非常糟糕的事情，既没有编译时的警告，也没有运行时广告，所以大写约定非常重要。作者不推荐这种形式的构造器函数。有更好的替代方式。Apply调用模式JavaScript是一门函数式的面向对象编程语言，所以对象可以拥有方法。apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值。参数arguments，虽然拥有length属性，但不是真正的数组。而是类似数组（array-like）的对象。返回return 可用来是函数提前返回。当return 被执行时，函数立即返回而不再执行余下的语句。一个函数总会返回一个值，如果没指定，那就是返回undefined值。如果函数调用时在前面加上了new 前缀，且返回值不是一个对象，则返回this（该新对象）。异常JavaScript提供了一套异常处理机制。throw语句和try catch,try catch中finally是可选的。扩展类型的功能JavaScript允许给语言的基本类型扩充功能。在第3章中我们已经看到，可以通过Object.prototype添加方法，可以让该方法对所有对象都可用。这样的方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用。 例如：1234Function.prototype.method = function () &#123; this.prototype[name] = func; return this;&#125; 基本类型的原型是公用结构，所以在类库混用时务必小心。一个保险的做法就是只在确认没有该方法时才添加它。123456Function.prototype.methods = function(name, func) &#123; if (!this.prototype[name]) &#123; this.prototype[name] = func; &#125; return this;&#125; 递归递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，递归是用一般的方式去解决每一个子问题。书中举了一个汉诺塔的例子，是程序设计中经典递归问题。详细说明可以参见 百度百科“汉诺塔”词条。一些语言提供了尾递归优化。尾递归是一种在函数的最后执行调用语句的特殊形式的递归。参见Tail call。 ES6版本扩展了尾递归。参见阮一峰老师的《ES6标准入门》中的尾调用优化作用域在编程语言中，作用域控制着变量与参数的可见性和声明周期。书中指出当前JavaScript没有块级作用域。因为没有块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。不过ES6扩展了有块级作用域。闭包作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）。例子：123456&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 123456789101112131415// 点击相应节点时，显示对应的序号。可以使用闭包来解决。var add_the_handlers = function() &#123; var helper = function(i) &#123; return function(e) &#123; alert(i); &#125; &#125; var i; for (i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = helper(i); &#125;&#125;// 扩展 另外可以用let i = 0，或者把nodes类数组转成数组等方案实现。// 闭包特性：1、函数内再嵌套函数，2、内部函数可以调用外层的参数和变量，3、参数和变量不会被垃圾回收机制回收。// 闭包优点 灵活和方便，便于封装。缺点：空间浪费、内存泄露、性能消耗。 回调发起异步请求，提供一个当服务器响应到达时随即出发的回调函数。异步函数立即返回，这样客户端就不会被阻塞。模块我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。举例：给String添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换成对应的字符。12345678910111213141516String.method(&apos;deentityify&apos;, function () &#123; // 字符实体表。它映射字符实体的名字到对应的字符。 var entity = &#123; quot: &apos;&quot;&apos;, lt: &apos;&lt;&apos;, gt: &apos;&gt;&apos; &#125;; // 返回 deentityify方法 return function () &#123; return this.replace(/&amp;([^&amp;;]+);)/g, function (a,b) &#123; var r = entity[b]; return typeof r === &apos;string&apos;? r : a; &#125; &#125;;&#125;()); 模块模式利用了函数作用域和闭包来创建被绑定对象与私有成员的关联，在上面例子中，只有deentityify方法有权访问字符实体表这个数据对象。模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。 单例译注模块模式通常结合单例模式使用。JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化。更多内容参见：单例模式 级联有一些方法没有返回值。如果我们让这些方法返回this而不是undefined，就可以启用级联。在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。比如jQuery获取元素、操作样式、添加事件、添加动画等。柯里化柯里化，是把多参数函数转换为一系列单参数函数并进行调用的技术。更多详情可参见：柯里化函数也是值。柯里化允许我们把函数与传递给它的参数相结合，产生一个新的函数。12var add1 = add.curry(1);document.writeln(add1(6)); JavaScript并没有curry方法，但可以扩展该功能。arguments不是真正的数组，所以使用了Array.prototype.slice方法。12345678Function.method(&apos;curry&apos;,function()&#123; var slice = Array.prototype.slice, args = slice.apply(arguments), that = this; return function() &#123; return that.apply(null, args.concat(slice.apply(arguments))); &#125;&#125;); 记忆函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化称作记忆。比如说，我们想要一个递归函数来计算Fibonacci(斐波那契)数列，它的特点是，前面相邻两项之和等于后一项的值。更多参考：斐波那契。最前面两个数字是0和1。123var fibonacci = function() &#123; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125; 这样虽然能完成工作，但它做了很多无谓的工作。构造一个带有记忆功能的函数：1234567891011var memoizer = function(mome, formula) &#123; var recur = function(n) &#123; var result = meno[n]; if (typeof result !== &apos;number&apos;) &#123; result = formula(recur, n); meno[n] = result; &#125; return result; &#125;; return recur;&#125; 再用这个memoizer函数来定义fibonacci函数，提供其初始的memo数组和formula函数。123var fibonacci = memoizer([0,1],function(recur, n)&#123; return recur(n-1) + recur (n-2);&#125;) 极大的减少了我们的工作量。例如要产生一个记忆的阶乘函数，只需要提供基本的阶乘公式即可：123var factorial = meoizer([1,1], function(recur, n)&#123; return n * recur(n-1);&#125;); 第5章 继承伪类JavaScript的原型存在诸多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。Function构造器产生的函数对象会运行类似这样的一些代码：1this.prototype = &#123;constructor:this&#125; 新函数对象被赋予一个prototype属性，这个prototype对象是存放继承特征的地方。 当采用构造器调用模式，即用new前缀去调用一个函数时，函数执行的方式会被修改。如果new运算符是一个方法而不是一个运算符，它可能像这样执行： 12345678Function.method(&apos;new&apos;,function()&#123; // 创建一个新对象，它继承自构造器函数的原型对象。 var that = Object.create(this.prototype); // 调用构造器函数，绑定 -this- 到新对象上。 var other = this.apply(that,arguments); // 如果它的返回值不是一个对象，就返回该新对象。 return (typeof other === &apos;object&apos; &amp;&amp; other) || that;&#125;); 所有构造器函数都约定命名成大写字母。一种更好的备选方案就是根本不使用new。对象说明符就是指传多个参数时，可以直接传递一个对象。原型可以用Object.create方法构造出更多实例来。函数化迄今为止，我们所看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。我们无法得到私有变量和私有函数。幸运的是，我们有一个更好的选择，那就是应用模块模式。我们从构造一个生成对象的函数开始。我们以小写字母开头来命名。该函数包括以下四个步骤1、创建一个新对象。2、有选择地私有实例变量和方法。3、给这个新对象扩充方法。4、返回那个新对象。以下是一个函数化构造器的伪代码模板12345678var constructor = function (spec, my) &#123; var that, 其他的私有实例变量； my = my || &#123;&#125;; 把共享的变量和函数添加到my中 that = 一个新对象 添加给 that 的特权方法 return that;&#125; 函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们更好的封装和信息隐藏，以及访问父类方法的能力。部件我们可以从一套部件中把对象组装出来。 第6章 数组数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。数组是一种性能出色的数据结构。不幸的是，JavaScript没有像此类数组一样的数据结构。数组字面量对象字面量数组继承了Array.prototype大量有用的方法。而对象字面量是继承自Object.prototype。数组有length属性，而对象没有。长度每个数组都有一个length属性。可以直接设置length的值。设置更大的length不会给数组分配更多的空间，而设小导致所有下标大于等于新length的属性被删除。123var arr = [1,2,3];arr.length = 1;console.log(arr) // [1] 也可以通过length来通过添加值123var arr = [1,2,3];arr[arr.length] = 4;console.log(arr) // [1,2,3,4] 有时用push方法更方便。删除由于JavaScript的数组也是对象，所以delete运算符可以用来从数组中移出元素。移除后，长度不变，原位置上变成了undefined。可以使用Array.prototype.splice方法删除数组。枚举JS数组就是对象，所以for in语句可以用来遍历数据的所有属性。不过，for in无法保证属性顺序。并且可能从原型链中得到意外的属性。for循环可以避免以上问题。容易混淆的地方12typeof [] === &quot;object&quot;; // truetypeof &#123;&#125; === &quot;object&quot;; // true 识别是否是数组。1234// 方法一、var is_array = function (value) &#123; return value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Array;&#125;; 但它在识别从不同窗口（window）或帧（frame）里的构造的数组时会失败。有一个更好的方式：1234// 方法二、var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === &apos;[object Array]&apos;;&#125; 扩展：ES5 提供了Array.isArray()的方法。不过兼容性是IE9+。要做到兼容，可以用如下方法。MDN上提供的。MDN Array.isArray123456// 方法三、if (!Array.isArray)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; &#125;;&#125; 1234567var arr = [];// 方法四arr instanceof Array;// 方法五Array.prototype.isPrototypeOf(arr);// 方法六Object.getPrototypeOf(arr) === Array.prototype; 方法四、instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。方法五、isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。方法六、Object.getPrototypeOf() 方法返回指定对象的原型（即, 内部[[Prototype]]属性的值）。小结：除了方法二、三外，面对复杂的环境，其他的都不能准确的判断是否是数组。方法JavaScript提供了一套数组可用的方法，这些方法是被存储在Array.prototype中的函数。Object.prototype是可以扩充的。Array.prototype也是可以扩充的。ES5中提供的Object.create方法。这方法用在数组是没有意义的，因为它产生的是一个对象，而不是一个数组，产生的对象将继承这个数组的值和方法，但它没有length特殊属性。指定初始值JavaScript的数组通常不会预设值。书中写了一个循环来扩展，生成初始值。扩展：ES6中提供了fill来填充。比如：12345[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(0); // [0,0,0]new Array(3).fill(0); // [0,0,0]// fill方法还可以接受第二、第三个参数，用于指定填充的起始位置和结束位置（不包含）。new Array(3).fill(0,1,2); // [ ,0, ,] 空位不是undefined。空位没有任何值。ES6则是明确将空位转为undefined。 第7章 正则表达式正则表达式对字符串中的信息实现查找、替换和提取操作。可处理正则表达式的方法有regexp.exec、regexp.test、string.match、string.search和string.split。通常来说，正则相较于等效的字符串处理有着显著的性能优势。 一个例子12345// 正则表达式必须写在一行中var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;var url = &quot;http://www.ora.com:80/goodparts?q#fragment&quot;;var result = parse_url.exec(url);// …… 依次匹配到的是：12345678url: &apos;http://www.ora.com:80/goodparts?q#fragment&apos;,scheme: &apos;http&apos;,slash: &apos;//&apos;host: &apos;www.ora.com&apos;port:&apos;80&apos;path:&apos;goodparts&apos;query: &apos;q&apos;hash: &apos;fragment&apos; 个人扩展：这里推荐 在线测试正则表达式的网站regex101，默认是PHP语言，选择JavaScript语言。在线图形化RegExp工具MDN RegExp.prototype.exec()大概解释下这个正则，这里的^ 起始位置，$结束位置() 分组捕获 ?:不捕获.表示除换行以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，点(.)不能识别（ES6中加u修饰符才可识别），+表示一个或多个，*表示零个或多个，?表示0个或一个。[]表示或者，里面符合一个即可。\\d表示数字0-9。不严谨的正则表达式是一个常见的安全漏洞的发源地。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。 再看一个 匹配数字的例子。1234567var parse_number = /^-?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?$/i;parse_number.test(&apos;1&apos;); // trueparse_number.test(&apos;number&apos;); // falseparse_number.test(&apos;98.6&apos;); // trueparse_number.test(&apos;132.21.86.100&apos;); // falseparse_number.test(&apos;123.45E-67&apos;); // trueparse_number.test(&apos;123.45D-67&apos;); // false 结构有两个方法来创建一个RegExp对象。优先考虑的是正则表达式字面量，还有一种方式是new RegExp(&#39;&#39;,&#39;g&#39;)。正则表达式标识：g全局(匹配多次，不同的方法对g标识的处理防范各不相同)，i忽略大小写。m多行元素正则表达式分支|表示或，也表示分支 比如：1&apos;info&apos;.match(/in|int/) // 匹配成功，[&quot;in&quot;, index: 0, input: &quot;info&quot;] 正则表达式序列一个正则表达式序列饱和一个或多个正则表达式因子。每一个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，若没指定，这个因子则只匹配一次。正则表达式因子1\\ / [ ] () &#123; &#125; ? + * | . ^ $ 正则表达式转义\\ 表转义 \\f 分页 \\n 换行 \\r回车 \\t 制表\\u 允许制定一个 Unicode 字符来表示一个十六进制的常量。\\d 等同于[0-9] \\D 取反等同于 [^0-9]\\s Unicode 空白符一个不完全子集。 \\S 与\\s相反\\w [0-9A-Z_a-z] \\W 与其相反 [^0-9A-Z_a-z]\\b 表示 字边界\\1 表示 分组1所捕获的文本的一个引用，所以它能被再次匹配。\\2 表示 指向分组2的引用，\\3 是表示分组3的引用，以此类推。正则表达式分组捕获型()非捕获型?:向前正向匹配?=有一个(?=前缀。它类似于非捕获类型分组，但在这个组匹配后，文本会倒回到它它开始的地方，实际上并不匹配任何东西。也可以理解为匹配位置。向后负向匹配有一个(?!前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。正则表达式字符集正则表达式字符集是一种指定一组字符的便利方式。例如，要匹配一个元音字母，(?:a|e|i|o|u),可以方便的写成[aeiou]。类提供另外两个便利：①指定字符范围所以，一组由32个ASCII的特殊组合，可以写成[!-\\/:-@\\[-{-~]`②类的取反取反1[^!-\\/:-@\\[-`&#123;-~] 正则表达式字符转义字符类内部的转义规则和正则表达式因子的相比稍有不同。下面是在字符类中需要被转义的特殊字符。1- / [ \\ ] 正则表达式量词量词后缀决定正则表达式因子应该被匹配的次数。{3}三次{3,6} 3、4、5、6次{3,}3次或更多次?等同于{0,1}，*等同于{0,}，+等同于{1,}。 第8章 方法Arrayarray.concat(item…)concat 方法产生一个新数组，它包含一份array的浅复制并把一个或多个参数item附加在其后。如果item是数组，那么每个元素分别被添加。后面有和它功能类似的array.push(item...)方法。1234var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];var c = a.concat(b, true);// c =&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,true] 扩展： ES6 有更便捷的扩展运算符...123var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];var c = [...a,true,...b]; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, true, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;] array.join(separator)join方法把一个array构造成一个字符串。separator 默认值就是逗号&#39;,&#39;。如果你想把大量的字符串片段组装成一个字符串，把这些片段放在一个数组中，并用join方法连接起来通常比用+元素运算符连接起来要快。 译注：对于IE6/7，使用join连接大量字符串效率确实优于加号运算符。但目前主流浏览器，包括IE8以后的版本，都对+元素运算符连接字符串做了优化，性能已经显著高于Array.join()。所以目前大多数情况下，建议首选使用+ 连接字符串。更多参看《高性能网站建设进阶指南》中字符串优化相关章节。 array.pop()pop方法移除array中的最后一个元素，并返回这个元素。如果array为空，则返回undefined。1234567var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var c = a.pop(); // a 是 [&apos;a&apos;,&apos;b&apos;] c是 &apos;c&apos;// pop 可以像这样实现。// 这里的 Array.method()在第一章例子中已经定义了，并且贯穿全书。其实就是相当于Array.prototypeArray.method(&apos;pop&apos;, function () &#123; return this.splice(this.length-1,1)[0];&#125;); array.push(item…)与concat不同的是，它会修改array，如果参数item是数组，它会把参数数组作为单个元素整个添加到数组中。并返回这个array的新长度值。12345var a = [1,2,3];var b = [4,5,6];var c = a.push(b,true);// a 是 [1,2,3,[4,5,6],true]// c 是 5 push可以像这样实现：1234567Array.method(&apos;push&apos;, function () &#123; this.splice.apply( this, [this.length,0]. concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); array.reverse()reverse反转array元素顺序，并返回array本身。123var a = [1,2,3];var b = a.reverse();// a 和 b都是 [3,2,1] array.shift()shift移除array的第一个元素并返回这个元素。如果array为空，则返回undefined。shift通常比pop慢的多。12var a = [1,2,3];var c = a.shift(); // a 是[2,3] , c 是1 shift可以这样实现：123Array.method(&apos;shift&apos;, function()&#123; return this.splice(0,1)[0];&#125;); array.slice(start[, end])slice是对array中的一段做浅复制。end是可选的。默认是array.length,如果两个参数任何一个是负数，array.length会和相加。如果start大于array.length,获得一个[],字符串也有Sting.slice这个同名方法。array.sort默认不能给一组数字排序。默认把要被排序的元素都视为字符串。幸运的是，可以使用自己的比较函数替换默认的比较函数。比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。sort方法是不稳定的。JavaScript的sort方法的稳定性根据不同浏览器的实现而不一致。可参见MDN sortarray.splice(start, deleteCount,item…)splice方法从array中移除一个或多个元素，并用新的item替换它们。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// splice 可以像这样实现Array.method(&apos;splice&apos;,function (start, deleteCount) &#123; var max = Math.max, min = Math.min, delta, element, insertCount = max(arguments.length - 2, 0), k = 0, len = this.length, new_len, result = [], shift_count; start = start || 0; if (start &lt; 0) &#123; start += len; &#125; start = max(min(start, len), 0); deleteCount = max(min(typeof deleteCount === &apos;number&apos; ? deleteCount : len, len - start), 0); delta = insertCount - deleteCount; new_len = len + delta; while (k &lt; deleteCount) &#123; element = this[start + k]; if (element !== undefined) &#123; result[k] = element; &#125; k += 1; &#125; shift_count = len - start - deleteCount; if (delta &lt; 0) &#123; k = start + insertCount; while (shift_count) &#123; this[k] = this[k - delta]; k += 1; shift_count -= 1; &#125; this.length = new_len; &#125; else if (delta &gt; 0) &#123; k = 1; while (shift_count) &#123; this[new_len - k] = this[len - k]; k += 1; shift_count -= 1; &#125; this.length = new_len; &#125; for (k = 0; k &lt; insertCount; k += 1) &#123; this[start + k] = arguments[k + 2]; &#125; return result;&#125;); array.unshift(item…)unshift 方法像push方法一样，不过是用于把元素添加到数组的开始部分，返回新array的length。123456// unshift 可以像这样实现Array.method(&apos;unshift&apos;, function()&#123; this.splice.apply(this, [0,0].concat(Array.prototype.slice.apply(arguments))); return this.length;&#125;); Functionfunction.apply(thisArg,argArray)apply方法调用function,传递一个会被绑定到this上的对象和一个可选的数组作为参数。 Numbernumber.toExponential(fractionDigits)toExponential方法 把这个number转换成一个指数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。 number.toFixed(fractionDigits)toFixed方法把这个number转换成一个十进制数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。 number.toPrecision(precision)toPrecision方法把这个number转换成一个十进制数形式的字符串。可选参数控制数字的精度。它的值必须在0~21。 number.toString(radix)把number转换成字符串。可选参数控制基数。它的值必须是2~36。默认的radix是以10为基数的。radix参数最常用的是整数，但是它可以用任意的数字。 Objectobject.hasOwnProperty(name)如果这个object包含名为name的属性，那么返回true。原型链中的同名方法不会被检测。这个方法对name就是“hasOwnProperty”时不起作用。 RegExpregexp.exec(string)exec是正则中最强大(和最慢）的方法。如果成功匹配，它会返回一个数组。下标为0 的元素包含正则匹配的子字符串。下标为1的则是分组1捕获的文本。下标为2的则是分组2捕获的文本。以此类推。如果匹配失败则返回null。regexp.test(string)test是最简单(和最快)的方法。匹配成功，返回true,否则返回false。不要对这个方法使用g标识。比如：12345678var reg = /\\w+/g;reg.test(&apos;ab&apos;); // true// 再执行一遍就是false了。reg.test(&apos;ab&apos;); // false// 再执行一遍就是true了。reg.test(&apos;ab&apos;); // true// 再执行一遍又是false了，如此反复，所以用g标识后，看起来很诡异。应该每次匹配开始位置变了。reg.test(&apos;ab&apos;); // false test可以像这样实现：123RegExp.method(&apos;test&apos;, function(string)&#123; return this.exec(string) !== null;&#125;); Stringstring.charAt(pos)返回在string中的pos位置处的字符。 string.charCodeAt(pos)与charAt一样，不过返回整数形式表示字符码位。 string.concat(string)很少用，用+号运算符更方便。 string.indexOf(searchString,position)在string中查找第一个参数，如果被找到返回该字符的位置，否则返回-1。position可设置指定位置开始查找。 string.lastIndexOf(searchString,position)lastIndexOf 方法和indexOf方法类似，不过它是从末尾开始查找，不是从头开始。 string.localeCompare(that)比较两个字符串。类似于array.sort。 string.match(regexp)如果没有g标识，那么调用string.match(regexp)和调用regexp.exec(string)结果相同。如果带有g标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组。 string.replace(searchValue,replaceValue)对string进行查找和替换操作，并返回一个新的字符串。参数searchvalue可以是一个字符串也可以是一个正则表达式对象。参数replaceValue可以是一个字符串或一个函数。 string.search(regexp)和indexOf类似，不过它接收正则为参数。 string.slice(start, end)slice方法复制string的一部分来构造一个新的字符串。如果start参数是负数，它将与string.length相加。end参数是可选的。 string.split(separator,limit)把string分割成片段来创建一个字符串数组。可选参数limit可以限制分割的片段数量。separator参数可以是字符串或者正则。string.substring(start,end)与slice方法一样，不过它不能处理负数参数。string.toLocaleLowerCase()它使用本地化的规则把这个string中的字母转换成小写格式。这个方法主要用在土耳其语上。string.toLocaleUpperCase()它使用本地化的规则把这个string中的字母转换成大写格式。这个方法主要用在土耳其语上。string.toLowerCase()返回新字符串，所有字母转成小写格式。string.toUpperCase()返回新字符串，所有字母转成大写格式。String.fromCharCode(char…)根据一串数字编码返回一个字符串。1var a = String.fromCharCode(67,97,116) // a是&apos;Cat&apos; 第9章 代码风格这一章中，简短的说了一些代码风格。事实证明代码风格在编程中是很重要的。 第10章 优美的特性精简的JavaScript里都是好东西。包括：1、函数是顶级对象；2、基于原型继承的动态作用域；3、对象字面量和数组字面量。 到此，读书笔记已完结。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/tags/读书笔记/"}],"keywords":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lxchuan12.github.io/categories/读书笔记/"}]},{"title":"工作一年后，我有些感悟","slug":"20170602-After a year's work, I had some insights","date":"2017-06-02T14:20:53.000Z","updated":"2017-06-24T15:24:29.479Z","comments":true,"path":"2017/06/02/20170602-After a year's work, I had some insights/","link":"","permalink":"https://lxchuan12.github.io/2017/06/02/20170602-After a year's work, I had some insights/","excerpt":"去年6月1日，入职那天早上下着小雨。在公司取了一个花名：轩辕，后来把网上昵称基本都改成了轩辕Rowboat。还记得那天晚上朋友请我吃小龙虾。 今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。","text":"去年6月1日，入职那天早上下着小雨。在公司取了一个花名：轩辕，后来把网上昵称基本都改成了轩辕Rowboat。还记得那天晚上朋友请我吃小龙虾。 今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。 学习工作从校园到职场 主动认识同事。 虽然不太可能与每一个同事都能相处的特别熟。但对于新人，都会被拉入一些群。这时候，可以加同事QQ或者微信等（同事一般不会拒绝），便于之后沟通交流工作。 这时候有的人能够主动快速得认识团队里的同事。有的人则是入职了很久都不认识对面的同事。 把离别看得平淡了许多。大学毕业后，很多人一晃一年没见，是再正常不过的事了。 同事离职后，即使还在同一个城市，但交集就变少了。 有江湖的地方就有规矩，职场也有。在职场只要用心去发现，能够学到公司的管理方式等。 认清自己的定位 常和别人开玩笑说，自己是来自贫困的小山村的一个大学生，职业是：说的高端一点是前端开发工程师，说的通俗易懂点则是做网站的程序猿。嗯，这就算是一种定位。 像我这样的人几百万。想起一个朋友说：感觉你在IT方面很厉害。我说：你只是认识万千程序猿中的一个而已。 学无止境，提升竞争力 智联招聘网显示：web前端开发是竞争最激烈的职业。 上次听一次segmentfault的讲堂，其中有提到慕课网有很多用户，其中400万是前端开发。 有时候会想我这一年是不是学习方式不对，不够努力，或者说能否再努力一点，是不是能够进入更好的大公司，能够得到更好的成长。 事实证明，自身能力不够，有机遇来了，会抓不住。 比如：之前有面试过淘宝、大搜车等，然而技术一般，没能通过面试。 现实生活我读大学买了电脑考了驾照，四年花了家里4万块左右（从大一暑假买电脑开始算到大四结束，用Excel统计家里打了25200元给我）。而在杭州待一年光吃住就得花近3万块（吃饭按一天40元算，一个月1200，租房1100+）。 最近看的电视剧《欢乐颂2》中，身为90后的程序猿应勤在大上海买了车买了房（好像还提到是全额付款）。现实中在大上海房价均价5.5万/平米，有人分析单靠程序猿那点工资（虽然IT行业相对其他行业薪资高些）是不太可能的。 展望未来看到毕业几年的同事过着怎样的生活，可以推测出几年后的自己大概过着怎样的生活。当然未来的一切都是未知的。但基本能看出自己一年后是过着怎样的生活。 月薪两万的薪资算是很不错了，但是在大城市算刚起步，为什么算刚起步，主要因为房价太高，买个房好几百万。比较优秀的前端开发工程师，工作三年后月薪大概能达到15K—20K，当然各城市不一。再往后，能达到年薪50万左右已经是非常不错了。 如何提高收入，是大家关心的永恒的话题。5月份我们从学校课题组出来的三个同学回学校时，在高铁上上讨论过，毕业一年有什么感觉，大家都一致认为：要想单靠开发这点薪资，在大城市立足，是非常艰难的。然后想着有哪些赚钱之道，都可以去试试，刚毕业一年，还算很早。 主要说到三条。第一条是：加入有潜力的团队初创公司（拿股份）。同学就说到他们老大的事迹，说刚靠程序猿这点工资在大城市过上小资生活是很艰难的，他之前加入阿里后来拿股份才开了现在的公司（大概意思是这样）。 第二条是：拓展自己的人脉，找准风口，好创意，自己组建团队开发出有价值的产品。说到这条我就提到小密圈（付费圈子，我加入一个圈子收费200，有700+人加入，运营一年，就能得到14万的收入。） 我自己也建了一个前端视野的小密圈（免费），发发自己关于前端开发的所见所想，也好沉淀沉淀，没打算怎么推广，但这里还是贴一下二维码，万一有人想加入呢。 。 [前端视野-小密圈-一个人走得快，一群人走得远] 前端视野-小密圈-一个人走得快，一群人走得远还建有一个PPT视野的圈子，这个目前还没发过动态。 第三条则是：发展一项兴趣爱好，打造个人品牌，做到可以赚大钱的地步。（有人刚毕业4K，毕业三年，凭借PPT，开商务PPT训练营收费课程，年薪50万）。他们经常问我可以多接些PPT来做，就可以赚点钱了，我说目前没有时间，也没有渠道，而且我也是只是万千PPT设计师中很渣的一员。 想做到收入更高，除了做好本职工作和提升专业素养外，也需要跳出来看看外面的世界。 上次和同学几人一起玩的时候，有个妹纸说了这句，何以解忧，唯有暴富。让我记忆犹新。 事实上群体中确实有小概率事件发生，比如中个上千万的彩票，但是对于个体，这种事几乎不可能发生。而且有研究表明，中彩票的普通人，一般会在五年后用完这笔财富，最后还是普通人。 所以说：提高自己在各方面的竞争力，比如：为人处事、沟通表达、团队协作等等，这也就是可迁移能力，以不变应对这个变化的世界，才是最重要的。 这是我写在简书的文章：工作一年后，我有些感悟","categories":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/tags/随笔/"},{"name":"感悟","slug":"感悟","permalink":"https://lxchuan12.github.io/tags/感悟/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://lxchuan12.github.io/categories/随笔/"}]},{"title":"如何破解百度网盘下载限制及网盘搜索技巧","slug":"20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips","date":"2017-03-17T14:52:23.000Z","updated":"2017-06-24T15:22:02.618Z","comments":true,"path":"2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/","link":"","permalink":"https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/","excerpt":"今天两个朋友问我如何选电脑的问题，我说了一些大概流程，需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买。其实我好久没有关注这方面了，毕竟没钱买电脑。晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。","text":"今天两个朋友问我如何选电脑的问题，我说了一些大概流程，需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买。其实我好久没有关注这方面了，毕竟没钱买电脑。晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。大学里也会去图书馆看看纸质的。然后找到 2017年《电脑报》的看了一会。看到一篇《如何破解百度网盘下载限制》的文章，我试过后有效，特来分享整理给大家。在chrome浏览器中，新建一个书签，书签名字随意，书签的网址复制粘贴这段代码：javascript:navigator.__defineGetter__ (&#39;platform&#39;,function(){return &#39;&#39;}); 它的作用是防止下载大文件时唤醒百度网盘客户端。 所以在点击“下载”前，先点击它。待开始下载后，打开浏览器的“下载内容”（快捷键：Ctrl+J），看到正在进行的下载任务选择“复制链接地址”。 右击复制链接地址.png 将地址粘贴到迅雷极速版下载，官方好像不提供下载链接了，这里推荐百度软件中心下载地址http://rj.baidu.com/soft/detail/26860.html ,点击普通下载即可，这样就可以了。 虽然速度不是非常稳定但至少比百度云盘PC客户端几十KB／s快。不建议大家再安装破解版，有钱还是买个会员吧，或者干脆上NAS。 可能有小伙伴好奇我是如何找到2017年的《电脑报》的。 搜百度盘.png 这时分享几个网盘搜索网站： （常用）搜百度盘：http://www.sobaidupan.com 搜索“罗小川chuan”结果.png 搜索“罗小川chuan”结果，可怕，我得赶紧取消一些个人信息的公开分享了。 盘搜网：http://www.pansou.com/搜盘网：http://www.soupan.info/ 之前书签里保存的网盘搜索网站.png 等等，其他就不附链接了。","categories":[{"name":"网盘搜索","slug":"网盘搜索","permalink":"https://lxchuan12.github.io/categories/网盘搜索/"}],"tags":[{"name":"window","slug":"window","permalink":"https://lxchuan12.github.io/tags/window/"},{"name":"skyDrive","slug":"skyDrive","permalink":"https://lxchuan12.github.io/tags/skyDrive/"},{"name":"Baidu","slug":"Baidu","permalink":"https://lxchuan12.github.io/tags/Baidu/"}],"keywords":[{"name":"网盘搜索","slug":"网盘搜索","permalink":"https://lxchuan12.github.io/categories/网盘搜索/"}]},{"title":"简单实用免费的shadowsocks翻墙技巧","slug":"20170306-freess","date":"2017-03-06T15:02:23.000Z","updated":"2017-08-08T14:19:01.371Z","comments":true,"path":"2017/03/06/20170306-freess/","link":"","permalink":"https://lxchuan12.github.io/2017/03/06/20170306-freess/","excerpt":"开发时遇到问题，一般都是使用谷歌搜索，相对百度更加精准一些。比如搜索我的网名轩辕Rowboat，一大堆结果。","text":"开发时遇到问题，一般都是使用谷歌搜索，相对百度更加精准一些。比如搜索我的网名轩辕Rowboat，一大堆结果。 谷歌搜索轩辕Rowboat结果.png 谷歌书签同步，YouTube等等。总是需要翻墙的。一次偶然的机会发现了这个网站，FreeSS-最好用的免费SS提供站点（提供免费的ss账号）（免费为它打广告~）觉得好东西要分享给大家，于是写下这篇文章（当然我觉得很多人都会，但还是写了）。 1、下载shadowsocks（Mac，Android等可以下载相应版本）：windows各版本下载地址：https://github.com/shadowsocks/shadowsocks-windows/releases，这网址一般不会是失效。一般下载最新的Downloads-&gt;Shadowsocks-xxx.zip即可。 Mac，Android等可以在这个链接下载：https://github.com/shadowsocks我下载的是:3.4.3.zip版本 ，软件一直在持续更新，链接可能会失效。解压到电脑任意位置，点击打开Shadowsocks.exe程序，程序图标会出现在右下角。 2、打开这个网站http://freess.org/ ，配置打开任意一个二维码。右键程序图标，弹出菜单中选择“服务器”－“扫描屏幕上的二维码”，扫描成功后会自动配置，菜单中勾选“启用系统代理”即可。这时就可以使用任意浏览器翻墙了。不过这个免费的ss账号（目前可用），只限当天使用，次日得重新扫描。 编辑服务器 配置截图 当然只想用谷歌搜索不一定要翻墙，可以使用谷歌镜像搜索。（网上有一些谷歌镜像站，不过有一定局限性，也有一些可用谷歌学术搜索镜像）。 可能遇到问题：如果碰到打开时提示，版本过低。 版本过低.png 下载安装.netframework下载地址链接 更多使用说明可以查看：官方中文说明文档比如：配合谷歌插件（SwitchyOmega ）共同使用，可以做到系统代理和直接连接，自动切换，就不容易导致开了代理，连接不需要代理的网站异常了。SwitchyOmega插件下载安装地址 小胡子哥的文章：Shadowsocks 原理简介及安装指南","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lxchuan12.github.io/categories/shadowsocks/"}],"tags":[{"name":"window","slug":"window","permalink":"https://lxchuan12.github.io/tags/window/"}],"keywords":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lxchuan12.github.io/categories/shadowsocks/"}]},{"title":"vue1.0和2.0的区别","slug":"20170212-The difference between vue1.0 and 2","date":"2017-02-12T07:04:23.000Z","updated":"2017-06-24T15:23:28.738Z","comments":true,"path":"2017/02/12/20170212-The difference between vue1.0 and 2/","link":"","permalink":"https://lxchuan12.github.io/2017/02/12/20170212-The difference between vue1.0 and 2/","excerpt":"重新仔细读了下文档，边看边写了一些。1、v-once只渲染一次。2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。全局过滤器和单个过滤器。","text":"重新仔细读了下文档，边看边写了一些。1、v-once只渲染一次。2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。全局过滤器和单个过滤器。1234&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 1&#123;&#123; message | filterA | filterB &#125;&#125; 1&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125; 3、watch允许异步操作。computed做不到。4、新增：v-else-if5、v-if中，使用 key 控制元素的可重用6、v-for (value,index)，$index被废除。 item in items,item of items.123&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 7、track-by=”$index”被废用，用key替代。（就地复用）7.1、template中不能使用this不是。data.a=1,template,直接写a即可。8、2.1.4新增9、2.1.0 新增可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。1234.ctrl.alt.shift.meta 10、修饰符lazy,number,trim11、组件中data 必须是函数123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 123&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 12、自定义事件，废除了events、$dispatch、$broadcast。使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件13、给组件绑定原生事件-修饰符.native1&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt; 使用自定义事件的表单输入组件14、非父子组件通信。15、slot分发内容。16、动态组件，参考：[译]Vue 动态组件17、子组件索引ref123456&lt;div id=&quot;parent&quot;&gt; &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)// 访问子组件var child = parent.$refs.profile 18、使用 v-once 的低级静态组件19、列表过渡,tag,v-movejQuery Event.stopImmediatePropagation() 函数详解 stopImmediatePropagation()函数用于阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。","categories":[{"name":"vue","slug":"vue","permalink":"https://lxchuan12.github.io/categories/vue/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://lxchuan12.github.io/tags/vuejs/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lxchuan12.github.io/categories/vue/"}]},{"title":"2016年度总结，毕业，工作","slug":"20170107-2016-annual-summary","date":"2017-01-07T13:40:38.000Z","updated":"2017-06-24T15:25:20.635Z","comments":true,"path":"2017/01/07/20170107-2016-annual-summary/","link":"","permalink":"https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/","excerpt":"1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。","text":"1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。 时间总是那么的快。2014年开始，就有了写个人年度总结的习惯。如果把2015年定义成PPT年，那么2016年则可以说是开发年。这一年相对比较平凡，还算满意。 2015年的年底，准备好了提前答辩的相关事宜。2016年元旦放假三天，在学校的课题组办公室翻看着微博（微博有时间轴，可以看到每个月都发了什么，这也就是为什么我比较喜欢发微博的原因之一），做着PPT，用思维导图工具Xmind，写着年度总结——《2015年总结，淡化旧标签，无惧未来 》。 翻看2016年的微博，看到大年初三的一条这样写着： 猴年初三（2月10日），去舅舅家拜年。舅舅极力要求我在他家住，说以后工作了，忙着赚钱，更是没什么时间住了。舅妈以为我还是21岁……然而过完年，虚岁就是24岁了，其实明明是22岁半。好吧，确实老了。到了尴尬的年纪。按这样算，还有6年就30岁了……这六年要赚好多钱。 最近听喜马拉雅付费精品中关于年度计划的，提到人生的8个方面,分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。于是根据这个把自己的2016年总结整理了一张思维导图和仿支付宝年账单做了一份年度总结PPT。 2016年度总结思维导图 2016年度总结PPT 未来的路在哪1、看周围同事，基本就能看到自己几年后是过着怎样的生活。试想这样的生活是不是自己想要的，如果不是又将做什么来改变呢。老板有时给我们开会也会问：一个员工加入一家公司终究会离开，你是否会认真考虑【我会在这里干多少年？想成为什么样的人】。2、再看看自己的校友，在移动互联网领域比较出名的有杜瑶，CSS参考手册作者（css.doyoe.com），去哪儿网前端技术总监。猎豹移动副总裁陈勇。柴魁元,乐动卓越科技有限公司CTO等等。3、如果仅从开发这条路来看，很容易看到自己的天花板。而且业界都一致认为，程序员是吃青春饭，看自己身边同事就知道年长的非常少。G20放假那次回家，跟老爸聊天，老爸聊到年轻的时候赚点钱容易，年纪大了就不容易了。何况你这工作吃的是青春饭，以后怎么办。我说：到时候再看，转行吧。比如这篇文章：一位工作十年程序员给的忠告 打造个人品牌（知识型IP）《程序员必读的职业规划书》有提到打造个人品牌；公司年中大会上，我司创始人（前阿里副总裁）也谈到IP；参加的网红经济论坛上更是对网红（IP）有一些深层次的解读；《和秋叶一起学职场技能》书中也有提到如何打造个人品牌。虽然，以前的积累，微博粉丝超过了1千，微信好友快1000，两个QQ的好友基本不重复，超过1400，但这些都是最低层次的无门槛自媒体。 我这名字，在我关注的圈子中，知道比较有名的大咖有小川叔。在公司叫花名（轩辕），于是把我在网络上的各种账号的昵称统一成轩辕Rowboat，也算是打造个人品牌的开始吧。 2016年，这一年出现了很多知识变现的产品，比如：微信公众号打赏，简书打赏，知乎live，分答，在行，微博的问答，喜马拉雅付费精品等。 原是程序员的彭小六就凭借着知识变现这一红利月入6位数。比如：《凭着这3个字，我上个月挣了6位数》也有程序员靠之前人气等多方面的积累，开一次知乎live，分享知识，就能赚1万+。之前在公众号看到的文章，《月入10W真的很难吗？》清华大学毕业阿何的一篇文章：《年轻人，如何挣到自己第一个100万？》文尾总结： 总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤：第一：找到自己的一个特长，把它培养得足够出色第二：找到适合你的特长，又有足够用户注意的平台第三：在这个平台上深耕细作，打造品牌，获得收入每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。 虽然这类文章有点夸大其词，鸡汤文的感觉，但也不无道理。总之这是赚钱思维的一种转变。 PPT圈内，布衣公子从2012年开始分享自己的PPT作品，他的作品影响着很多人。后来收费，一份作品就能卖到上万元。这是他分享他的故事时分享的五个故事。改变我命运的五个故事-布衣公子要在大城市生活，培养一种或几种可以「变现」的能力，并且这些能力不受地域的限制，似乎变得重要起来。 时间也是资源时间管理是永恒的话题，这篇文章写的挺好：毕业三年，你如何与同龄人拉开差距？ 世界发展太快，需要不断学习世界在发展，以前的很多岗位都不存在了。而且未来很多工作可以由机器人来完成，而且机器人比人类做得更优秀。另外年轻人的接触新鲜事物的学习能力相对比较强。那么持续学习，变得更加的重要了。","categories":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/tags/年度总结/"}],"keywords":[{"name":"年度总结","slug":"年度总结","permalink":"https://lxchuan12.github.io/categories/年度总结/"}]},{"title":"提高效率的webstorm技巧","slug":"20161207-webstrom-skill","date":"2016-12-07T14:48:18.000Z","updated":"2017-06-24T15:25:56.187Z","comments":true,"path":"2016/12/07/20161207-webstrom-skill/","link":"","permalink":"https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/","excerpt":"webstrom有一些基本的操作1、快速查找2、代码补全3、版本控制4、本地历史5、即时模板6、光标7、代码格式化等","text":"webstrom有一些基本的操作1、快速查找2、代码补全3、版本控制4、本地历史5、即时模板6、光标7、代码格式化等 基本操作双击shift搜索：快速查找。文件，函数名等。 template模板可以设置。 光标定位到相关位置。比如tilte,body每次修改的历史：local history。 多光标的功能。1、查找替换，ctrl+R2、alt+鼠标选择。 3、alt+单击。 4、格式化代码：ctrl+alt+L 菜单，code——reformat code。 5、快捷键可以自定义设置。 可以通过快捷键名称来查找。也可以通过怎么使用来查找快捷键，然后对其进行修改。webstrom预设了许多快捷键，可以自己选择。与原来的IDE快捷键相同。 Emmet详情参见：Emmet：HTML/CSS代码快速编写神器 1、Tab键，缩写的补全2、li中间写完，按enter键，光标直接定位到接下来的一个。3、嵌套结构：> + ^ ()子元素，同级，往上一级，重复，（）4、属性# （id）. （类）[]自定义属性div#container.container $ul&gt;li.item-$5{}文本p{click me}lorem没有意义的文字。用于排版。用法：lorem100注意事项：光标定位在最后（最想展开的）。不能有空格。比如：css中，bt:border-topm10:margin:10px;m10-20:margin:10px 20px;bdrs10:border-radius:10px;df：display：flex; 设置前缀。默认关闭这个开关。可以用其他工具来实现。、html:5,sublime text等编辑器可以安装emmet插件。 进阶操作一——常见快捷键操作，快捷键。 光标放在相对应的标签上，按F1，可以显示相关的描述，关联的站点等。js也是如此，参数列表等。比如 hello world要包裹在一个div中，选择这代码，ctrl+alt+T,选择第一个，输入div就变包裹在div中。 ——71、注释与取消注释ctrl+/2、选择选中子元素，alt+上/下3、粘贴ctrl+shift+V，最近粘贴板中的内容。4、删除当前行，ctrl+退格键。5、当前行上、下面加入一行上面加入一行。ctrl+alt+enter下面加入一行。ctrl+shift+enter.这样不需要刻意定位光标的位置。其实键盘上有（home,end)键。6、折叠代码，ctrl++（展开），ctrl+-(折叠)ctrl+shift++,ctrl+shift+-,所有可以折叠的地方全部折叠。在css中，js,html中都是如此。7、相邻位置代码换位置。alt+shift+上、下键。选中一段代码也可以让其上下移动。8、闭合标签，定位在两个标签位置。ctrl+m键。引号，括号，{}等也适用。window下好像无效。9、前进、后退到上一次编辑的地方。ctrl+alt+左右键。10、转到上一次编辑的地方。ctrl+shift+backspace键。11、最近使用的文件，ctrl+E——81、img标签，知道图片宽和高。方式1、输入路径，宽和高，按住Tab键可以自动补全。方式2、放在图片上，按F1图片预览，固定预览框。或者悬浮在文字上方。方式3、按住shift，鼠标浮在路径上，就可以看到图片的预览了。2、color:#999;色块上点击即可选择修改颜色。亮度（竖向）和透明度（横向）可以调节。 进阶操作二——重命名1、重命名， hello world，把光标放在标签上，ctrl+T,第一个就是重命名。window下试用无效。shift+F6重命名。2、其实直接写即可呀。对话框会显示有相同的地方，右击，排查或包含include，exclude.点击执行，do refactor。侧边有一些功能。2、函数名称，参数重命名。html,css,js中都可以重命名，类名，颜色，可以预览，避免把一些框架库里的相同东西修改了。、文件或文件夹也可以重命名。所有引用的地方也被修改了。 进阶操作三——代码检查webstrom使用了静态代码分析。不仅检查编译错误，而且代码效率低下，未使用的代码，非本地化的字符串，无法解析的代码，内存泄露，甚至编写问题等等。提示分为：错误，警告和正确。红色，橙黄色，或者绿色。一般来说是对整个项目进行检查的。也可以自己配置检查的范围。也可以自己运行检查。–&gt;code-&gt;Inspect code webstrom检查出来的不代表真的有错，还需要人工自己检查。一般在文件中，F2键可以在各个错误中切换。alt+enter，可以看到提示。（右侧的提示）规则自己设置，搜索inspec js是静态的校验。","categories":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/tags/tool/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://lxchuan12.github.io/categories/tool/"}]},{"title":"关于我","slug":"20161120-about me","date":"2016-11-20T14:36:52.000Z","updated":"2017-11-20T15:13:10.891Z","comments":true,"path":"2016/11/20/20161120-about me/","link":"","permalink":"https://lxchuan12.github.io/2016/11/20/20161120-about me/","excerpt":"","text":"简介某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。 家乡在很久很久以前，盘古开天辟地之时，后来…不知道经过了多少年。轩辕Rowboat，出生于江西吉安欧阳修故里的一个贫困的小山村，究竟有多贫困呢，各地贫困指数不一，就不得而知了。你们只需要知道小马云，就是来自我们的小县城上的一个镇上。百度百科词条：小马云 怎么走上前端路的再后来，我一不小心来到了某世界闻名的陶瓷大学拜师学艺，当然可想而知，不是学的的陶瓷相关技艺。拜师学艺期间，遇见两位”师傅”，和其他两名弟子一同学习PHP+MySql，从此开始了我的Web开发学习之路，也有一些成果。再一不小心玩起了PPT，后来发现自己更加喜欢前端，期间又听说有个叫网易的招收前端开发微专业三期弟子，于是走向了这条漫漫前端路。一眨眼，四年过去了。2016年，下山来到了杭州闯江湖。深知时代在迅速发展，需不断学习。欲知更多详情请让鼠标走两步，看此文我是如何踏上前端这条路的。 联系我工作一年后，我有些感悟 这篇文章里有知识星球【前端视野】二维码，主要发表一些前端所见所想，一个人走得快，一群人走得远。欢迎扫码免费加入。 微博，偶尔在微博上更新日常。segmentfault社区，偶尔在SF社区答题，目前只有少得可伶的1.8K声望。简书，偶尔在简书上写写文章。知乎，偶尔逛逛知乎，看帖基本不回帖。微信嘛，很显然，一般人不会加我，但万一不是一般人呢，还是写下微信号，注明验证。微信：lxchuan12。","categories":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/categories/关于我/"}],"tags":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/tags/关于我/"}],"keywords":[{"name":"关于我","slug":"关于我","permalink":"https://lxchuan12.github.io/categories/关于我/"}]},{"title":"数组方法splice和数组去重","slug":"20161029-array-splice-uniq","date":"2016-10-29T14:08:18.000Z","updated":"2016-10-29T15:47:36.020Z","comments":true,"path":"2016/10/29/20161029-array-splice-uniq/","link":"","permalink":"https://lxchuan12.github.io/2016/10/29/20161029-array-splice-uniq/","excerpt":"splice方法有删除、替换、添加的功能。修改原数组……","text":"splice方法有删除、替换、添加的功能。修改原数组…… 语法：array.splice(start, deleteCount[, item1[, item2[, …]]]) start整数，如果大于数组长度，itemN有值则为添加否则不添加。12345var arr=[1,2,3];//arr.splice(4,2);//console.log(arr);//[1,2,3]arr.splice(4,2,2);console.log(arr);//[1,2,3,2] 如果为负数，则从数组末尾倒数第一位。detecount整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。itemN要添加进数组的元素。如果不指定，则 splice() 只删除数组元素。返回值由被删除的元素组成的一个数组。未删除就是返回空数组。 删除123var arr=[1,2,3];arr.splice(1,2);console.log(arr);//[1] 替换123var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.splice(1,2,&apos;2&apos;,&apos;3&apos;);console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;] 添加123var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];arr.splice(1,0,&apos;2&apos;,&apos;3&apos;);console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;，&apos;b&apos;,&apos;c&apos;] 数组去重题目：牛客网数组去重试题为 Array 对象添加一个去除重复项的方法 输入例子：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’, ‘a’, NaN].uniq()输出例子：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’] 解答：12345678910111213Array.prototype.uniq = function () &#123; var hasNaN = false; for(var i=0;i&lt;this.length;i++)&#123; if(this[i]!==this[i])hasNaN=true; for(var j=i+1;j&lt;this.length;j++)&#123; if(this[i]===this[j]||(hasNaN&amp;&amp;this[j]!==this[j]))&#123; this.splice(j,1); j--; &#125; &#125; &#125; return this;&#125; 较复杂的数组，一般思路是先判断类型再做去重。参考资料：MDN:Array.prototype.splice()js删除数组里的某个元素从 JavaScript 数组去重谈性能优化(玉伯)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"(转)背景图片固定不随内容滚动而滚动","slug":"20161016-background-attachment","date":"2016-10-16T14:48:38.000Z","updated":"2016-10-17T12:48:14.594Z","comments":true,"path":"2016/10/16/20161016-background-attachment/","link":"","permalink":"https://lxchuan12.github.io/2016/10/16/20161016-background-attachment/","excerpt":"有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法……","text":"有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法…… 第一种：背景附着属性(background-attachment)，代码如下：123456789101112131415&lt;html&gt;&lt;head&gt;&lt;title&gt;背景附着属性 background-attachment&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg); background-repeat:no-repeat; background-attachment:fixed&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-attachment属性，将背景图片固定，不随内容滚动而滚动。&lt;p&gt;&lt;p&gt;背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。&lt;/p&gt;&lt;p&gt;background-attachment要和background-image一起用。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第二种：背景位置属性(background-position)，代码如下：123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;背景位置属性 background-position&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg);background-repeat:no-repeat; background-position:20px 60px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-position属性。这个属性和background-image属性连在一起使用，决定了背景图片的最初位置。&lt;/p&gt;&lt;p&gt;上面的代码表示背景图片的初始位置距离网页最左面20px，距离网页最上面60px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第三种：背景属性(background)，代码如下：12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;背景属性 background&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background:#99FF00 url(../images/css_tutorials/background.jpg) no-repeat fixed 40px 100px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个属性是设置背景相关属性的一种快捷的综合写法， 包括background-color, background-image, background-repeat, backgroundattachment, background-position。&lt;/p&gt;&lt;p&gt;这个HTML所用的背景属性表示，网页的背景颜色是翠绿色，背景图片是background.jpg图片，背景图片不重复显示，背景图片不随内容滚动而动，背景图片距离网页最左面40px，距离网页最上面100px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 原文：背景图片固定不随内容滚动而滚动源自今日头条2017前端工程师实习生笔试题12345675、下面哪条声明能固定背景图片（）正确答案: A 你的答案: A (正确)background-attachment:fixed;background-attachment:scroll;background-origin: initial;background-clip: initial; ——————————————————————————置换元素与非置换元素a) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。b) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。 12345674、请选出所有的置换元素（）正确答案: A B C D 你的答案: A B C D (正确)A、imgB、inputC、textareaD、select","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"函数的length属性","slug":"20161009-function-length","date":"2016-10-09T13:30:12.000Z","updated":"2016-10-17T12:50:41.889Z","comments":true,"path":"2016/10/09/20161009-function-length/","link":"","permalink":"https://lxchuan12.github.io/2016/10/09/20161009-function-length/","excerpt":"看《ES6标准入门》中提到函数的length属性，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……","text":"看《ES6标准入门》中提到函数的length属性，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……查阅了MDN Function.length是这样描述的： length 是函数对象的一个属性值，指明该函数期望多少个参数，意即形参的个数。数量不包括剩余参数。相比之下，arguments.length 是函数被调用时实际传参的个数。 12345function test(a,b,c) &#123;&#125;test.length // 3function test(a,b,c,d) &#123;&#125;test.length // 4 看起来很简单，但是也有特殊的，如果函数内部是通过arguments 调用参数，而没有实际定义参数的话，length只会的得到0。12function test() &#123; console.log( arguments );&#125;test.length // 0 这个函数确实可以传入参数，而且内部也调用了参数，但是length却无法得知传入的参数的个数。只能在函数执行的时候通过arguments.length得到实参个数。123function test() &#123; console.log( arguments.length );&#125;test(1,2,3); // 输出 3test(1,2,3,4); // 输出 4 所以函数的length属性只能得到他的形参个数，而无法得知实参个数。 参考链接：js小记 function 的 length 属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"正则表达式知识点","slug":"20160922-RegExp","date":"2016-09-22T15:48:12.000Z","updated":"2016-10-23T15:11:22.449Z","comments":true,"path":"2016/09/22/20160922-RegExp/","link":"","permalink":"https://lxchuan12.github.io/2016/09/22/20160922-RegExp/","excerpt":"正则表达式(RegExp)1、什么是正则表达式1.1 什么叫“正则”—规则、模式—强大的字符串匹配工具……","text":"正则表达式(RegExp)1、什么是正则表达式1.1 什么叫“正则”—规则、模式—强大的字符串匹配工具……1.2 正则的写法–new RegExp(“a”,”ig”),需要传参只能用这种方案。–/a/ 2、正则表达式常用方法2.1 test—字符串判断—返回真假—正则.test(字符串)—例子：是否有不是数字的字符2.2 search字符串搜索–返回出现的位置–字符串.search(正则)–忽略大小写：i——ignore2.3 match获取匹配的项目,–返回数组–量词：+–全局匹配：g——global–例子：找出所有数字2.4 replace替换所有匹配–返回替换后的字符串–字符串.replace(正则,想替换的)–例子：敏感词过滤-例子：统计字符串中每个字符的出现频率/**统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率 不限制 key 的顺序 输入的字符串参数不会为空 忽略空白字符输入例子:count(‘hello world’)输出例子:{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}*/123456789function count_2(str) &#123; var obj = &#123;&#125;; // \\S:非空白符 str.replace(/\\S/g,function(s)&#123; !obj[s]?obj[s]=1:obj[s]++; &#125;) return obj;&#125;console.log(count_2(&apos;hello world&apos;)); –匹配子项–例子：日期格式化 3、正则表达式字符类3.1 任意字符-[abc]–例子：o[usb]t——obt、ost、out3.2 范围-[a-z]、[0-9]–例子：id[0-9]——id0、id53.3 排除-[^a]–例子：o[^0-9]t——oat、o?t、o t3.4 组合-[a-z0-9A-Z]实例：偷小说过滤HTML标签–自定义innerText方法 4、转义字符转义字符.（点）——任意字符\\d（[0-9]）、\\w（[a-zA-Z0-9_]）、\\s（空白符） 、\\b（单词边界）\\D（[^\\d]）、\\W（[^\\w]）、\\S（[^\\s]） 、\\B（[^\\b]）\\1 重复子项例子–获取class元素–找重复项最多的字符和个数 5、量词5.1 什么是量词出现的次数{n,m}，至少出现n次，最多m次例子：查找QQ号5.2 常用量词{m,n}:m到n次{n,}:至少n次{n}:正好n次*:任意次 {0,}？:零次或一次 {0,1}+:一次或任意次{1,} 正则收尾^ 开始$ 结束例子–是不是QQ号–去掉前后空格 6、常用正则例子高级表单校验匹配中文：[\\u4e00-\\u9fa5]行首行尾空格：^\\s|\\s$Email：^\\w+@[a-z0-9]+(.[a-z]+){1,3}$ 网址：[a-zA-z]+://[^\\s]*QQ号：[1-9][0-9]{4,9}邮政编码：[1-9]\\d{5}身份证：[1-9]\\d{14}|[1-9]\\d{17}|[1-9]\\d{16}x 7、正则与面向对象把方法包在一个空间里有人管他叫——命名空间在公司里，把同一类方法，包在一起JSON的使用把之前的方法，包在一起 参考链接MDN RegExp","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"RegExp","slug":"RegExp","permalink":"https://lxchuan12.github.io/tags/RegExp/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"gitflow工作流","slug":"20160920-gitflow workflow","date":"2016-09-20T09:30:32.000Z","updated":"2016-09-27T15:06:56.001Z","comments":true,"path":"2016/09/20/20160920-gitflow workflow/","link":"","permalink":"https://lxchuan12.github.io/2016/09/20/20160920-gitflow workflow/","excerpt":"记得今年6月份参加了一次coding技术小馆杭州站的活动，讲的就是git和gitflow相关的。讲师当场也写代码。那是第一次gitflow工作流。那时在想我什么时候也能在舞台上讲开发技术……","text":"记得今年6月份参加了一次coding技术小馆杭州站的活动，讲的就是git和gitflow相关的。讲师当场也写代码。那是第一次gitflow工作流。那时在想我什么时候也能在舞台上讲开发技术……今天就碰到一个关于gitflow工作流的问题。使用sourceTree软件时，建立工作流。一般来说，是切换到master上。再建立工作流。我不小心，直接在develop分支上建了工作流。切换到master分支上。再打hotfix(修复补丁)时，发现无法成功。 谷歌搜索发现解决方案： 1、找到项目当前文件夹中的.git/config，把配置文件中的gitflow*相关的全部删除。2、关闭再重新打开SourceTree。3、重新在master上建立工作流，再打hotfix。发现成功了。 参考链接：Git 工作流程Git Flow 在团队中的最佳实践 – SourceTree的使用Smart branching with SourceTree and Git-flow","categories":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"https://lxchuan12.github.io/categories/git/"}]},{"title":"camelCase()转驼峰方法实现","slug":"20160915-camelCase","date":"2016-09-15T09:30:32.000Z","updated":"2017-06-04T11:42:10.400Z","comments":true,"path":"2016/09/15/20160915-camelCase/","link":"","permalink":"https://lxchuan12.github.io/2016/09/15/20160915-camelCase/","excerpt":"今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……","text":"今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……12345678910111213141516171819202122232425// 字符串操作方式function camelCase_1(str)&#123; var i=1, arr = str.split(&apos;-&apos;), len = str.split(&apos;-&apos;).length; var result = arr[0]; for(;i&lt;len;i++)&#123; result += arr[i].substring(0,1).toUpperCase()+arr[i].substring(1); &#125; return result;&#125;function camelCase_2(str)&#123; var arr = str.split(&apos;-&apos;); for (var i=1;i&lt;arr.length;i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substring(1); &#125; return arr.join(&apos;&apos;);&#125;// 正则方式// 分组概念 $0 代表整体，$1 第一个匹配子项function camelCase_3(str)&#123; return str.replace(/-(\\w)/g,function($0,$1)&#123; return $1.toUpperCase(); &#125;);&#125; 再看下jquery实现方案：123456//str.replace(/^-ms-/,&apos;ms-&apos;)是有IE下有，-ms-前缀的，比如转换成msTransform，而其他转换成首字母大写，如：WebkitTransformfunction camelCase_2(str)&#123; return str.replace(/^-ms-/,&apos;ms-&apos;).replace(/-([\\da-z])/gi,function(all,letter)&#123; return letter.toUpperCase(); &#125;);&#125; 再看zeptojs实现方案：12345//zepto.js实现方式：没处理-ms-，兼容性IE10+，但依旧有很多IE10依旧要加-ms-前缀的css3属性。为啥zeptojs没实现呢，难道还没碰到这个bug？//并且，空字符串写toUpperCase()依旧是空字符串。所以不需要写三目运算。function camelCase_3(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : &apos;&apos; &#125;)&#125; 测试：123456789101112var webkitstr = &apos;-webkit-transfrom&apos;;var msstr = &apos;-ms-transfrom&apos;;console.log(camelCase_1(webkitstr));//WebkitTransfromconsole.log(camelCase_1(msstr)); //MsTransfromconsole.log(camelCase_2(webkitstr));//WebkitTransfromconsole.log(camelCase_2(msstr)); //MsTransfromconsole.log(camelCase_3(webkitstr));//WebkitTransfromconsole.log(camelCase_3(msstr)); //MsTransfromconsole.log(camelCase_4(webkitstr)); //WebkitTransfromconsole.log(camelCase_4(msstr)); //msTransfromconsole.log(camelCase_5(webkitstr));//WebkitTransfromconsole.log(camelCase_5(msstr)); //MsTransfrom 看到这里，其实很想给zepto提pull request的。但还是没有提。 小结：分析jquery/zeptojs源码，发现能学到很多。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"jquery","slug":"jquery","permalink":"https://lxchuan12.github.io/tags/jquery/"},{"name":"zepto","slug":"zepto","permalink":"https://lxchuan12.github.io/tags/zepto/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"window.location-浏览器定位和导航","slug":"20160912-window.location","date":"2016-09-12T14:55:32.000Z","updated":"2017-06-19T14:16:43.206Z","comments":true,"path":"2016/09/12/20160912-window.location/","link":"","permalink":"https://lxchuan12.github.io/2016/09/12/20160912-window.location/","excerpt":"平时用window.location.href比较多。但却经常会忽略window.location下的其他属性……","text":"平时用window.location.href比较多。但却经常会忽略window.location下的其他属性……并且很多时候需要对链接问号后面字符串做处理，一般使用split()分割，再取。而实际上，有window.location.search可以获取。一图胜千言![图解url] url: 统一资源定位符 (Uniform Resource Locator, URL)href: 当前页面的urlprotocol: 协议hostname: 主机名port: 端口号host: 主机名+端口号pathname: 当前页面的路径和文件名origin:协议+主机名加端口号（新API）MDN location ![图解location]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://lxchuan12.github.io/tags/BOM/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"jQuery的几种写法探析","slug":"20160911-Several-writing-of-jquery","date":"2016-09-11T13:41:23.000Z","updated":"2016-09-11T13:55:03.057Z","comments":true,"path":"2016/09/11/20160911-Several-writing-of-jquery/","link":"","permalink":"https://lxchuan12.github.io/2016/09/11/20160911-Several-writing-of-jquery/","excerpt":"写法一：123$(function()&#123; //code here&#125;);","text":"写法一：123$(function()&#123; //code here&#125;); 写法二：123$(document).ready(function()&#123; //code here&#125;); 写法三：123$().ready(function()&#123; //code here&#125;) 默认参数就是document，所以可以省略不写。写法四：123(function($)&#123; //code here&#125;)(jQuery); 这种写法的最大好处是形成闭包。在内部定义的函数和变量只能在此范围内有效。形成是否函数函数、私有变量的概念。不会与其他类库，框架产生冲突。以上四种方法都是同一个意思，一般来说使用写法一比较多。此外，1234567$(window).load = function()&#123;&#125;//等价于：window.onload = function()&#123; //code here&#125; (JS中的事件，不加on，比如单击事件：click,双击事件：dblclick) window.onload = function(){}与$(funtion(){})两者的区别是：$(funtion(){})：1、在DOM加载完成后就可以可以对DOM进行操作。一般情况一个页面响应加载的顺序是：域名解析-加载html-加载js和css-加载图片和视频等其他信息。那么Dom Ready应该在“加载js和css”和“加载图片等其他信息”之间，就可以操作Dom了。2、能多次使用，按序执行。window.onload = function(){}：1、在网页中所有元素(包括元素的所有关联文件)完全加载到浏览器后才执行，即JavaScript 此时可以访问网页中的所有元素。2、不能多次使用，后者会覆盖前者。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/tags/jQuery/"}],"keywords":[{"name":"jQuery","slug":"jQuery","permalink":"https://lxchuan12.github.io/categories/jQuery/"}]},{"title":"CSS3 媒体查询media","slug":"20160909-CSS3-@media","date":"2016-09-09T12:50:42.000Z","updated":"2016-09-09T13:20:44.079Z","comments":true,"path":"2016/09/09/20160909-CSS3-@media/","link":"","permalink":"https://lxchuan12.github.io/2016/09/09/20160909-CSS3-@media/","excerpt":"CSS3 媒体查询media，其实CSS2也有media，只是基本不用……","text":"CSS3 媒体查询media，其实CSS2也有media，只是基本不用……1234567891011@media only screen and (max-width:375px)&#123; .box&#123; background:#f00!important; /*加上！important才有效。*/ &#125;&#125;.box&#123; width:100px; height:100px; background:#000;&#125; 媒体查询@media需要配合meta标签使用才有效。简版：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 完整版：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt; 其中minimal-ui表示参考链接：iOS 7.1的Safari为meta标签新增minimal-ui属性，在网页加载时隐藏地址栏与导航栏iOS 8 removed “minimal-ui” viewport property, are there other “soft fullscreen” solutions?取值：123456789@media screen and (max-width:320px)&#123; /*视窗宽度&lt;=320px*/&#125;@media screen and (min-width:769px)&#123; /*视窗宽度&gt;=769px*/&#125;@media screen and (min-width:769px) and (max-width:1000px)&#123; /*769px&lt;=视窗宽度&lt;=1000px*/&#125; 几道判断题：1、媒体查询条件中，（max-width:320px）表示的是：A. 当视窗宽度小于等于320px时。2、要做响应式网站，就必须设置viewportA. √3、device-width是viewport的默认宽度B、×4、viewport的默认宽度就是屏幕的水平分辨率B、×","categories":[{"name":"css3","slug":"css3","permalink":"https://lxchuan12.github.io/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://lxchuan12.github.io/tags/css3/"},{"name":"media","slug":"media","permalink":"https://lxchuan12.github.io/tags/media/"}],"keywords":[{"name":"css3","slug":"css3","permalink":"https://lxchuan12.github.io/categories/css3/"}]},{"title":"我是如何踏上前端这条路的","slug":"20160907-How-do-I-set-foot-on-the-front-end-of-the-road","date":"2016-09-07T13:48:12.000Z","updated":"2017-06-24T15:13:21.115Z","comments":true,"path":"2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/","link":"","permalink":"https://lxchuan12.github.io/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/","excerpt":"感觉最近我是如何XXX的这类标题挺火的。杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。","text":"感觉最近我是如何XXX的这类标题挺火的。杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。1、刚好可以对现在大四迷茫的学弟学妹们，有些指引。2、还可以借此回忆下大学生活。3、锻炼自己写长文的逻辑能力。当然，学习是座大山，人们沿着不同的路登山，分享着自己看到的风景，别人不一定看得到你看到的风景，体会得了你的心情。 接触前端2012年，那年大一，只记得上学期参加了四个社团，参加社团的各种活动，比较忙，另外自己收集一些电子书放到我那一点都不智能的手机上看。下学期，我所在的社团计算机协会（后文简称计协），当时教网页制作（嗯，那时不叫前端开发），当然我报名去参加了。比我们大一级的学长用着Dreamweaver软件 给我们教学，超链接，图片，音乐，视频，FLASH等。总之感觉很有趣。也要我们做出一些作品，交作业。但那时我并没有电脑。所以就没做。 江西省网页制作与设计技能大赛大二任职计协会长，举办各类活动。也没怎么学习前端开发之类的知识。学习方面好像也就是平时上上课而已，再就是学习电脑方面的技巧，帮助别人解决电脑问题，为此也写了挺多这类技术文章。比如：【教程】Ｕ盘、硬盘安装原版win7、8.1、10系统,近期上网拨号客户端出现拨号异常、711错误解决方案。在大学，懂点电脑，会装几个软件，重装个系统，在别人眼中就会被看做是大神，并且很受欢迎。后来实在忙，就写了篇文章：对不起，我不能帮你修电脑了转眼间，就到了2014年4月（大二下学期），我所在的信息学院，组织参加省级网页大赛，同时派老师给予培训指导。这时，老师N每周四（或五）给我们上了几周课，主要讲HTML和CSS，还给我们他录制的视频，当时觉得老师好厉害。后来让我们出作品，我们就找设计（陶美）学院的学生给我们设计网页视觉稿。虽然她们学的是设计，但也不是很懂网页设计这块。于是我就自己参照一个视觉比较好的网站，自己仿照着写了一个。当时还是比较忙，只有晚上有时间，所以总共八个页面，好像写了将近10天。主要用了HTML，CSS，js，jquery。现在放在github上，点击可以访问，时尚影楼,那时并不是很懂js和jquery。后来比赛结果出来了，竟然是省级一等奖。其实一等奖有挺多的。这次网页赛，我们学校获得了很多奖项。大二末，图书馆一老师找到我们，想让我们暑假回去学点PHP，开学好让我们上手，帮他做项目。我们信息学院邀请了10级计科的H学长，给我们这些迷茫的学弟学妹开了一次经验分享会，说到腾讯招人的标准。因为他就是课题组研发部的一员。说到课题组研发部的各种好处，跟着里面的老师L学习PHP，学到60％就够找好工作了。总之意思就是要进课题组学习。大二暑假，家里没网，我就在学校，下载好各种PHP学习资源，暑假就在家看着PHP相关的视频等，一套PHP视频也是100多集，基本看完了，也写了些代码。当时也学了javascript，一套JS视频100多集没有看完。其实到后来基本都忘了。另外，大二暑假，线上面试了乔布简历，通过成为了乔布简历校园大使。 加入课题组研发部大三上学期，卸任了计协会长，本以为这是大学最后一个职务，谁知这只是第一个。同学A，同学B跟着图书馆老师做PHP的项目。而我此时看着没啥事，就玩起了PPT，新媒体运营，又相继任职了校园网络中心团队的队长（关于这个我也写了篇文章谈一谈校园网管这一工作，一直任职到大四上学期）。校友总会志愿团常务团长（后来由于组织性质缘故，2014年11月，不到两个月就默认退出了），乔布简历江西省副主管，那时班上竞选班干，班主任说我们计协会长卸任了怎么不竞选一个职务。我说不用了，我并没有说还有这么多职务。上学期刚开始不久，我们专业老师也邀请了11级的学长学姐分享他们的一些经验。后来我们成立了信管学习小组，规定时间来主教自习。主要是为了学习网站开发。但后来效果不佳，我也较忙，就散了。PPT水平在涨进，主要体现在我做的优秀班集体评选PPT上，传说就是凭借这次展示，让学校领导记住了做PPT还有这么好的人，后来（2015年5月13日）就被找去做更名大学工作汇报PPT，再后来就有了这张图 PPT制作主要经历:，也写了一些关于PPT制作的文章，比如：要做PPT，一直找不到资源？。开发水平并没有多少涨进。大三下学期，我和同学A，B一起加入了课题组学习，做任务。5月19日，成立了移动互联协会，又任职移动互联协会首届会长，一直任职到大四上学期。成立这社团，主要目的就是为了培养开发，后来给学弟学妹们培训HTML，CSS,和PPT，PS等，感觉他们真幸福。现在回想起来，在课题组，老师好像真的没给我什么实质性的开发任务。好像就让我做些与开发不那么相关的事情。可能是我个人原因。4月，九家培训机构到我们信息学院做宣讲，他们的目的很明显，就是招人去培训。下午跟千锋教育的老师聊了挺久，主要是了解了他们机构是如何授课等。当然，他们极力希望我能去他们的好程序员班，但我肯定不会考虑培训。当时听完，晚上总结了一张图![从校园宣讲会我学到了什么]。 到学期末（6月），让我和同学A一起做设计学院网站（给了设计稿），用迅时CMS搭建网站后台（Asp.net）。主要是我做。那时相当于隔了一年多，要重新捡起HTML，CSS，JS。连引入的jquery和自己写的JS顺序都能弄反，连Jquery的选项卡都写不来。熬了几次夜，在同学A和老师的指导下。终于完成了。这时，我开始感受到，就业压力，我究竟要往哪条路走。是新媒体运营（PPT），或者是PHP开发，还是前端开发？如果走新媒体运营（PPT），那么要开个微信公众号，写PPT相关文章，PPT演界网卖模板，等等。 真正意义上开始学前端开发大三暑假，课题组业务需求，我和同学A，B，都留在课题组做任务学习。前期我还在学PHP，后来室友L，在杭州暑假实习，他说前端也比较火。刚好又在网易云课堂，看到网易推出前端微专业第二期。价格一千多。虽然对于在更名大学办公室做PPT和做网络中心团队队长赚了少许钱的我来说，不是很贵，但上学期报名了驾照（3K+），所以就买不起了。但那时我就确定了方向，前端开发，因为入门相对容易，并且所见即所得，喜欢视觉交互，和之前玩PPT是同样注重视觉交互和逻辑。另外在PHP方面根本没做什么项目。要走前端，原生JavaScript必学！于是在知乎上看到说智能社的JS视频《精通JavaScript开发》，这套课程不错。那时就没多想，先看完这套课程再学其他的。很多时候，你想学的太多，都在同时学，往往效果不好，而是先学什么再学什么。记得那时，晚上9点断网，他们在打牌，我回去后在看下载好的视频。学完这条课程后，感觉有些提升，至少熟练了下写代码。学完这套后，就在慕课网学习其他前端相关知识。8月，课题组组建了一支团队，参加互联网+大赛，当时学校比较重视这次比赛，召集参赛者在学校机房培训，解决吃住问题（在教工食堂吃了10多天），我一不小心又成了临时班长，协助就业处的老师处理相关事务。我还负责团队赛项目计划书的撰写和PPT制作。后来我们团队（指尖上的陶艺项目）依次进入校赛，省赛，国赛，最后10月份到吉林大学（吉林长春）参赛国赛，获得国赛金奖（前30）和最佳创意奖，载誉归来之时，学校领导在校门口接我们，学校党委书记说奖励我们团队10万元。刚开始以为不会分到没多少钱。后来就有钱买课程了。双十一期间，就买了网易云课堂的前端开发微专业第三期，系统的学习前端开发。另外还买了妙味课堂的视频课程学习。有人说，你要学知识，把市面上这类书都买下来，看懂并消化。那你肯定就有提升了。11月，老师N让我做学工处的网站，同样是Asp.net的后台。这次就没做多久，也没做设计学院网站那么痛苦。12月，开始做毕业设计，是用php+mySql做第二课堂管理系统。1月5日，提前答辩通过。 大四寒假开发水平那么差的我，当然是不忘抓住这段时间，提升自己的。看妙味课堂的视频。学着前端微专业，看课程，查资料，讨论区讨论，做作业，改作业。提交作业有截止日期。感觉这段时间挺充实的。也在考虑大四下学期是否去学校，校内实习，还是去公司实习。老师L是推荐我去公司实习，能学挺多。虽然11月份参加了学校的招聘会，有公司问我用过Bootstrap吗，我说没有。后来有几家公司，叫我去实习，我没去。主要是以下考虑：1、公司前端团队好，实习则好。不好，不如自学。2、自己不足还有很多，希望能继续学完前端开发微专业，获得优秀学员，也许能进好一点的公司。3、毕竟不考研，以后有的是工作时间，还不如继续享受下最后一学期的校园生活。 大四最后一个学期开学伊始，我和同学A，B都没去公司实习，重新来到了课题组。刚去不久，老师N就推荐我去南昌，算是实习，说有搞PHP的愿意带一个人一起做项目。后来委婉的拒绝了。因为已经不想走PHP开发路线，想走前端开发路线。但本学期，老师交给我的任务依旧是PHP开发的。第二课堂管理系统（PHP+MySql，CI框架）。因为不是很赶，我就前端微专业，百度前端技术学院任务，（妙味课堂的vip视频）三线并行。4月初，完成了前端微专业大作业，获得优秀学员证书。在学校，上班是996（早上9点上班，晚上9点下班，中午休息1-2小时）。周日老师不在办公室，而我一般在（同学A，B不在）。因为我太Low了，所以只好多花点时间学习。有段时间，都是24点前提交完代码，才去刷牙洗脸睡觉。晚上躺着睡前还在牛客网刷题，或者看视频，或者看前端开发类电子书。 面试，入职杭州一家移动互联网公司4月底投简历，5月劳动节一过，我和同学A就来杭州面试。我求职还算顺利，面试了3天，共9家。有的给了offer，就选了一家我认为比较合适的。6月1日入职杭州一家移动互联网公司，公司使用花名，我自己挑选了一个，叫轩辕。于是把网上各种昵称，改成了轩辕Rowboat。 轩辕Rowboat由来：轩辕(公司花名)。Rowboat，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），剑未佩妥，出门便是江湖。 公司使用的技术主要有：HTML5，模板语言（velocity，thymeleaf,handlebarsjs，underscorejs，lodash工具库等），CSS3，Less，Sass，JS，JQuery，zeptojs，bootstrap，angularjs，vuejs，git，gulp，webpack，ES6等（React，nodejs暂时没用到）。不知不觉就写了挺多字，感觉一路走来，在网易云课堂购买了付费课程（office，前端微专业等）两千左右（已赚回），当没有时间，有钱时，可以选择付费学习，投资学习，回报很大。技术提升需要一定的过程，脚踏实地走好每一步，先定好一个个小目标，然后去一一实现。看过很多前端大神成长路线，也是从刚开始啥都不会，一步一步变成前端大神的。","categories":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}],"tags":[{"name":"self-growth","slug":"self-growth","permalink":"https://lxchuan12.github.io/tags/self-growth/"},{"name":"前端","slug":"前端","permalink":"https://lxchuan12.github.io/tags/前端/"}],"keywords":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}]},{"title":"由JavaScript一道面向对象题引发的思考","slug":"20160830-js-oop-prototype-constructor","date":"2016-08-30T15:09:00.000Z","updated":"2016-08-31T05:13:33.817Z","comments":true,"path":"2016/08/30/20160830-js-oop-prototype-constructor/","link":"","permalink":"https://lxchuan12.github.io/2016/08/30/20160830-js-oop-prototype-constructor/","excerpt":"一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了","text":"一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了123456789101112131415161718function Person()&#123; this.name = &quot;lxchuan12&quot;;&#125;var rowboat = new Person();Person.prototype.age=20;Person.prototype=&#123;a:1,b:2&#125;;//Person.prototype.constructor = Person;console.log(rowboat.name);//&quot;lxchuan12&quot;console.log(rowboat.age);//20console.log(rowboat.a);//undefinedconsole.log(rowboat.b);//undefinedconsole.log(rowboat);console.log(Person.prototype.name);//undefinedconsole.log(Person.prototype.age);//undefinedconsole.log(Person.prototype.a);//1console.log(Person.prototype.b);//2console.log(Person.prototype.constructor);//function Object() &#123; [native code] &#125;console.log(Person.prototype);//Object &#123;a: 1, b: 2&#125; 问题：他不明白，为什么rowboat.age为20。但Person.prototype.age却为undefined。 解答：我把代码在jsbin运行后，为之解答。Person.prototype={a:1,b:2};这种写法是赋值，与Person.prototype.age=20;写法不同，不经意间把constructor指向原本为Person的，改为了Object（一般来说，需要修正指向。Person.prototype.constructor = Person）。 控制台输出对象 相当于prototype下只有a,b两个值了。所以Person.prototype.age则是undefined。但rowboat.age是原型上的，可以找到，所以是20。所谓原型查找：查找的是构造器查找的原型，构造器是指向一个function(){},里面没有a和b. 参考资料：《JavaScript高级程序设计》——对象学习笔记 小结：学习js面对对象编程相关知识,对了解js语言很有帮助。另外，有人说，能写组件，做组件开发说明达到了中级水平。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"},{"name":"oop","slug":"oop","permalink":"https://lxchuan12.github.io/tags/oop/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"sass基本特性-运算","slug":"20160829-Sass-basic-characteristics-of-computing","date":"2016-08-29T13:26:28.000Z","updated":"2016-08-29T15:16:14.266Z","comments":true,"path":"2016/08/29/20160829-Sass-basic-characteristics-of-computing/","link":"","permalink":"https://lxchuan12.github.io/2016/08/29/20160829-Sass-basic-characteristics-of-computing/","excerpt":"CSS中目前只有calc()能做运算，但是在Sass中，可以做各种数学运算……","text":"CSS中目前只有calc()能做运算，但是在Sass中，可以做各种数学运算…… 1、加法123.box&#123; width: 20px + 8in;&#125; 编译出来的CSS:123.box &#123; width: 788px;&#125; 1in = 96px; 当em,rem等相对当前字体，于px在一起不能运算，会报错，如:123.box&#123; width: 20px + 8em;&#125; 不过如果其中一个不同单位，那么会以另一个带单位的为准，如：1234567.box&#123; width: 20px + 8;&#125;.box2&#123; width: 20em + 8;&#125; 编译出来的CSS为:1234567.box &#123; width: 28px;&#125;.box2 &#123; width: 28em;&#125; 2、减法12345678$container: 960px;$sidebar-width: 220px;$gap-width: 20px;.content&#123; width: $container - $sidebar-width - $gap-width; float: left;&#125; 编译出来的CSS：123456.content &#123; width: 720px; float: left; &#125; 减法和加法一样，不支持em,rem等相对当前字体大小的单位与px进行计算。 3、乘法 乘法运算时，只需要其中一个带单位即可，如果都带有单位会报错,如:123.box&#123; width: 20px * 20px&#125; 编译时会报错。 而:123.box&#123; width: 20px * 20;&#125; 编译出来的CSS：123.box&#123; width: 400px;&#125; 与加减法一样，不同类型的单位运算时会报错。 4、除法 Sass的乘法运算规则也适用于除法运算，不过除法运算有特殊之处，因为”/”符号在CSS中已经作为一种符号使用，因此在Sass中直接使用”/”作为处好时，将不会生效，编译时既不会报错，也不会得到我们想要的效果。 如:123.box&#123; width: 100px / 2;&#125; 编译出来的CSS:123.box &#123; width: 100px / 2;&#125; 要修正这个文字，只需要给运算的外面添加一对小括号即可。123.box&#123; width: (100px / 2);&#125; 编译出来的CSS为:123.box &#123; width: 50px;&#125; 除了小括号以外，如果除了 “/” 外，还有其它的运算符号，那么也会被当作除号看待。123.box &#123; width: 100px / 2 + 20px; &#125; 编译出来的CSS为：123.box &#123; width: 70px;&#125; 另外，如果是用变量进行除法运算，”/”也会自动被识别为除法。 如:12345$width: 960px;.col &#123; width: $width / 10;&#125; 编译出来的CSS为:1234.col &#123; width: 96px; &#125; 综合上述，”/ ”符号被当作除法运算符时有以下几种情况： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。如果数值被圆括号包围。如果数值是另一个数学表达式的一部分。在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值。 关于单位计算的问题，同物理倒是非常像。 如果不想记”/”的规则，那么在想作为除法使用是，加上一个括号即可。 5、颜色运算 所有的运算都支持颜色值。如:123p &#123; color: #010203 + #040506;&#125; 编译出的CSS为:123p &#123; color: #050709;&#125; 同样颜色值也支持乘法运算:123p &#123; color: #010203 * 2;&#125; 编译出来的CSS:123p &#123; color: #020406;&#125; 运算规则和二进制乘法相同，依次与每一位相乘。个人觉得颜色值的运算意义不是很大。 6、字符运算 在Sass中可以用”+”号对字符串进行拼接，如:123456789$content: &quot;Hello&quot; + &quot; &quot; + &quot;Sass!&quot;;.box&#123; &amp;:after&#123; content: $content; &#125; &amp;:before&#123; content: &quot; #&#123;$content&#125; &quot;; &#125;&#125; 编译出来的CSS为:123456.box:after &#123; content: &quot;Hello Sass!&quot;; &#125;.box:before &#123; content: &quot; Hello Sass! &quot;; &#125; 除了在变量中做字符连接运算之外，还可以直接通过 +，把字符连接在一起：1234567div&#123; cursor: e + -resize;&#125;span&#123; cursor: &quot;e&quot; + &quot;-resize&quot;;&#125; 编译出来的CSS为:1234567div &#123; cursor: e-resize;&#125;span &#123; cursor: &quot;e-resize&quot;; &#125; ==注意==:如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 也就是说始终与加号左边的保持一致:1234p:before &#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125; 编译出来的CSS为:1234p:before &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 根据慕课网sass入门篇整理","categories":[{"name":"sass","slug":"sass","permalink":"https://lxchuan12.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://lxchuan12.github.io/tags/sass/"}],"keywords":[{"name":"sass","slug":"sass","permalink":"https://lxchuan12.github.io/categories/sass/"}]},{"title":"js如何判断对象为空","slug":"20160827-Judge-null-object-by-javascript","date":"2016-08-27T14:46:23.000Z","updated":"2016-08-29T15:46:51.607Z","comments":true,"path":"2016/08/27/20160827-Judge-null-object-by-javascript/","link":"","permalink":"https://lxchuan12.github.io/2016/08/27/20160827-Judge-null-object-by-javascript/","excerpt":"vuejs项目中，遇到要判断data中的对象是否为空……","text":"vuejs项目中，遇到要判断data中的对象是否为空……12345678910111213141516171819202122var vm = new Vue(&#123; el:&apos;#demo&apos;, data:&#123; msg:&apos;hello&apos;, ms:&#123;&#125; &#125;, created ()&#123; let that = this; console.log(that.ms); console.log(that.msg); console.log(that.ms === null);//false if(that.ms)&#123;//true console.log(1);//1, &#125;; console.log(that.ms === undefined);//false for(var attr in that.ms)&#123; console.log(attr); console.log(&apos;2&apos;); &#125; //console.log(&apos;3&apos;); &#125;&#125;); 点击查看详情vuejs jquery有工具方法$.isEmptyObject(),查看源码发现这样实现的。1234567isEmptyObject:function(obj)&#123; var name; for(name in obj)&#123; return false; &#125; return true;&#125; 这是利用了for in无法循环到系统自带的属性值。123456789//比如：function Watch()&#123;&#125;//Watch.prototype.constructor = Watch;//系统自己生成。写出来这句也无法用for in循环到。for (var attr in Watch.prototype)&#123; console.log(&apos;can not console&apos;);//无法输出。&#125;//如果自己写,则可以输出show.Watch.prototype.show = function()&#123;&#125; 这时想起了js中数组遍历for与for in区别(强烈建议不要使用for in遍历数组)$.isPlainObject()方法：判断”纯粹的对象”，就是该对象是通过”{}”或”new Object”创建的。$.isPlainObject( document.location ) ); // false(在IE中返回true) 参考资料：汤姆大叔博客 小结:js一切皆为对象，了解面对对象编程很有好处。能研究一遍jquery源码,定能更上一层楼。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://lxchuan12.github.io/tags/vuejs/"},{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"iPhone safari可以通过访问链接来打开微信","slug":"20160820-safari-open-wechat","date":"2016-08-20T15:35:26.000Z","updated":"2016-08-22T15:33:42.579Z","comments":true,"path":"2016/08/20/20160820-safari-open-wechat/","link":"","permalink":"https://lxchuan12.github.io/2016/08/20/20160820-safari-open-wechat/","excerpt":"今天发现：iPhone safari可以可以通过访问链接来打开微信。而安卓手机不行。不多说，直接show the code……","text":"今天发现：iPhone safari可以可以通过访问链接来打开微信。而安卓手机不行。不多说，直接show the code…… 1234let ua = window.navigator.userAgent.toLowerCase();if ((ua.indexOf(&apos;iphone&apos;)&gt;-1)&amp;&amp;(ua.indexOf(&apos;safari&apos;)&gt;-1))&#123; window.location.href = &apos;weixin:http://weixin.qq.com&apos;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"},{"name":"wechat","slug":"wechat","permalink":"https://lxchuan12.github.io/tags/wechat/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxchuan12.github.io/categories/JavaScript/"}]},{"title":"(转)一种代码量更少的(micro clearfix)清除浮动的hack","slug":"20160819-css-micro clearfix-hack","date":"2016-08-19T15:24:12.000Z","updated":"2016-08-19T15:36:30.924Z","comments":true,"path":"2016/08/19/20160819-css-micro clearfix-hack/","link":"","permalink":"https://lxchuan12.github.io/2016/08/19/20160819-css-micro clearfix-hack/","excerpt":"clearfix hack做为一种无需借助额外标签清除浮动的方法已经人尽皆知了，本文给出一种优化方案，可以进一步减少所需css的数量……","text":"clearfix hack做为一种无需借助额外标签清除浮动的方法已经人尽皆知了，本文给出一种优化方案，可以进一步减少所需css的数量…… Demo: Micro clearfix hack Known support: Firefox 3.5+, Safari 4+, Chrome, Opera 9+, IE 6+ micro clearfix基于 Thierry Koblentz’s “clearfix reloadedreloaded优化而来，适用于现代浏览器（modern browsers） 下面是micro clearfix的代码片段1234567891011.cf:before,.cf:after &#123; content: &quot; &quot;; display: table; &#125;.cf:after &#123; clear: both;&#125;.cf &#123; *zoom: 1;&#125; “micro clearfix”生成伪类元素，并将其display属性设置为table，这样就会创建一个匿名table-cell，同时生成了新的BFC，这样意味着:before伪类会阻止上边距折叠，:after伪类用于清除浮动，好处是不用隐藏产生的内容了，所需要的css代码就变少了。 为了清除浮动包含:before选择器是没必要的，但是:before的加入可以阻止top-margins折叠，这样有两个好处： 同其他使用BFC方式清除浮动一样，确保了视觉上的一致，例如使用overflow:hiddenIE 6/7中使用zoom:1 时，确保了视觉上的一致N.B.: 有一个细节：IE 6/7中在新的BFC中浮动元素的下边距是不会包含在内的，进一步的描述可以看这里： Better float containment in IE using CSS expressions.content:” “的使用避免了一个Opera的bug，如果contenteditable属性同时出现在元素中时，这个bug会在待清除元素周围生成空格。一种可选的修复方案是使用 font:0/0 a，多谢Sergio Cerrutti测试出这个bug 转载于：一种代码量更少的(micro clearfix)清除浮动的hack 英文版：A new micro clearfix hack，转载标明出处，谢谢！","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/tags/css/"},{"name":"clearfix","slug":"clearfix","permalink":"https://lxchuan12.github.io/tags/clearfix/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"vuejs生态，自顶而下学习","slug":"20160818-chat","date":"2016-08-18T15:24:12.000Z","updated":"2016-09-30T15:59:10.755Z","comments":true,"path":"2016/08/18/20160818-chat/","link":"","permalink":"https://lxchuan12.github.io/2016/08/18/20160818-chat/","excerpt":"由于我git比较活跃，有幸收到大搜车前端leader芋头（前端乱炖网站创始人，颜文字APP）的邮件，并与之交流。","text":"由于我git比较活跃，有幸收到大搜车前端leader芋头（前端乱炖网站创始人，颜文字APP）的邮件，并与之交流。小芋头君的知乎主页.大搜车前端团队博客. 大概整理： 1、自顶而下学习，看vuejs文章，熟悉其生态圈，怎么产生的，解决了什么问题。不是会写，就行。很多人看完vuejs教程都会写。 比如angularjs，双向绑定，vuejs是单向绑定，虽然也可以双向绑定。2、自我管理，自我规划，自我提升。综合能力。3、追新，有些人工作了几年就不学新东西，这样没提升。4、前端工程化，（打包工具只是其中一小部分）。5、目前重要的不是学ES6，而是把基础夯实。 这让我想起：知乎上一个提问大学毕业做前端工作感觉最近遇到了瓶颈，不知道该如何提升自己？ 作者：林獺链接：https://www.zhihu.com/question/49164656/answer/114625869来源：知乎著作权归作者所有，转载请联系作者获得授权。 首先，正视自己的能力。前端的新技术，不是门坎较低、就是给人一种容易掌握的错觉。Less/Sass 不谈，你学了 Angular，懂得 data-binding、router 等背后的实现原理吗？你虽会用 Node 搭建一个本地 server，但懂得 I/O 流程、HTTP 和操作系统知识吗？你能不诉诸书本和搜索引擎，写出几个 JS 设计模式和继承模式吗？你能完全脱离 jQuery 来操纵 DOM 和 Ajax 吗？你知道怎么写 CSS 选择器能让浏览器解释速度最快吗？你会在开发过程中，下意识地追求 HTTP 请求最少吗？……如果你不能的话，那就需要重新审视自己，是否被一时的自我成就和满足所障目，而忘却了技术最重要的永远是基础。如果你能的话，恭喜你，你已经不止是合格的前端了。这样的话，你要怎么做才能走出平阳、找到归宿呢？我的建议是积累经验——积累工作和项目的经验，闲时继续学习并深入新技术。你的工作效率高、闲时多，这是好事。我毕业后第一份工作也是如此，领导缺乏技术嗅觉，技术路线过时老旧。我是这么应对的：凭越发娴熟的技能，加快工作速度，换来学习的时间。接着，主动把你的新技能移植到公司项目中。例如 Gulp、Less/Sass，都是开发环境下的利器，开发环境下你想怎么用就怎么用，外人只看到生产代码；甚或 Angular——遇到独力负责的中重量级项目，主动考虑此类 MVC 框架的可行性；有时不是项目和领导不允许使用新框架，而是自己不愿走出舒适圈、缺乏实践自信。（业余时间，用你的 Gulp、Angular 写一些个人项目放在 GitHub 上，配以 Node mock server 甚至 Redis 数据库，有助理解前后端交互和数据库的组织，也增加面试的资本。）当你「利用」这个公司，积累了新老技术的实践经验后，便是另谋高就的时机了。你的简历不仅会有上述技能，还会有「一力为旧公司引入任务构建、工作流等新技术」之类的 impressing 字眼。在投简历时，开始考虑实质回报以外更深层的东西。你可以询问对方，贵团队的前端技术栈为何，未来的技术规划为何。因为接下来的新工作，在你的职场生涯中，是最能影响你的技术修炼的——你将第一次名正言顺地学习技术、并将其付诸实践、甚至有同样技术路线的同事大牛带领。对比上一家，事半功倍。 小结：坚持学习，自我提升；重视基础！努力争取能进好团队，学习更快。","categories":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}],"tags":[{"name":"self-growth","slug":"self-growth","permalink":"https://lxchuan12.github.io/tags/self-growth/"}],"keywords":[{"name":"自我成长","slug":"自我成长","permalink":"https://lxchuan12.github.io/categories/自我成长/"}]},{"title":"弹窗（modal）垂直水平居中","slug":"20160817-modal-center","date":"2016-08-17T15:07:15.000Z","updated":"2016-08-17T15:58:06.795Z","comments":true,"path":"2016/08/17/20160817-modal-center/","link":"","permalink":"https://lxchuan12.github.io/2016/08/17/20160817-modal-center/","excerpt":"今天发现{margin:0 auto}竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了……","text":"今天发现{margin:0 auto}竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了…… 弹窗垂直水平居中：方法1：12345678910.modal&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; margin-left:-125px; margin-top:-50px;&#125; 小结:fixed，支持到IE7，IE6不支持。modal定宽定高。 方法2：12345678910.modal&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125; 小结:不支持IE9+，modal不需定宽定高，手机端可用。（发现如果有其他的transform，好像先执行其他的，在移动到中心。）另外，发现{margin:0 auto}:12345678910.modal&#123; position:fixed; width:250px; left:0; right:0; top:40%; bottom:auto; margin:0 auto; background:#ececec;&#125; 竟然能使固定定位fixed(脱离文档流）（在chrome手机模拟器和chrome浏览器）水平居中。在我安卓手机(4.2.2)不行。后来改成{margin-left:-定宽/2}，于是在安卓手机也可以了","categories":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/tags/css/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/categories/css/"}]},{"title":"js手机号码正则表达式","slug":"20160816-reg-phone-num","date":"2016-08-16T15:06:16.000Z","updated":"2016-08-20T15:51:20.899Z","comments":true,"path":"2016/08/16/20160816-reg-phone-num/","link":"","permalink":"https://lxchuan12.github.io/2016/08/16/20160816-reg-phone-num/","excerpt":"前端做了手机号的限制，但有的号码通过了前端验证，但依旧数据无法保存成功，但又没错误提示。与后台联调发现，原来是后端也做了限制，还不一样……","text":"前端做了手机号的限制，但有的号码通过了前端验证，但依旧数据无法保存成功，但又没错误提示。与后台联调发现，原来是后端也做了限制，还不一样……1.前端验证var reg = /^1\\d{10}$/; 2.后端验证var reg = /^1[3|4|5|7|8][0-9]{9}$/; //验证规则不知其合理性，普适性，于是搜索了下。 3.最后采用： var reg = /^1\\d{10}$/; //验证规则var phoneNum = ‘18296821923’;//手机号码var flag = reg.test(phoneNum); //true 4.参考资料：JS最新手机号码检验正则表达式","categories":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/tags/js/"},{"name":"reg","slug":"reg","permalink":"https://lxchuan12.github.io/tags/reg/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://lxchuan12.github.io/categories/js/"}]},{"title":"new Date()的浏览器兼容性问题","slug":"20160813-tip-js-new-date","date":"2016-08-13T14:03:29.000Z","updated":"2016-08-14T15:30:20.655Z","comments":true,"path":"2016/08/13/20160813-tip-js-new-date/","link":"","permalink":"https://lxchuan12.github.io/2016/08/13/20160813-tip-js-new-date/","excerpt":"兼容性问题var date = new Date(‘2016-08-13 13:25:50’).getTime();这种chrome下没问题，但ie和firefox下是NaN,在Safari下也有问题……","text":"兼容性问题var date = new Date(‘2016-08-13 13:25:50’).getTime();这种chrome下没问题，但ie和firefox下是NaN,在Safari下也有问题…… var date = new Date(‘2016-08-13 13:25:50’).getTime(); 这么写的时候所有浏览器都没有问题。 所以遇到兼容的时候：这样就可以将上面那种格式yyyy-MM-dd改为yyyy/MM/dd 再去转换 var date = new Date((‘2016-08-13 13:25:50’).replace(new RegExp(“-“,”g”),”/“)).getTime() 另外：+new Date()=== new Date().getTime();true.123456789101112&lt;div id=&quot;d&quot;&gt;&lt;/div&gt;&lt;div id=&quot;getTime&quot;&gt;&lt;/div&gt;&lt;div id=&quot;type&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var d1 = document.getElementById(&apos;d&apos;); var getTime1 = document.getElementById(&apos;getTime&apos;); var type1 = document.getElementById(&apos;type&apos;); var date = new Date(&apos;2016-08-13 13:25:50&apos;); d.innerHTML = date.toString(); d.innerHTML = date.getTime(); type1.innerHTML = typeof date.toString();&lt;/script&gt; 参考文章：JS原生Date类型方法的一些冷知识javascript中new Date()的浏览器兼容性问题js new Date(“2016-07-01 08:00:00”) 格式在IE内核浏览器中显示NaN的问题","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lxchuan12.github.io/categories/javascript/"}],"tags":[{"name":"date","slug":"date","permalink":"https://lxchuan12.github.io/tags/date/"},{"name":"javascript","slug":"javascript","permalink":"https://lxchuan12.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://lxchuan12.github.io/categories/javascript/"}]},{"title":"vue js两次请求","slug":"20160812-vue-route request","date":"2016-08-12T14:59:16.000Z","updated":"2016-08-16T15:06:06.197Z","comments":true,"path":"2016/08/12/20160812-vue-route request/","link":"","permalink":"https://lxchuan12.github.io/2016/08/12/20160812-vue-route request/","excerpt":"当使用vue-resource发送注册的POST请求时，Fiddler捕获到了2次请求，第1次是由浏览器发送的OPTIONS预请求，第2次才是实际的POST请求……","text":"当使用vue-resource发送注册的POST请求时，Fiddler捕获到了2次请求，第1次是由浏览器发送的OPTIONS预请求，第2次才是实际的POST请求……这和使用$.ajax时是不一样的，因为$.ajax会将非GET请求的Content-Type设置为application/x-www-form-urlencoded，而vue-resource发送POST请求的Content-Type为application/json;charset=UTF-8。 1.全局启用：1Vue.http.options.emulateJSON = true 2.局部启用启用了emulateJSON选项后，使得POST请求的Content-Type变为application/x-www-form-urlencoded1234this.$http.post(this.registerUrl, this.registerModel ,&#123; emulateJSON : true&#125;) .then( (response) =&gt; &#123; this.msg = ‘注册成功！‘ &#125;) 3.参考资料：参考官方文档$.ajax和vue-resource实现OAuthVue.js——vue-resource全攻略","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://lxchuan12.github.io/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://lxchuan12.github.io/tags/vuejs/"}],"keywords":[{"name":"vuejs","slug":"vuejs","permalink":"https://lxchuan12.github.io/categories/vuejs/"}]},{"title":"chrome跨域设置","slug":"20160811-chrome-settings","date":"2016-08-11T14:55:38.000Z","updated":"2016-10-19T15:29:34.907Z","comments":true,"path":"2016/08/11/20160811-chrome-settings/","link":"","permalink":"https://lxchuan12.github.io/2016/08/11/20160811-chrome-settings/","excerpt":"今天用vuejs,与后端联调,发现用localhost或者本机ip访问本地资源，和后端接口资源，没有数据，google发现是chrome的安全机制，不允许跨域……","text":"今天用vuejs,与后端联调,发现用localhost或者本机ip访问本地资源，和后端接口资源，没有数据，google发现是chrome的安全机制，不允许跨域…… 解决方案：浏览器版本：chrome 52。1、在桌面找到chrome浏览器快捷图标并点击鼠标右键的属性一栏。(或者任务栏选中chrome右击——google chrome右击属性) 2、在属性页面中的目标输入框里加上 –args –disable-web-security.–args可省略。或者试试：–disable-web-security –user-data-dir 3、点击应用和确定后关闭属性页面，并打开chrome浏览器即可。 使用本机ip地址加端口号，访问本地资源。","categories":[{"name":"调试技巧","slug":"调试技巧","permalink":"https://lxchuan12.github.io/categories/调试技巧/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://lxchuan12.github.io/tags/chrome/"}],"keywords":[{"name":"调试技巧","slug":"调试技巧","permalink":"https://lxchuan12.github.io/categories/调试技巧/"}]},{"title":"清除IE下input的默认叉","slug":"20160810-ms-clear","date":"2016-08-10T15:00:38.000Z","updated":"2016-08-10T15:50:19.919Z","comments":true,"path":"2016/08/10/20160810-ms-clear/","link":"","permalink":"https://lxchuan12.github.io/2016/08/10/20160810-ms-clear/","excerpt":"IE10下的Input Text和谷歌下面的 input search 一旦输入内容，会在最右端出现一个叉号，点击后，内容就会自动清空，input password有小眼睛，点击显示密码。看似方便，其实有些场景并不需要，需要写代码清除掉……","text":"IE10下的Input Text和谷歌下面的 input search 一旦输入内容，会在最右端出现一个叉号，点击后，内容就会自动清空，input password有小眼睛，点击显示密码。看似方便，其实有些场景并不需要，需要写代码清除掉……1234567891011121314151617181920212223242526/*--清除谷歌浏览器下的 text 叉号*/input::-webkit-text-cancel-button&#123; display: none;&#125; input[type=text]::-ms-clear&#123; display: none;&#125;/*--清除IE下的 search 叉号*//*当然如果想清除所有的input的话 ，只需把[type=search]去掉即可。*/input::-webkit-search-cancel-button&#123; display: none;&#125; input[type=search]::-ms-clear&#123; display: none;&#125;/* 小眼睛 */input[type=password]::-ms-reveal&#123; display:none;&#125; 待完善……","categories":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/tags/css/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://lxchuan12.github.io/categories/css/"}]},{"title":"line-height学习笔记","slug":"20160808-line-height","date":"2016-08-08T15:28:23.000Z","updated":"2016-08-09T15:09:26.569Z","comments":true,"path":"2016/08/08/20160808-line-height/","link":"","permalink":"https://lxchuan12.github.io/2016/08/08/20160808-line-height/","excerpt":"line-height看似简单，其实还是有挺多不知道的奥妙。比如line-height:300%,line-height:3,有什么不同……","text":"line-height看似简单，其实还是有挺多不知道的奥妙。比如line-height:300%,line-height:3,有什么不同…… 形式化语法1normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; 取值normal取决于用户代理。桌面浏览器（包括火狐浏览器）使用默认值，约为1.2，这取决于元素的 font-family。 所用的值是无单位数值乘以元素的 font size。计算出来的值与使用数值指定的一样。大多数情况下，使用这种方法设置line-height是首选方法，在继承情况下不会有异常的值。 指定 用于计算 line box 的高度。查看 获取可能的单位。 与元素自身的字体大小有关。计算出的值是给定的百分比值乘以元素计算出的字体大小。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;line-height&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;p&#123;margin:10px;background:#ddd;&#125;p+p&#123;margin-left:40px;&#125;body&#123;font-size:30px;&#125;.m-demo&#123;line-height:40px;&#125;.m-demo p&#123;background:#ddd;&#125;.m-demo .p1&#123;line-height:3em;&#125;.m-demo .p2&#123;line-height:300%;&#125;.m-demo .p3&#123;line-height:3;&#125;.m-demo2&#123;line-height:300%;&#125;.m-demo2 p&#123;background:#fbb;&#125;.m-demo2 .p1&#123;font-size:16px;&#125;.m-demo3&#123;line-height:3;&#125;.m-demo3 p&#123;background:#0dd;&#125;.m-demo3 .p1&#123;font-size:16px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;m-demo&quot;&gt; &lt;p&gt;行高：line-height:40px;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;行高：line-height:3em;&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;行高：line-height:300%;&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;行高：line-height:3;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;m-demo2&quot;&gt; &lt;p&gt;行高：line-height:300%;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;字体大小：font-size:16px;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;m-demo3&quot;&gt; &lt;p&gt;行高：line-height:3;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;字体大小：font-size:16px;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 自己的理解：1、normal由浏览器决定，一般是1.1到1.2之间，1.14左右。 2、最近遇到，安卓浏览器显示placeholder 垂直不居中，去掉line-height即可。或者line-height:normal。 3、font-size:30px;line-height:3em;(90px),line-height:300px;(90px),line-height:3;(90px)百分比和数字的区别：number是直接继承。（推荐使用无单位数值给line-height赋值）比如：m-demo2行高是90px;m-demo3行高是48px; 参见：MDN line-height参见：CSS3在线手册参见：css2.1规范 感悟，多查规范，看MDN。善用google搜索。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"(转)30个你必须记住的CSS选择器","slug":"20160807-The 30 CSS Selectors you Must Memorize","date":"2016-08-07T15:10:41.000Z","updated":"2016-09-08T13:57:25.487Z","comments":true,"path":"2016/08/07/20160807-The 30 CSS Selectors you Must Memorize/","link":"","permalink":"https://lxchuan12.github.io/2016/08/07/20160807-The 30 CSS Selectors you Must Memorize/","excerpt":"概述也许你了解了基本的 id,class和descendant选择器，并且整天都在调用，如果是这样的话，那你正在错过拥有灵活性更大的选择器。这篇文章里面提到的大部分选择器都是在CSS3标准下的，所以它们只能在相应最新版本的浏览器中才能生效，你完全应该把这些都记在你聪明的脑袋里面……","text":"概述也许你了解了基本的 id,class和descendant选择器，并且整天都在调用，如果是这样的话，那你正在错过拥有灵活性更大的选择器。这篇文章里面提到的大部分选择器都是在CSS3标准下的，所以它们只能在相应最新版本的浏览器中才能生效，你完全应该把这些都记在你聪明的脑袋里面…… 1. ** { margin: 0; padding: 0; } 在我们看比较高级的选择器之前，应该认识下这个众所周知的清空选择器。星号(*)会将页面上所有每一个元素都选到。许多开发者都用它来清空margin和padding。当然你在练习的时候使用这个没问题，但是我不建议在生产环境中使用它。它会给浏览器凭添许多不必要的东西。 *也可以用来选择某元素的所有子元素: #container * { border: 1px solid black; } 它会选中#container下的所有元素。当然，我还是不建议你去使用它。DEMO 兼容性： IE6+ Firefox Chrome Safari Opera 2.#X#container { width: 960px; margin: auto; } 在选择器中使用#可以用id来定位某个元素。大家通常都会这么使用，使用的时候大家还是得相当小心的。 需要问自己一下：我是不是必须要给这个元素来赋值个id来定位它呢？ id选择器是很严格的并且你没办法去复用它。如果可以的话，首先试试用标签名字，HTML5中的新元素，或者是伪类。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 3. .X.error { color: red; } 这是个class选择器。它跟id选择器不同的是，它可以定位多个元素。当你想对多个元素进行样式修饰的时候就可以使用class。当你要对某个特定的元素进行修饰那就是用id来定位它。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 4.X Yli a { text-decoration: none; } 下一个常用的就是descendant(后代)选择器(后代指所有后代，儿子、孙子后代等)。如果你想更加具体的去定位元素，你可以使用它。例如，假如，你不需要定位所有的a元素，而只需要定位li标签下的a标签？这时候你就需要使用descendant选择器了。 专家提示：如果你的选择器像X Y Z A B.error这样，那你就错了。时刻都提醒自己，是否真的需要对那么多元素修饰。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 5.Xa { color: red; } ul { margin-left: 0; } 如果你想定位页面上所有的某标签，不是通过id或者是’class’，这简单，直接使用类型选择器。DEMO 兼容性: IE6+ Firefox Chrome Safari Opera 6.X:visited 和 X:linka:link {color:red;} a:visited {color: purple;} 我们使用:link这个伪类来定位所有还没有被访问过的链接。另外，我们也使用:visited来定位所有已经被访问过的链接。DEMO 兼容性: IE7+ Firefox Chrome Safari Opera 7.X + Yul+p{ color:red; } 这被称作相邻选择符。它将只选择紧贴在X元素之后Y元素。上面的例子，仅每一个ul之后的第一个段落元素的文本为红色。DEMO 兼容性: IE7+ Firefox Chrome Safari Opera 8.X&gt;Ydiv#container &gt; ul{ border :1px solid black; } X Y和X &gt; Y之间的不同点是后者只选择直接子代。例如，考虑如下的标记。 &lt;div id=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt; List Item &lt;ul&gt; &lt;li&gt; Child &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 选择符#container &gt; ul将只选择id为container的div的直接子代ul。它不匹配更深层的li的子代的ul。因此，使用子代选择符有性能上的优势。事实上，这同样适用于基于css选择器的javascript引擎。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 9.X~Yul ~ p { color: red; } 这是兄弟选择符和X + Y一样，然而，它没有约束。与相邻选择符（ul + li）仅选择前一个选择符后面的第一个元素比起来，兄弟选择符更宽泛。它会选择，我们上面例子中更在ul后面的任何p元素。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 10.X[title]a[title] { color: green; } 被称为属性选择器，在我们上面的例子里，这只会选择有title属性的锚标签。没有此属性的锚标签将不受影像。但如果你需要更多的特性怎么办呢？呵呵……DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 11. X[href=”foo”]a[href=&quot;http://net.tutsplus.com&quot;] { color: #1f6053; /* nettuts green */ } 上面的代码段将给所有href属性为http://net.tutsplus.com的锚标签添加样式；他们将会显示为我们的品牌绿色。所有其他的锚标签将不受影响。 注意我们将href值用引号包裹。记住，当使用javascript的css选择符引擎时也这么做。如果可能的话，尽可能使用css3选择符代替非官方的方法。 这工作的很好，但有点不够灵活。如果链接确实直接连接到Nettus+还好，但是，也许路径是到nettust的相对路径呢？在这种情况下，我们可以使用一点正则表达式语法。 DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 12. X[href*=”nettuts”]a[href*=&quot;tuts&quot;] { color: #1f6053; /* nettuts green */ } 来了不是~这就是我们需要的代码。*号指定了包含该属性的值必须包含定义的值。就是说，这句代码包含了href值为 nettuts.com，net.tutsplus.com或者tutsplus.com。记住这个描述过于宽泛，如果是某个锚点标签链接到某个连接中带有tuts非Envato的网站（tutsplus属于Envato旗下网站）呢？因此你需要更多特性来限制，分别使用^和&amp;来限定字符串的开始和结束。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 13. X[href^=”http”]a[href^=&quot;http&quot;] { background: url(path/to/external/icon.png) no-repeat; padding-left: 10px; } 有没有想过某些网站是如何定义一个图标的链接的？我确定你肯定看到过。这些链接很容易让你跳转到另一个网站。使用^(carat)符灰常简单啦。这个符号常常在正则表达式中表示字符串的开始。如果我们想指向所有以”http”开头的”href”属性的锚点的话，我们就可以使用类似于上面的那段代码啦。 注意啦，我们不需要搜索”http://&quot;,完全没必要，因为我们还要包含以https://开头的链接呢。 如果我们想为所有链接到图片的链接定义样式咋办？这种情况下，我们得搜索字符串的结束了不是。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 14. X[href$=”.jpg”]a[href$=&quot;.jpg&quot;] { color: red; } 又来了，我们还是使用正则表达式符号，$(dolor)，来作为字符串的结束标记。这种情况下，我们就会搜索所有url以.jpg为结尾的锚点啦。记住记住这种情况下gif和png格式的图片不会被选择哦。DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 15. X[data-*=”foo”]a[data-filetype=&quot;image&quot;] { color: red; } 回顾最近一条，我们如何能包含各种图片类型:png,jpeg,jpg,gif?很容易想到，我们能通过多个选择器来不是，像这样： a[href$=&quot;.jpg&quot;], a[href$=&quot;.jpeg&quot;], a[href$=&quot;.png&quot;], a[href$=&quot;.gif&quot;] { color: red; } 不过，这样很蛋疼，效率极低。另一个解决办法是使用自定义属性。如果我们加了一种自己的 data-filetype 属性给每一个链接到图片的锚点的话呢？&lt;a href=&quot;path/to/image.jpg&quot; data-filetype=&quot;image&quot;&gt; Image Link &lt;/a&gt;这样关联后，我们就能使用标准的属性选择器来指定这些链接啦。看下面：DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 16. X[foo~=”bar”]a[data-info~=&quot;external&quot;] { color: red; } a[data-info~=&quot;image&quot;] { border: 1px solid black; } 这儿有个鲜为人知的特殊技巧，绝对让你印象时刻。~(tilda)符，它可以帮助我们指向那些以空格隔开多个值的属性的元素（真拗口，这翻译我自己都看不懂，水平问题）以我们第15条的自定义属性为例，上面的代码中我们创建了 data-info属性，这个属性可以定义以空格分隔的多个值。这样，这个链接本身就是个icon，并且指向的也是一个图片链接，像下面这样。&lt;a href=&quot;path/to/image.jpg&quot; data-info=&quot;external image&quot;&gt; Click Me, Fool &lt;/a&gt;有了这样适当的标记，通过使用 ~ 属性选择器的技巧，我们就可以指向任何具有着两种属性的任何一种啦。 /* Target data-info attr that contains the value &quot;external&quot; */ a[data-info~=&quot;external&quot;] { color: red; } /* And which contain the value &quot;image&quot; */ a[data-info~=&quot;image&quot;] { border: 1px solid black; } 很棒，不是吗？DEMO 兼容性 *IE7+ *Firefox *Chrome *Safari *Opera 17. X:checkedinput[type=radio]:checked { border: 1px solid black; } 这种伪类只会匹配已经被选中的单选元素。就是这么简单。DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari *Opera 18. X:afterinput[type=radio]:checked { border: 1px solid black; } before 和 after 伪类也很蛋疼。貌似人们每天都能找到或者发明一些新办法来有效地使用它们。它们很容易控制选择器周围的内容。很多第一次使用是因为他们需要对clear-fix进行改进。 .clearfix:after { content: &quot;&quot;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; } .clearfix { *display: inline-block; _height: 1%; } 这个改进使用了:after伪类元素来在元素后增加一个空间，然后清除它。这个牛X的技巧你应该收藏到工具包里，特别是当overflow:hidden方法无能为力的时候。想看看其他创造性的用法：访问我滴创建阴影的窍门 通过Css3选择器的标准说明书，你应该有技巧地使用这些伪类语法——双冒号::。不过为了兼容，浏览器会接受一个双引号。 兼容性 *IE8+ *Firefox *Chrome *Safari *Opera 19. X:hoverdiv:hover { background: #e3e3e3; } 我去，这个你必须懂。典型的官方形式的用户触发伪类。听起来会有点迷惑，不过实际上并非如此。想在用户在某个元素上面悬停时定义个特别的样式？这个属性就是做这个的。 记住啦，较old版本的IE，只能在锚点标签后使用这个hover。 这个选择器你用得最多的情况，估计可能就是在锚点的悬停时加个border-bottom啦。 a:hover { border-bottom: 1px solid black; } 小贴士： border-bottom:1px solid black;比 text-decoration:underline;好看一点哦。（真的？我去） 兼容性 *IE6+ (In IE6, :hover must be applied to an anchor element) *Firefox *Chrome *Safari *Opera 20. X:not(selector)div:not(#container) { color: blue; } not伪类灰常有用。例如我要选择所有的div，除了有id为container的。上面那个代码片段就能完美的实现。如果我想选择除了p以外的所有元素，我可以这么做： *:not(p) { color: green; } DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari *Opera 21. X::pseudoElementp::first-line { font-weight: bold; font-size: 1.2em; } 我们可以使用伪元素（以::为表示）来定义元素的样式。例如第一行，第一个字符，记住啦，这种方法只能应用于同级元素才有效。 伪元素由两个冒号组成：:: 指定p的第一个字符的样式 p::first-letter { float: left; font-size: 2em; font-weight: bold; font-family: cursive; padding-right: 2px; } 这段代码会找到所有段落，然后再从中定义这些段落的第一个字符。这常常使用在仿报纸的文章首字母样式。 指定p的首行样式 p::first-line { font-weight: bold; font-size: 1.2em; } 同样，这个::first-line伪元素会像我们期望的那样，只定义段落的第一行的样式。DEMO 兼容性 *IE6+ *Firefox *Chrome *Safari *Opera 22. X:nth-child(n)li:nth-child(3) { color: red; } 想想那些没法从元素堆中选择元素的日子。nth-child伪类解决了这个问题。请注意 nth-child接收整数和变量，不过不是从0开始的，如果你想选定第二个li，使用 li:nth-child(2).我们甚至使用这个办法来选择任意的子元素。例如，我们可以用 li:nth-child(4n)来完成4为倍数的所有元素的选择。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari *Opera 23. X:nth-last-child(n)li:nth-last-child(2) { color: red; } 如果我有灰常多的li在ul里面，我只想要最后3个li怎么办？不必使用li:nth-child(397),你可以使用nth-last-child伪类。这种技巧和第六条几乎一样有效，不过两者的不同之处在于它从结束开始收集，用回溯的方式进行。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 24. X:nth-of-type(n)ul:nth-of-type(3) { border: 1px solid black; } 你应该有很多时候想要元素类型来选择元素而不是通过孩子。想象一下标记5个无序列表（UL）。如果你想定义第三个ul，并且没有一个唯一的id来找到它，你就可以使用 nth-of-type(3)伪类了。在上面这个代码段中，只有第三个ul才会有黑色的边框。DEMO兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 25. X:nth-last-of-type(n)ul:nth-last-of-type(3) { border: 1px solid black; } 没错，我们一样可以使用nth-last-of-type来从结束开始回溯这个选择器，来找到我们想要的元素。 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 26. X:first-childul li:first-child { border-top: none; } 这个结构的伪类让我们可以选择某个元素的第一个子孩子。你通常可以使用这个办法来删除第一个或者最后一个元素的边框。例如，你有一系列的rows，每一个都有border-top 和border-bottom。这种情况下，第一行和最后一行看起来会灰常怪。很多设计师会使用first和last类来弥补这个缺陷。相反，你可以使用这些伪类来解决这些问题。DEMO 兼容性 *IE7+ *Firefox 3.5+ *Chrome *Safari 27. X:last-childul &gt; li:last-child { color: green; } 与first-child相反，last-child会选择父节点的最后一个子节点。 例子 我们建立一些例子来示范这些类的可能的用法。我们会建立一种风格来展示。标记 List Item List Item List Item 没啥特别的，就是一个简单的序列。 CSS ul { width: 200px; background: #292929; color: white; list-style: none; padding-left: 0; } li { padding: 10px; border-bottom: 1px solid black; border-top: 1px solid #3c3c3c; } 图片 这个样式会设置一个背景，删除浏览器默认的ul的padding值，并定义边框给每一个li来提供一点深度。 如上图所示，唯一的问题是最上面的边框和最下面的边框看起来有点儿怪。让我们来使用:first-child和:last-child来解决这个问题。 li:first-child { border-top: none; } li:last-child { border-bottom: none; } 图片 看上图，解决了不是。DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari 是滴，IE8支持 first-child 不过不支持last-child。 28. X:only-childdiv p:only-child { color: red; } 实话说，你很可能会发现你不会经常使用 only-child伪类。尽管如此，它确实有用，你应该需要它。它可以帮助你选择是父节点的独生子（没别的孩子啦）的元素。例如，使用上面的代码，只有是div的唯一子孩子的p段落才会定义其颜色为red。让我们来假定下面的标记。 &lt;div&gt;&lt;p&gt; My paragraph here. &lt;/p&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt; Two paragraphs total. &lt;/p&gt; &lt;p&gt; Two paragraphs total. &lt;/p&gt; &lt;/div&gt; 这样，第二个div的p标签的内容不会被选中。只有第一个div的p才会被选中。 DEMO 兼容性 *IE9+ *Firefox *Chrome *Safari 29. X:only-of-typeli:only-of-type { font-weight: bold; } 这种结构的伪类有几种灰常聪明的用法。它可以选定在其父节点内没有兄弟节点的元素。例如，我们可以选择只有一个li作为其子孩子的ul。首先，取决于你想怎样完成这一目标。你可以使用 ul li，不过，这回选择所有li元素。唯一的办法是使用only-of-type。 ul &gt; li:only-of-type { font-weight: bold; } DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari 30. X:first-of-typefirst-of-type 伪类可以让你选择该类型的第一个兄弟节点。 一个测试 为了更好地理解它，让我们来测试一下啊。拷贝下面的标记到你的编辑器。 现在，别急着往下读，试试看如何能只选择’LIST ITEM 2’?如果你搞定了（或者放弃了），继续读。 解决办法1 有很多办法能搞定这个测试。我们回顾其中一小部分。以使用first-of-type开始。 ul:first-of-type &gt; li:nth-child(2) { font-weight: bold; } 这个代码段本质上表示，“找到第一个无序列表，然后找到这里面的li，然后，继续使用过滤器直到找到第二个li。 解决办法2 另一个可行的办法是毗邻选择器。 p + ul li:last-child { font-weight: bold; } 在这个方案中，我们找到p的临近节点ul，然后找到ul的li的最后一个孩子。解决办法3 我们可以随心所欲滴选择这些选择器。 ul:first-of-type li:nth-last-child(1) { font-weight: bold; } 这次，我们取到第一个ul，然后找到第一个元素，不过是从最后一个开始数。哈哈。DEMO 兼容性 *IE9+ *Firefox 3.5+ *Chrome *Safari *Opera 结论如果你仍在为解决old浏览器的缺陷而纠结，如IE6。在使用这些新的选择器方面，你仍然需要非常小心。不过，别因为这个阻碍了你对这些新玩意儿的学习。别虐待自己。确保关注这里的兼容性列表。应一方面，你可以使用 Dean Edward’s excellent IE9.js script 来为旧浏览器提供新的选择器支持。（我去。cool）其次，当使用javascript库时，如流行的jQuery，最好尽可能使用这些css3本身的选择器而不是使用库的自定义方法/选择器。这能让你的代码更快哦，因为这些选择器引擎本身就能被浏览器解析，而不是用这些库选择器。感谢阅读，希望你能学到一两个技巧。 #译者注本文为翻译文章，原文为“The 30 CSS Selectors you Must Memorize” 本文转载于颜海镜的博客","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}],"tags":[{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://lxchuan12.github.io/tags/CSS选择器/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://lxchuan12.github.io/categories/CSS/"}]},{"title":"最近碰到的兼容性问题","slug":"20160806-tips","date":"2016-08-06T13:12:38.000Z","updated":"2016-08-07T15:32:49.337Z","comments":true,"path":"2016/08/06/20160806-tips/","link":"","permalink":"https://lxchuan12.github.io/2016/08/06/20160806-tips/","excerpt":"","text":"1、transfrom:translate3d(),兼容性:-webkit-安卓4.4+2、删除节点，elem.remove(),安卓4.2.2不支持。解决方案：elem.parentNode.removeChild(elem);","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/tags/前端开发/"},{"name":"兼容性","slug":"兼容性","permalink":"https://lxchuan12.github.io/tags/兼容性/"}],"keywords":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}]},{"title":"搭建hexo博客，记录前端开发","slug":"20160806-hexo","date":"2016-08-06T08:40:38.000Z","updated":"2016-08-20T15:51:54.470Z","comments":true,"path":"2016/08/06/20160806-hexo/","link":"","permalink":"https://lxchuan12.github.io/2016/08/06/20160806-hexo/","excerpt":"虽然有在简书上使用markdown写法发布一些文章，但不是前端相关的，主要是一些电脑技巧，PPT，读书笔记等。早就有想着搭建自己的博客，记录在前端开发的路上学到的知识……","text":"虽然有在简书上使用markdown写法发布一些文章，但不是前端相关的，主要是一些电脑技巧，PPT，读书笔记等。早就有想着搭建自己的博客，记录在前端开发的路上学到的知识……有人说，写博客，不要太在乎有多少阅读量。重要的是，写博客是自己对一些知识的理解，并且能写出来，这本身就是一种整理和成长。其实有记录自己前端开发所学知识，不过是保存在为知笔记上。现在看来，也可以写博客分享出来。 总之，慢慢坚持写博客。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lxchuan12.github.io/tags/hexo/"},{"name":"F2E","slug":"F2E","permalink":"https://lxchuan12.github.io/tags/F2E/"}],"keywords":[{"name":"前端开发","slug":"前端开发","permalink":"https://lxchuan12.github.io/categories/前端开发/"}]}]}