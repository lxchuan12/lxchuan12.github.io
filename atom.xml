<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轩辕Rowboat的博客</title>
  
  <subtitle>前端路上 | PPT爱好者 | 所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxchuan12.github.io/"/>
  <updated>2018-07-28T07:17:38.173Z</updated>
  <id>https://lxchuan12.github.io/</id>
  
  <author>
    <name>轩辕Rowboat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分享百度网盘下载搜索神器和一些实用浏览器插件</title>
    <link href="https://lxchuan12.github.io/2018/07/14/20180714-some%20baiduyunpan-and%20chrome%20crx/"/>
    <id>https://lxchuan12.github.io/2018/07/14/20180714-some baiduyunpan-and chrome crx/</id>
    <published>2018-07-14T14:42:50.000Z</published>
    <updated>2018-07-28T07:17:38.173Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间（端午节期间）折腾电脑，用虚拟机安装<code>mac 10.13</code>，但安装包太大，6.5G。<br>顺便放下我安装时参考的链接，说不定有人也想安装<code>mac</code>试试，不过我试验的是安装后比较卡。<a href="https://blog.csdn.net/icarus666/article/details/79536388" target="_blank" rel="noopener">验证在vm12下安装os 10.13的可行性（同适用 os 10.12.6）</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-17c2d7e071a258b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟机安装`mac`后截图.png" title="">                </div>                <div class="image-caption">虚拟机安装`mac`后截图.png</div>            </figure></p><p>文件在百度网盘中，但大家都知道百度云管家下载限制下载速度，按照限制的下载速度，不知道要下载到猴年马月。</p><h3 id="Proxyee-down-百度网盘下载神器"><a href="#Proxyee-down-百度网盘下载神器" class="headerlink" title="Proxyee-down 百度网盘下载神器"></a><code>Proxyee-down</code> 百度网盘下载神器</h3><p>于是我发现了一款百度网盘下载神器【<code>Proxyee-down</code>】（支持<code>Win/Mac/Linux</code>的百度云文件下载工具），据说下载速度不止2M/s，可以跑到20M/s。当然也跟所在网络环境有关。总之要比官方百度云管家下载速度要快。<br><a href="https://pan.lanzou.com/b203390" target="_blank" rel="noopener">下载地址（根据不同系统安装不同版本）</a><br>项目开源，安装教程等相关都可以在这个链接里找到。我就不附图了。<br><a href="https://github.com/proxyee-down-org/proxyee-down" target="_blank" rel="noopener"><code>proxyee-down</code>项目地址</a></p><h3 id="云盘万能钥匙-插件"><a href="#云盘万能钥匙-插件" class="headerlink" title="云盘万能钥匙 插件"></a>云盘万能钥匙 插件</h3><p>既然推荐了百度网盘下载工具，那就再推荐 云盘万能钥匙这个插件。<br><a href="http://www.ypsuperkey.com/" target="_blank" rel="noopener">云盘万能钥匙官网</a><br><a href="https://chrome.google.com/webstore/detail/%E4%BA%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/anlllmnpjodopgbkbpnghnjlelnogfjc?hl=zh-CN" target="_blank" rel="noopener">谷歌应用商店安装地址</a><br>官方是这样推荐的。<br>1.自动识别并填写提取密码，懒癌患者的福音<br>2.每当点击一个分享链接，却提示我分享已失效时，我的内心是崩溃的<br>3.尊重个人隐私<br>可以根据不同浏览器下载安装不同版本插件。不科学上网也可以下载安装。如何科学上网就自行百度研究了。简要推荐一个插件<code>skyZIP-Proxy</code>。<br><a href="http://www.ypsuperkey.com/helps/add-ypsuperkey-to-chrome" target="_blank" rel="noopener">在谷歌浏览器中离线安装、卸载和更新云盘万能钥匙</a></p><p>可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何离线安装可以参看这篇文章<a href="https://www.jianshu.com/p/12ca04c61fc6" target="_blank" rel="noopener">如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？</a>，也可以参看上文推荐【在谷歌浏览器中安装、卸载和更新云盘万能钥匙】文章。<br>不过还是简单说下离线安装步骤：把下载下<code>YPSuperKey-For-Chrome-Only.crx</code>文件，（如果没有扩展名，那设置显示）改成<code>YPSuperKey-For-Chrome-Only.zip</code>，然后用好压等工具解压出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-3722a404430cafce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YPSuperKey-For-Chrome-Only文件夹.png" title="">                </div>                <div class="image-caption">YPSuperKey-For-Chrome-Only文件夹.png</div>            </figure></p><p>打开<code>chrome</code>浏览器，按图所示，依次打开【更多工具】 -  【扩展程序】 - 勾选【开发者模式】【加载已解压的扩展程序】，选择刚刚的文件夹，安装这个插件成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-589dca8f83258f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="【更多工具】 -  【扩展程序】.png" title="">                </div>                <div class="image-caption">【更多工具】 -  【扩展程序】.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-29cf1303be96d7a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开发模式 - 加载已解压的扩展程序.png" title="">                </div>                <div class="image-caption">开发模式 - 加载已解压的扩展程序.png</div>            </figure></p><h3 id="ghostery-隐私广告拦截工具-插件"><a href="#ghostery-隐私广告拦截工具-插件" class="headerlink" title="ghostery 隐私广告拦截工具 插件"></a><code>ghostery</code> 隐私广告拦截工具 插件</h3><p>说到隐私，推荐这个插件，能够屏蔽网站统计收集用户信息。<br><a href="https://chrome.google.com/webstore/detail/ghostery-%E2%80%93-privacy-ad-blo/mlomiejdfkolichcflejclcbmpeaniij" target="_blank" rel="noopener">应用商店下载安装</a></p><h3 id="二维码生成-插件"><a href="#二维码生成-插件" class="headerlink" title="二维码生成 插件"></a>二维码生成 插件</h3><p>有时需要手机上访问电脑浏览器上某个地址，直接输入太长，不现实。这时候这个插件就很有用了。<br><a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="云盘精灵，一个更好的网盘搜索引擎"><a href="#云盘精灵，一个更好的网盘搜索引擎" class="headerlink" title="云盘精灵，一个更好的网盘搜索引擎"></a>云盘精灵，一个更好的网盘搜索引擎</h3><p><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵官网</a> 这网站有时需要科学上网访问。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-913aa1fc467b15c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索罗小川chuan的结果，之前写的文章配套资源.png" title="">                </div>                <div class="image-caption">搜索罗小川chuan的结果，之前写的文章配套资源.png</div>            </figure></p><p>官方是这样推荐的。</p><ol><li>基于【云盘万能钥匙】收录的海量数据</li><li>支持搜索带提取密码的分享资源</li><li>资源链接失效时立即移除出搜索数据库</li><li>简洁清新的界面设计（没有低俗的广告）</li></ol><h3 id="adblock-plus-屏蔽广告插件。"><a href="#adblock-plus-屏蔽广告插件。" class="headerlink" title="adblock-plus 屏蔽广告插件。"></a><code>adblock-plus</code> 屏蔽广告插件。</h3><p>说到广告啊。我用<code>chrome</code>  <code>adblock-plus</code>插件<br><a href="https://chrome.google.com/weipibstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">应用商店安装地址</a><br>屏蔽各种网站广告。</p><h3 id="网页截图插件-fireShot-系统截图PicPick软件"><a href="#网页截图插件-fireShot-系统截图PicPick软件" class="headerlink" title="网页截图插件 fireShot , 系统截图PicPick软件"></a>网页截图插件 <code>fireShot</code> , 系统截图<code>PicPick</code>软件</h3><p><a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg" target="_blank" rel="noopener">应用商店下载地址</a><br>有时需要截取整个网页，这个插件可以做到。<br>跳出网站，系统截图我推荐<code>Snipaste</code>或者<code>PicPick</code>软件。<br><a href="https://www.snipaste.com/" target="_blank" rel="noopener"><code>Snipaste</code>官网</a>，<code>win10</code>也可以通过<code>Microsoft Store 下载安装</code>。<br><a href="https://picpick.app/" target="_blank" rel="noopener"><code>PicPick</code>官网</a>。<br>说到截图顺带提下，win系统下，按<code>PrintScreen</code>键截取整个屏幕、按<code>Alt</code>键+<code>PrintScreen</code>键截取活动窗口、按<code>Win键+</code>PrintScreen<code>键截取整个屏幕，并保存在【图片】 - 【屏幕截图】 中，一般是</code>C:\Users{你的用户名}\Pictures\Screenshots<code>中。（PS:这个按Win键+</code>PrintScreen`键，我也是前不久才发现，真是活到老，学到老。）</p><h3 id="鼠标手势插件-crxMouse-插件"><a href="#鼠标手势插件-crxMouse-插件" class="headerlink" title="鼠标手势插件 crxMouse 插件"></a>鼠标手势插件 <code>crxMouse</code> 插件</h3><p>鼠标右击画一些手势，可以操作浏览器，控制前进、后退，关闭，翻页等。很好用。<br><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo" target="_blank" rel="noopener">应用商店地址</a></p><h3 id="OneTab-插件，节省内存，减轻标签页混乱现象"><a href="#OneTab-插件，节省内存，减轻标签页混乱现象" class="headerlink" title="OneTab  插件，节省内存，减轻标签页混乱现象"></a><code>OneTab</code>  插件，节省内存，减轻标签页混乱现象</h3><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">应用商店下载安装地址</a><br>官方是这样推荐的：节省高达95％的内存，并减轻标签页混乱现象<br>有时打开很多页面，没有及时关闭，就占用挺大内存，这个插件可以一键收起。以后再打开。当然还有更多功能。</p><h3 id="octotree-树形结构-查看github项目"><a href="#octotree-树形结构-查看github项目" class="headerlink" title="octotree 树形结构 查看github项目"></a><code>octotree</code> 树形结构 查看<code>github</code>项目</h3><p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="noopener">应用商店下载安装地址</a><br><a href="https://github.com/buunguyen/octotree" target="_blank" rel="noopener">github项目地址</a></p><h3 id="Octo-Mate-增强你的-github-体验"><a href="#Octo-Mate-增强你的-github-体验" class="headerlink" title="Octo Mate, 增强你的 github 体验"></a><code>Octo Mate</code>, 增强你的 <code>github</code> 体验</h3><p>能一键下载文件和目录形式查看文档等。<br><a href="https://chrome.google.com/webstore/detail/octo-mate/baggcehellihkglakjnmnhpnjmkbmpkf" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="一键管理-扩展-插件"><a href="#一键管理-扩展-插件" class="headerlink" title="一键管理 扩展 插件"></a>一键管理 扩展 插件</h3><p>安装了那么多插件，不常用的可以先停用，这个插件可以一键管理这些插件。<br><a href="https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86/kfjmkgngkgpgjdoealkmmajmmhpnffoj" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当然我安装了很多插件和软件，先推荐这些给大家，后续有时间再更新。还有更多好玩实用的插件和软件等着我们去发掘。<br>写到这里好久之前写过这样一篇文章<a href="https://www.jianshu.com/p/93d9fbb9ad92" target="_blank" rel="noopener">提高效率的电脑技巧及软件</a>，可以看看。<br>本着<strong>学我所学，为我所用，服务他人</strong>的宗旨^_^，这篇文章主要推荐了：<br>1、<code>Proxyee-down</code> 百度网盘下载神器<br>2、云盘万能钥匙 插件<br>3、<code>ghostery</code> 隐私广告拦截工具 插件<br>4、二维码生成 插件<br>5、云盘精灵，一个更好的网盘搜索引擎<br>6、<code>adblock-plus</code> 屏蔽广告插件。<br>7、网页截图插件 <code>fireShot</code> , 系统截图<code>Snipaste</code>或者<code>PicPick</code>软件<br>8、鼠标手势插件 <code>crxMouse</code> 插件<br>9、<code>OneTab</code>  插件，节省内存，减轻标签页混乱现象<br>10、<code>Octotree</code> 树形结构 查看<code>github</code>项目<br>11、<code>Octo Mate</code>, 增强 <code>github</code> 体验<br>12、一键管理 扩展 插件</p><p>文章同时发布在我的个人博客上：<a href="http://lxchuan12.github.io/2018/07/14/20180714-some%20baiduyunpan-and%20chrome%20crx/">分享百度网盘下载搜索神器和一些实用浏览器插件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间（端午节期间）折腾电脑，用虚拟机安装&lt;code&gt;mac 10.13&lt;/code&gt;，但安装包太大，6.5G。&lt;br&gt;顺便放下我安装时参考的链接，说不定有人也想安装&lt;code&gt;mac&lt;/code&gt;试试，不过我试验的是安装后比较卡。&lt;a href=&quot;https://blo
      
    
    </summary>
    
      <category term="实用技巧" scheme="https://lxchuan12.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="chrome" scheme="https://lxchuan12.github.io/tags/chrome/"/>
    
      <category term="skyDrive" scheme="https://lxchuan12.github.io/tags/skyDrive/"/>
    
      <category term="baidu" scheme="https://lxchuan12.github.io/tags/baidu/"/>
    
  </entry>
  
  <entry>
    <title>分析vue-cli@2.9.3 搭建的webpack项目工程</title>
    <link href="https://lxchuan12.github.io/2018/06/11/20180611-analyse-vue-cli/"/>
    <id>https://lxchuan12.github.io/2018/06/11/20180611-analyse-vue-cli/</id>
    <published>2018-06-11T12:22:38.000Z</published>
    <updated>2018-06-12T14:29:33.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>已经有很多分析<code>Vue-cli</code>搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p><strong>项目放在笔者的<code>github</code>上，<a href="https://github.com/lxchuan12/analyse-vue-cli" target="_blank" rel="noopener">分析vue-cli@2.9.3 搭建的webpack项目工程</a>。方便大家克隆下载，或者在线查看。同时也求个<code>star</code> <code>^_^</code>，也是对笔者的一种鼓励和支持。</strong></p><p>正文从这里开始～</p><h3 id="使用vue-cli初始化webpack工程"><a href="#使用vue-cli初始化webpack工程" class="headerlink" title="使用vue-cli初始化webpack工程"></a>使用<code>vue-cli</code>初始化<code>webpack</code>工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// # 安装</span><br><span class="line">npm install -g vue-cli</span><br><span class="line">// 安装完后vue命令就可以使用了。实际上是全局注册了vue、vue-init、vue-list几个命令</span><br><span class="line"></span><br><span class="line">// # ubuntu 系统下</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue-init@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-init</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue-list@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-list</span><br><span class="line"></span><br><span class="line">vue list</span><br><span class="line">// 可以发现有browserify、browserify-simple、pwa、simple、webpack、webpack-simple几种模板可选，这里选用webpack。</span><br><span class="line"></span><br><span class="line">// # 使用 vue init</span><br><span class="line">vue init &lt;template-name&gt; &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line">// # 例子</span><br><span class="line">vue init webpack analyse-vue-cli</span><br></pre></td></tr></table></figure><p>更多<code>vue-cli</code>如何工作的可以查看这篇文章<a href="https://juejin.im/post/5a7b1b86f265da4e8f049081" target="_blank" rel="noopener">vue-cli是如何工作的</a>，或者分析Vue-cli源码查看这篇<a href="https://segmentfault.com/a/1190000013975247" target="_blank" rel="noopener">走进Vue-cli源码，自己动手搭建前端脚手架工具</a>，再或者直接查看<a href="https://github.com/vuejs/vue-cli/tree/master" target="_blank" rel="noopener">vue-cli github仓库源码</a></p><p>如果对<code>webpack</code>还不是很了解，可以查看<a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">webpack官方文档中的概念</a>，虽然是最新版本的，但概念都是差不多的。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>分析一个项目，一般从<code>package.json</code>的命令入口<code>scripts</code>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  // dev webpack-dev-server --inline 模式 --progress 显示进度 --config 指定配置文件（默认是webpack.config.js）</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">  // jest测试</span><br><span class="line">  &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,</span><br><span class="line">  // e2e测试</span><br><span class="line">  &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;,</span><br><span class="line">  // 运行jest测试和e2e测试</span><br><span class="line">  &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;,</span><br><span class="line">  // eslint --ext 指定扩展名和相应的文件</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;,</span><br><span class="line">  // node 执行build/build.js文件</span><br><span class="line">  &quot;build&quot;: &quot;node build/build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p><code>Npm Script</code> 底层实现原理是通过调用 <code>Shell</code> 去运行脚本命令。<code>npm run start</code>等同于运行<code>npm run dev</code>。</p><p><code>Npm Script</code> 还有一个重要的功能是能运行安装到项目目录里的 <code>node_modules</code> 里的可执行模块。</p><p>例如在通过命令<code>npm i -D webpack-dev-server</code>将<code>webpack-dev-server</code>安装到项目后，是无法直接在项目根目录下通过命令 <code>webpack-dev-server</code> 去执行 <code>webpack-dev-server</code> 构建的，而是要通过命令 <code>./node_modules/.bin/webpack-dev-server</code> 去执行。</p><p><code>Npm Script</code> 能方便的解决这个问题，只需要在 <code>scripts</code> 字段里定义一个任务，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span><br></pre></td></tr></table></figure></p><p><code>Npm Script</code> 会先去项目目录下的 <code>node_modules</code> 中寻找有没有可执行的 <code>webpack-dev-server</code> 文件，如果有就使用本地的，如果没有就使用全局的。 所以现在执行 <code>webpack-dev-server</code> 启动服务时只需要通过执行 <code>npm run dev</code> 去实现。</p><blockquote><p>再来看下 npm run dev<br> <code>webpack-dev-server</code> 其实是一个<code>node.js</code>的应用程序，它是通过<code>JavaScript</code>开发的。在命令行执行<code>npm run dev</code>命令等同于执行<code>node ./node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js</code>。你可以试试。</p></blockquote><p>更多<code>package.json</code>的配置项，可以查看<a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">阮一峰老师的文章 package.json文件</a></p><p><code>npm run dev</code>指定了<code>build/webpack.dev.conf.js</code>配置去启动服务，那么我们来看下这个文件做了什么。</p><h3 id="build-webpack-dev-conf-js-webpack开发环境配置"><a href="#build-webpack-dev-conf-js-webpack开发环境配置" class="headerlink" title="build/webpack.dev.conf.js webpack开发环境配置"></a><code>build/webpack.dev.conf.js</code> <code>webpack</code>开发环境配置</h3><p>这个文件主要做了以下几件事情：<br>1、引入各种依赖，同时也引入了<code>config</code>文件夹下的变量和配置，和一个工具函数<code>build/utils.js</code>，<br>2、合并<code>build/webpack.base.conf.js</code>配置文件，<br>3、配置开发环境一些<code>devServer</code>，<code>plugin</code>等配置，<br>4、最后导出了一个<code>Promise</code>，根据配置的端口，寻找可用的端口来启动服务。</p><p>具体可以看<code>build/webpack.dev.conf.js</code>这个文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 引入工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js配置</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 合并webpack配置</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 基本配置</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)</span><br><span class="line">// 拷贝插件</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">// 生成html的插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">// 友好提示的插件 https://github.com/geowarin/friendly-errors-webpack-plugin</span><br><span class="line">const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)</span><br><span class="line">// 查找可用端口 // github仓库 https://github.com/indexzero/node-portfinder</span><br><span class="line">const portfinder = require(&apos;portfinder&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// process模块用来与当前进程互动，可以通过全局变量process访问，不必使用require命令加载。它是一个EventEmitter对象的实例。</span><br><span class="line"></span><br><span class="line">// 后面有些process模块用到的，所以这里统一列举下。</span><br><span class="line">// 更多查看这篇阮一峰的这篇文章 http://javascript.ruanyifeng.com/nodejs/process.html</span><br><span class="line"></span><br><span class="line">// process对象提供一系列属性，用于返回系统信息。</span><br><span class="line">// process.pid：当前进程的进程号。</span><br><span class="line">// process.version：Node的版本，比如v0.10.18。</span><br><span class="line">// process.platform：当前系统平台，比如Linux。</span><br><span class="line">// process.title：默认值为“node”，可以自定义该值。</span><br><span class="line">// process.argv：当前进程的命令行参数数组。</span><br><span class="line">// process.env：指向当前shell的环境变量，比如process.env.HOME。</span><br><span class="line">// process.execPath：运行当前进程的可执行文件的绝对路径。</span><br><span class="line">// process.stdout：指向标准输出。</span><br><span class="line">// process.stdin：指向标准输入。</span><br><span class="line">// process.stderr：指向标准错误。</span><br><span class="line"></span><br><span class="line">// process对象提供以下方法：</span><br><span class="line">// process.exit()：退出当前进程。</span><br><span class="line">// process.cwd()：返回运行当前脚本的工作目录的路径。_</span><br><span class="line">// process.chdir()：改变工作目录。</span><br><span class="line">// process.nextTick()：将一个回调函数放在下次事件循环的顶部。</span><br><span class="line"></span><br><span class="line">// host</span><br><span class="line">const HOST = process.env.HOST</span><br><span class="line">// 端口</span><br><span class="line">const PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)</span><br><span class="line"></span><br><span class="line">// 合并基本的webpack配置</span><br><span class="line">const devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    // cssSourceMap这里配置的是true</span><br><span class="line">    rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // cheap-module-eval-source-map is faster for development</span><br><span class="line">  // 在开发环境是cheap-module-eval-source-map选项更快</span><br><span class="line">  // 这里配置的是cheap-module-eval-source-map</span><br><span class="line">  // 更多可以查看中文文档：https://webpack.docschina.org/configuration/devtool/#devtool</span><br><span class="line">  // 英文 https://webpack.js.org/configuration/devtool/#development</span><br><span class="line">  devtool: config.dev.devtool,</span><br><span class="line"></span><br><span class="line">  // these devServer options should be customized in /config/index.js</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // 配置在客户端的日志等级，这会影响到你在浏览器开发者工具控制台里看到的日志内容。</span><br><span class="line">    // clientLogLevel 是枚举类型，可取如下之一的值 none | error | warning | info。</span><br><span class="line">    // 默认为 info 级别，即输出所有类型的日志，设置成 none 可以不输出任何日志。</span><br><span class="line">    clientLogLevel: &apos;warning&apos;,</span><br><span class="line">    // historyApiFallback boolean object 用于方便的开发使用了 HTML5 History API 的单页应用。</span><br><span class="line">    // 可以简单true 或者 任意的 404 响应可以提供为 index.html 页面。</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      rewrites: [</span><br><span class="line">        // config.dev.assetsPublicPath 这里是 /</span><br><span class="line">        &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    // 开启热更新</span><br><span class="line">    hot: true,</span><br><span class="line">    // contentBase 配置 DevServer HTTP 服务器的文件根目录。</span><br><span class="line">    // 默认情况下为当前执行目录，通常是项目根目录，所有一般情况下你不必设置它，除非你有额外的文件需要被 DevServer 服务。</span><br><span class="line">    contentBase: false, // since we use CopyWebpackPlugin.</span><br><span class="line">    // compress 配置是否启用 gzip 压缩。boolean 为类型，默认为 false。</span><br><span class="line">    compress: true,</span><br><span class="line">    // host</span><br><span class="line">    // 例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 --host 0.0.0.0</span><br><span class="line">    // 或者直接设置为 0.0.0.0</span><br><span class="line">    // 这里配置的是localhost</span><br><span class="line">    host: HOST || config.dev.host,</span><br><span class="line">    // 端口号 这里配置的是8080</span><br><span class="line">    port: PORT || config.dev.port,</span><br><span class="line">    // 打开浏览器，这里配置是不打开false</span><br><span class="line">    open: config.dev.autoOpenBrowser,</span><br><span class="line">    // 是否在浏览器以遮罩形式显示报错信息 这里配置的是true</span><br><span class="line">    overlay: config.dev.errorOverlay</span><br><span class="line">      ? &#123; warnings: false, errors: true &#125;</span><br><span class="line">      : false,</span><br><span class="line">      // 这里配置的是 /</span><br><span class="line">    publicPath: config.dev.assetsPublicPath,</span><br><span class="line">    // 代理 这里配置的是空&#123;&#125;,有需要可以自行配置</span><br><span class="line">    proxy: config.dev.proxyTable,</span><br><span class="line">    // 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    // 开启后一般非常干净只有类似的提示 Your application is running here: http://localhost:8080</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin</span><br><span class="line">    // webpack-dev-middleware</span><br><span class="line">    // watch: false,</span><br><span class="line">    // 启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。Watch 模式默认关闭。</span><br><span class="line">    // webpack-dev-server 和 webpack-dev-middleware 里 Watch 模式默认开启。</span><br><span class="line">    // Watch 模式的选项</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">      // 或者指定毫秒为单位进行轮询。</span><br><span class="line">      // 这里配置为false</span><br><span class="line">      poll: config.dev.poll,</span><br><span class="line">    &#125;</span><br><span class="line">    // 更多查看中文文档：https://webpack.docschina.org/configuration/watch/#src/components/Sidebar/Sidebar.jsx</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 定义为开发环境</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      // 这里是 &#123; NODE_ENV: &apos;&quot;development&quot;&apos; &#125;</span><br><span class="line">      &apos;process.env&apos;: require(&apos;../config/dev.env&apos;)</span><br><span class="line">    &#125;),</span><br><span class="line">    // 热更新插件</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    // 热更新时显示具体的模块路径</span><br><span class="line">    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.</span><br><span class="line">    // 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    // github仓库 https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: &apos;index.html&apos;,</span><br><span class="line">      // inject 默认值 true，script标签位于html文件的 body 底部</span><br><span class="line">      // body 通true, header, script 标签位于 head 标签内</span><br><span class="line">      // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;),</span><br><span class="line">    // copy custom static assets</span><br><span class="line">    // 把static资源复制到相应目录。</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        // 这里是 static</span><br><span class="line">        from: path.resolve(__dirname, &apos;../static&apos;),</span><br><span class="line">        // 这里是 static</span><br><span class="line">        to: config.dev.assetsSubDirectory,</span><br><span class="line">        // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git</span><br><span class="line">        ignore: [&apos;.*&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">// 导出一个promise</span><br><span class="line">module.exports = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // process.env.PORT 可以在命令行指定端口号，比如PORT=2000 npm run dev，那访问就是http://localhost:2000</span><br><span class="line">  // config.dev.port 这里配置是 8080</span><br><span class="line">  portfinder.basePort = process.env.PORT || config.dev.port</span><br><span class="line">  // 以配置的端口为基准，寻找可用的端口，比如：如果8080占用，那就8081,以此类推</span><br><span class="line">  // github仓库 https://github.com/indexzero/node-portfinder</span><br><span class="line">  portfinder.getPort((err, port) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // publish the new Port, necessary for e2e tests</span><br><span class="line">      process.env.PORT = port</span><br><span class="line">      // add port to devServer config</span><br><span class="line">      devWebpackConfig.devServer.port = port</span><br><span class="line"></span><br><span class="line">      // Add FriendlyErrorsPlugin</span><br><span class="line">      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123;</span><br><span class="line">        compilationSuccessInfo: &#123;</span><br><span class="line">          messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`],</span><br><span class="line">        &#125;,</span><br><span class="line">        // notifyOnErrors 这里配置是 true</span><br><span class="line">        // onErrors 是一个函数，出错输出错误信息，系统原生的通知</span><br><span class="line">        onErrors: config.dev.notifyOnErrors</span><br><span class="line">        ? utils.createNotifierCallback()</span><br><span class="line">        : undefined</span><br><span class="line">      &#125;))</span><br><span class="line"></span><br><span class="line">      resolve(devWebpackConfig)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="build-utils-js-工具函数"><a href="#build-utils-js-工具函数" class="headerlink" title="build/utils.js 工具函数"></a><code>build/utils.js</code> 工具函数</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/utils.js</code>工具函数。<br>该文件主要写了以下几个工具函数：<br>1、<code>assetsPath</code>返回输出路径，<br>2、<code>cssLoaders</code>返回相应的<code>css-loader</code>配置，<br>3、<code>styleLoaders</code>返回相应的处理样式的配置，<br>4、<code>createNotifierCallback</code>创建启动服务时出错时提示信息回调。</p><p>具体配置可以看该文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入配置文件config/index.js</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 提取css的插件</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line">// 引入package.json配置</span><br><span class="line">const packageConfig = require(&apos;../package.json&apos;)</span><br><span class="line">// 返回路径</span><br><span class="line">exports.assetsPath = function (_path) &#123;</span><br><span class="line">  const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">    // 二级目录 这里是 static</span><br><span class="line">    ? config.build.assetsSubDirectory</span><br><span class="line">    // 二级目录 这里是 static</span><br><span class="line">    : config.dev.assetsSubDirectory</span><br><span class="line"></span><br><span class="line">  // 生成跨平台兼容的路径</span><br><span class="line">  // 更多查看Node API链接：https://nodejs.org/api/path.html#path_path_posix</span><br><span class="line">  return path.posix.join(assetsSubDirectory, _path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.cssLoaders = function (options) &#123;</span><br><span class="line">  // 作为参数传递进来的options对象</span><br><span class="line">  // &#123;</span><br><span class="line">  //   // sourceMap这里是true</span><br><span class="line">  //   sourceMap: true,</span><br><span class="line">  //   // 是否提取css到单独的css文件</span><br><span class="line">  //   extract: true,</span><br><span class="line">  //   // 是否使用postcss</span><br><span class="line">  //   usePostCSS: true</span><br><span class="line">  // &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const cssLoader = &#123;</span><br><span class="line">    loader: &apos;css-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const postcssLoader = &#123;</span><br><span class="line">    loader: &apos;postcss-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // generate loader string to be used with extract text plugin</span><br><span class="line">  // 创建对应的loader配置</span><br><span class="line">  function generateLoaders (loader, loaderOptions) &#123;</span><br><span class="line">    // 是否使用usePostCSS，来决定是否采用postcssLoader</span><br><span class="line">    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]</span><br><span class="line"></span><br><span class="line">    if (loader) &#123;</span><br><span class="line">      loaders.push(&#123;</span><br><span class="line">        loader: loader + &apos;-loader&apos;,</span><br><span class="line">        // 合并 loaderOptions 生成options</span><br><span class="line">        options: Object.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">          sourceMap: options.sourceMap</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Extract CSS when that option is specified</span><br><span class="line">    // (which is the case during production build)</span><br><span class="line">    if (options.extract) &#123;</span><br><span class="line">      // 如果提取使用ExtractTextPlugin插件提取</span><br><span class="line">      // 更多配置 看插件中文文档：https://webpack.docschina.org/plugins/extract-text-webpack-plugin/</span><br><span class="line">      return ExtractTextPlugin.extract(&#123;</span><br><span class="line">        // 指需要什么样的loader去编译文件</span><br><span class="line">        // loader 被用于将资源转换成一个 CSS 导出模块 (必填)</span><br><span class="line">        use: loaders,</span><br><span class="line">        // loader（例如 &apos;style-loader&apos;）应用于当 CSS 没有被提取(也就是一个额外的 chunk，当 allChunks: false)</span><br><span class="line">        fallback: &apos;vue-style-loader&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return [&apos;vue-style-loader&apos;].concat(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // https://vue-loader.vuejs.org/en/configurations/extract-css.html</span><br><span class="line">  return &#123;</span><br><span class="line">    css: generateLoaders(),</span><br><span class="line">    postcss: generateLoaders(),</span><br><span class="line">    less: generateLoaders(&apos;less&apos;),</span><br><span class="line">    // sass indentedSyntax 语法缩进，类似下方格式</span><br><span class="line">    // #main</span><br><span class="line">    //   color: blue</span><br><span class="line">    //   font-size: 0.3em</span><br><span class="line">    sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;),</span><br><span class="line">    scss: generateLoaders(&apos;sass&apos;),</span><br><span class="line">    stylus: generateLoaders(&apos;stylus&apos;),</span><br><span class="line">    styl: generateLoaders(&apos;stylus&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Generate loaders for standalone style files (outside of .vue)</span><br><span class="line">// 最终会返回webpack css相关的配置</span><br><span class="line">exports.styleLoaders = function (options) &#123;</span><br><span class="line">  // &#123;</span><br><span class="line">  //   // sourceMap这里是true</span><br><span class="line">  //   sourceMap: true,</span><br><span class="line">  //   // 是否提取css到单独的css文件</span><br><span class="line">  //   extract: true,</span><br><span class="line">  //   // 是否使用postcss</span><br><span class="line">  //   usePostCSS: true</span><br><span class="line">  // &#125;</span><br><span class="line">  const output = []</span><br><span class="line">  const loaders = exports.cssLoaders(options)</span><br><span class="line"></span><br><span class="line">  for (const extension in loaders) &#123;</span><br><span class="line">    const loader = loaders[extension]</span><br><span class="line">    output.push(&#123;</span><br><span class="line">      test: new RegExp(&apos;\\.&apos; + extension + &apos;$&apos;),</span><br><span class="line">      use: loader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// npm run dev 出错时， FriendlyErrorsPlugin插件 配置 onErrors输出错误信息</span><br><span class="line">exports.createNotifierCallback = () =&gt; &#123;</span><br><span class="line">  // &apos;node-notifier&apos;是一个跨平台系统通知的页面，当遇到错误时，它能用系统原生的推送方式给你推送信息</span><br><span class="line">  const notifier = require(&apos;node-notifier&apos;)</span><br><span class="line"></span><br><span class="line">  return (severity, errors) =&gt; &#123;</span><br><span class="line">    if (severity !== &apos;error&apos;) return</span><br><span class="line"></span><br><span class="line">    const error = errors[0]</span><br><span class="line">    const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop()</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      title: packageConfig.name,</span><br><span class="line">      message: severity + &apos;: &apos; + error.name,</span><br><span class="line">      subtitle: filename || &apos;&apos;,</span><br><span class="line">      icon: path.join(__dirname, &apos;logo.png&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-webpack-base-conf-js-webpack基本配置文件"><a href="#build-webpack-base-conf-js-webpack基本配置文件" class="headerlink" title="build/webpack.base.conf.js webpack基本配置文件"></a><code>build/webpack.base.conf.js</code> <code>webpack</code>基本配置文件</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/webpack.base.conf.js</code>这个<code>webpack</code>基本配置文件。<br>这个文件主要做了以下几件事情：<br>1、引入各种插件、配置等，其中引入了<code>build/vue-loader.conf.js</code>相关配置，<br>2、创建<code>eslint</code>规则配置，默认启用，<br>3、导出<code>webpack</code>配置对象，其中包含<code>context</code>，入口<code>entry</code>，输出<code>output</code>，<code>resolve</code>，<code>module</code>下的<code>rules</code>（处理对应文件的规则），和<code>node</code>相关的配置等。</p><p>具体可以看这个文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// 使用严格模式，更多严格模式可以查看</span><br><span class="line">// [阮一峰老师的es标准入门](http://es6.ruanyifeng.com/?search=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F&amp;x=0&amp;y=0#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)</span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入配置文件，也就是config/index.js文件</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 引入vue-loader的配置文件</span><br><span class="line">const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)</span><br><span class="line">// 定义获取绝对路径函数</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, &apos;..&apos;, dir)</span><br><span class="line">&#125;</span><br><span class="line">// 创建eslint配置</span><br><span class="line">const createLintingRule = () =&gt; (&#123;</span><br><span class="line">  test: /\.(js|vue)$/,</span><br><span class="line">  loader: &apos;eslint-loader&apos;,</span><br><span class="line">  // 执行顺序，前置，还有一个选项是post是后置</span><br><span class="line">  // 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查</span><br><span class="line">  enforce: &apos;pre&apos;,</span><br><span class="line">  // 包含文件夹</span><br><span class="line">  include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    // 使用友好的eslint提示插件</span><br><span class="line">    formatter: require(&apos;eslint-friendly-formatter&apos;),</span><br><span class="line">    // eslint报错提示是否显示以遮罩形式显示在浏览器中</span><br><span class="line">    // 这里showEslintErrorsInOverlay配置是false</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 运行环境的上下文，就是实际的目录，也就是项目根目录</span><br><span class="line">  context: path.resolve(__dirname, &apos;../&apos;),</span><br><span class="line">  // 入口</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 输出</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 路径 这里是根目录下的dist</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    // 文件名</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    publicPath: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">      // 这里是 /，但要上传到github pages等会路径不对，需要修改为./</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      // 这里配置是 /</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  // Webpack 在启动后会从配置的入口模块出发找出所有依赖的模块，Resolve 配置 Webpack 如何寻找模块所对应的文件。</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 配置了这个，对应的扩展名可以省略</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      // 给定对象的键后的末尾添加 $，以表示精准匹配 node_modules/vue/dist/vue.esm.js</span><br><span class="line">      // 引用 import Vue from &apos;vue&apos;就是引入的这个文件最后export default Vue 导出的Vue;</span><br><span class="line">      // 所以这句可以以任意大写字母命名 比如：import V from &apos;vue&apos;</span><br><span class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">      // src别名 比如 ：引入import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 定义一些文件的转换规则</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // 是否使用eslint 这里配置是true</span><br><span class="line">      ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        // vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/</span><br><span class="line">        loader: &apos;vue-loader&apos;,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // js文件使用babel-loader转换</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 图片文件使用url-loader转换</span><br><span class="line">        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 限制大小10000B(bytes)以内，转成base64编码的dataURL字符串</span><br><span class="line">          limit: 10000,</span><br><span class="line">          // 输出路径 img/名称.7位hash.扩展名</span><br><span class="line">          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 视频文件使用url-loader转换</span><br><span class="line">        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // 这里的node是一个对象，其中每个属性都是 Node.js 全局变量或模块的名称，每个 value 是以下其中之一</span><br><span class="line">  // empty 提供空对象。</span><br><span class="line">  // false 什么都不提供。</span><br><span class="line">  // 更多查看 中文文档：https://webpack.docschina.org/configuration/node/</span><br><span class="line">  node: &#123;</span><br><span class="line">    // prevent webpack from injecting useless setImmediate polyfill because Vue</span><br><span class="line">    // source contains it (although only uses it if it&apos;s native).</span><br><span class="line">    // 防止webpack注入一些polyfill 因为Vue已经包含了这些。</span><br><span class="line">    setImmediate: false,</span><br><span class="line">    // prevent webpack from injecting mocks to Node native modules</span><br><span class="line">    // that does not make sense for the client</span><br><span class="line">    dgram: &apos;empty&apos;,</span><br><span class="line">    fs: &apos;empty&apos;,</span><br><span class="line">    net: &apos;empty&apos;,</span><br><span class="line">    tls: &apos;empty&apos;,</span><br><span class="line">    child_process: &apos;empty&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-vue-loader-conf-js-vue-loader配置文件"><a href="#build-vue-loader-conf-js-vue-loader配置文件" class="headerlink" title="build/vue-loader.conf.js vue-loader配置文件"></a><code>build/vue-loader.conf.js</code> <code>vue-loader</code>配置文件</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/vue-loader.conf.js</code>。</p><p>这个文件主要导出了一份<code>Vue-loader</code>的配置，<br>主要有：<code>loaders</code>，<code>cssSourceMap</code>，<code>cacheBusting</code>，<code>transformToRequire</code>。</p><p>具体看该文件注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">const isProduction = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">const sourceMapEnabled = isProduction</span><br><span class="line">  // 这里是true</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  // 这里是true</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line">// 更多配置 可以查看vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // cssLoaders 生成相应loader配置，具体看utils文件中的cssLoader</span><br><span class="line">  loaders: utils.cssLoaders(&#123;</span><br><span class="line">    // 是否开启sourceMap，便于调试</span><br><span class="line">    sourceMap: sourceMapEnabled,</span><br><span class="line">    // 是否提取vue单文件的css</span><br><span class="line">    extract: isProduction</span><br><span class="line">  &#125;),</span><br><span class="line">  // 是否开启cssSourceMap，便于调试</span><br><span class="line">  cssSourceMap: sourceMapEnabled,</span><br><span class="line">  // 这里是true</span><br><span class="line">  // 缓存破坏，进行sourceMap debug时，设置成false很有帮助。</span><br><span class="line">  cacheBusting: config.dev.cacheBusting,</span><br><span class="line">  // vue单文件中，在模板中的图片等资源引用转成require的形式。以便目标资源可以由 webpack 处理。</span><br><span class="line">  transformToRequire: &#123;</span><br><span class="line">    video: [&apos;src&apos;, &apos;poster&apos;],</span><br><span class="line">    source: &apos;src&apos;,</span><br><span class="line">    img: &apos;src&apos;,</span><br><span class="line">    // 默认配置会转换 &lt;img&gt; 标签上的 src 属性和 SVG 的 &lt;image&gt; 标签上的 xlink：href 属性。</span><br><span class="line">    image: &apos;xlink:href&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完了这些文件相应配置，开发环境的相关配置就串起来了。其中<code>config/</code>文件夹下的配置，笔者都已经注释在<code>build/</code>文件夹下的对应的文件中，所以就不单独说明了。</p><p>那回过头来看，<code>package.json</code>的<code>scripts</code>中的<code>npm run build</code>配置，<code>node build/build.js</code>，其实就是用<code>node</code>去执行<code>build/build.js</code>文件。</p><h3 id="build-build-js-npm-run-build-指定执行的文件"><a href="#build-build-js-npm-run-build-指定执行的文件" class="headerlink" title="build/build.js npm run build 指定执行的文件"></a><code>build/build.js</code> <code>npm run build</code> 指定执行的文件</h3><p>这个文件主要做了以下几件事情：<br>1、引入<code>build/check-versions</code>文件，检查<code>node</code>和<code>npm</code>的版本，<br>2、引入相关插件和配置，其中引入了<code>webpack</code>生产环境的配置<code>build/webpack.prod.conf.js</code>，<br>3、先控制台输出<code>loading</code>，删除<code>dist</code>目录下的文件，开始构建，构建失败和构建成功都给出相应的提示信息。</p><p>具体可以查看相应的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 检查node npm的版本</span><br><span class="line">require(&apos;./check-versions&apos;)()</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV = &apos;production&apos;</span><br><span class="line">// 命令行中的loading</span><br><span class="line">const ora = require(&apos;ora&apos;)</span><br><span class="line">// 删除文件或文件夹</span><br><span class="line">const rm = require(&apos;rimraf&apos;)</span><br><span class="line">// 路径相关</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalk</span><br><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 引入 生产环境webpack配置</span><br><span class="line">const webpackConfig = require(&apos;./webpack.prod.conf&apos;)</span><br><span class="line"></span><br><span class="line">// 控制台输入开始构建loading</span><br><span class="line">const spinner = ora(&apos;building for production...&apos;)</span><br><span class="line">spinner.start()</span><br><span class="line"></span><br><span class="line">// 删除原有构建输出的目录文件 这里是dist 和 static</span><br><span class="line">rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123;</span><br><span class="line">  // 如果出错，抛出错误</span><br><span class="line">  if (err) throw err</span><br><span class="line">  webpack(webpackConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    // 关闭 控制台输入开始构建loading</span><br><span class="line">    spinner.stop()</span><br><span class="line">    // 如果出错，抛出错误</span><br><span class="line">    if (err) throw err</span><br><span class="line">    process.stdout.write(stats.toString(&#123;</span><br><span class="line">      colors: true,</span><br><span class="line">      modules: false,</span><br><span class="line">      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span><br><span class="line">      chunks: false,</span><br><span class="line">      chunkModules: false</span><br><span class="line">    &#125;) + &apos;\n\n&apos;)</span><br><span class="line"></span><br><span class="line">    // 如果有错，控制台输出构建失败</span><br><span class="line">    if (stats.hasErrors()) &#123;</span><br><span class="line">      console.log(chalk.red(&apos;  Build failed with errors.\n&apos;))</span><br><span class="line">      process.exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 控制台输出构建成功相关信息</span><br><span class="line">    console.log(chalk.cyan(&apos;  Build complete.\n&apos;))</span><br><span class="line">    console.log(chalk.yellow(</span><br><span class="line">      &apos;  Tip: built files are meant to be served over an HTTP server.\n&apos; +</span><br><span class="line">      &apos;  Opening index.html over file:// won\&apos;t work.\n&apos;</span><br><span class="line">    ))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="build-check-versions-检查node和npm版本"><a href="#build-check-versions-检查node和npm版本" class="headerlink" title="build/check-versions 检查node和npm版本"></a><code>build/check-versions</code> 检查<code>node</code>和<code>npm</code>版本</h3><p>上文提到<code>build/check-versions</code> 检查<code>node</code>和<code>npm</code>版本，这个文件主要引入了一些插件和配置，最后导出一个函数，版本不符合预期就输出警告。</p><p>具体查看这个配置文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalk</span><br><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">// 语义化控制版本的插件 更多查看：https://github.com/npm/node-semver</span><br><span class="line">const semver = require(&apos;semver&apos;)</span><br><span class="line">// package.json配置</span><br><span class="line">const packageConfig = require(&apos;../package.json&apos;)</span><br><span class="line">// shell 脚本 Unix shell commands for Node.js 更多查看：https://github.com/shelljs/shelljs</span><br><span class="line">const shell = require(&apos;shelljs&apos;)</span><br><span class="line"></span><br><span class="line">function exec (cmd) &#123;</span><br><span class="line">  return require(&apos;child_process&apos;).execSync(cmd).toString().trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const versionRequirements = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;node&apos;,</span><br><span class="line">    currentVersion: semver.clean(process.version),</span><br><span class="line">    // 这里配置是&quot;node&quot;: &quot;&gt;= 6.0.0&quot;,</span><br><span class="line">    versionRequirement: packageConfig.engines.node</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">// 需要使用npm</span><br><span class="line">if (shell.which(&apos;npm&apos;)) &#123;</span><br><span class="line">  versionRequirements.push(&#123;</span><br><span class="line">    name: &apos;npm&apos;,</span><br><span class="line">    currentVersion: exec(&apos;npm --version&apos;),</span><br><span class="line">    // 这里配置是&quot;npm&quot;: &quot;&gt;= 3.0.0&quot;</span><br><span class="line">    versionRequirement: packageConfig.engines.npm</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 导出一个检查版本的函数</span><br><span class="line">module.exports = function () &#123;</span><br><span class="line">  const warnings = []</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; versionRequirements.length; i++) &#123;</span><br><span class="line">    const mod = versionRequirements[i]</span><br><span class="line"></span><br><span class="line">    // 当前版本不大于所需版本</span><br><span class="line">    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</span><br><span class="line">      warnings.push(mod.name + &apos;: &apos; +</span><br><span class="line">        chalk.red(mod.currentVersion) + &apos; should be &apos; +</span><br><span class="line">        chalk.green(mod.versionRequirement)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果有警告，全部输出到控制台</span><br><span class="line">  if (warnings.length) &#123;</span><br><span class="line">    console.log(&apos;&apos;)</span><br><span class="line">    console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;))</span><br><span class="line">    console.log()</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; warnings.length; i++) &#123;</span><br><span class="line">      const warning = warnings[i]</span><br><span class="line">      console.log(&apos;  &apos; + warning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log()</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-webpack-prod-conf-js-webpack生产环境配置"><a href="#build-webpack-prod-conf-js-webpack生产环境配置" class="headerlink" title="build/webpack.prod.conf.js webpack生产环境配置"></a><code>build/webpack.prod.conf.js</code> <code>webpack</code>生产环境配置</h3><p>上文<code>build/build.js</code>提到，引入了这个配置文件。<br>这个文件主要做了以下几件事情：<br>1、引入一些插件和配置，其中引入了<code>build/webpack.base.conf.js</code> <code>webpack</code>基本配置文件，<br>2、用<code>DefinePlugin</code>定义环境，<br>3、合并基本配置，定义自己的配置<code>webpackConfig</code>，配置了一些<code>modules</code>下的<code>rules</code>，<code>devtools</code>配置，<code>output</code>输出配置，一些处理<code>js</code>、提取<code>css</code>、压缩<code>css</code>、输出<code>html</code>插件、提取公共代码等的<br><code>plugins</code>，<br>4、如果启用<code>gzip</code>，再使用相应的插件处理，<br>5、如果启用了分析打包后的插件，则用<code>webpack-bundle-analyzer</code>，<br>6、最后导出这份配置。</p><p>具体可以查看这个文件配置注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 引入node路径相关</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入utils工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js配置文件</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 合并webpack配置的插件</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">// 基本的webpack配置</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)</span><br><span class="line">// 拷贝文件和文件夹的插件</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理HTML的插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理css的插件</span><br><span class="line">const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理js的插件</span><br><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">// 用DefinePlugin定义环境</span><br><span class="line">const env = process.env.NODE_ENV === &apos;testing&apos;</span><br><span class="line">  // 这里是 &#123; NODE_ENV: &apos;&quot;testing&quot;&apos; &#125;</span><br><span class="line">  ? require(&apos;../config/test.env&apos;)</span><br><span class="line">  // 这里是 &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125;</span><br><span class="line">  : require(&apos;../config/prod.env&apos;)</span><br><span class="line">// 合并基本webpack配置</span><br><span class="line">const webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    // 通过styleLoaders函数生成样式的一些规则</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      // sourceMap这里是true</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      // 是否提取css到单独的css文件</span><br><span class="line">      extract: true,</span><br><span class="line">      // 是否使用postcss</span><br><span class="line">      usePostCSS: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 配置使用sourceMap true 这里是 #source-map</span><br><span class="line">  devtool: config.build.productionSourceMap ? config.build.devtool : false,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 这里是根目录下的dist</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    // 文件名称 chunkhash</span><br><span class="line">    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;),</span><br><span class="line">    // chunks名称 chunkhash</span><br><span class="line">    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // http://vuejs.github.io/vue-loader/en/workflow/production.html</span><br><span class="line">    // 定义具体是什么环境</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env&apos;: env</span><br><span class="line">    &#125;),</span><br><span class="line">    // 压缩js插件</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          // 警告</span><br><span class="line">          warnings: false</span><br><span class="line">          // 构建后的文件 常用的配置还有这些</span><br><span class="line">          // 去除console.log 默认为false。  传入true会丢弃对console函数的调用。</span><br><span class="line">          // drop_console: true,</span><br><span class="line">          // 去除debugger</span><br><span class="line">          // drop_debugger: true,</span><br><span class="line">          // 默认为null. 你可以传入一个名称的数组，而UglifyJs将会假定那些函数不会产生副作用。</span><br><span class="line">          // pure_funcs: [ &apos;console.log&apos;, &apos;console.log.apply&apos; ],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 是否开启sourceMap 这里是true</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      // 平行处理（同时处理）加快速度</span><br><span class="line">      parallel: true</span><br><span class="line">    &#125;),</span><br><span class="line">    // extract css into its own file</span><br><span class="line">    // 提取css到单独的css文件</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      // 提取到相应的文件名 使用内容hash contenthash</span><br><span class="line">      filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;),</span><br><span class="line">      // Setting the following option to `false` will not extract CSS from codesplit chunks.</span><br><span class="line">      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.</span><br><span class="line">      // It&apos;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&apos;s `false`,</span><br><span class="line">      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110</span><br><span class="line">      // allChunks 默认是false,true指提取所有chunks包括动态引入的组件。</span><br><span class="line">      allChunks: true,</span><br><span class="line">    &#125;),</span><br><span class="line">    // Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">    // duplicated CSS from different components can be deduped.</span><br><span class="line">    new OptimizeCSSPlugin(&#123;</span><br><span class="line">      // 这里配置是true</span><br><span class="line">      cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">        ? &#123; safe: true, map: &#123; inline: false &#125; &#125;</span><br><span class="line">        : &#123; safe: true &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // generate dist index.html with correct asset hash for caching.</span><br><span class="line">    // you can customize output by editing /index.html</span><br><span class="line">    // see https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      // 输出html名称</span><br><span class="line">      filename: process.env.NODE_ENV === &apos;testing&apos;</span><br><span class="line">        ? &apos;index.html&apos;</span><br><span class="line">        // 这里是 根目录下的dist/index.html</span><br><span class="line">        : config.build.index,</span><br><span class="line">      // 使用哪个模板</span><br><span class="line">      template: &apos;index.html&apos;,</span><br><span class="line">      // inject 默认值 true，script标签位于html文件的 body 底部</span><br><span class="line">      // body 通true, header, script 标签位于 head 标签内</span><br><span class="line">      // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件</span><br><span class="line">      inject: true,</span><br><span class="line">      // 压缩</span><br><span class="line">      minify: &#123;</span><br><span class="line">        // 删除注释</span><br><span class="line">        removeComments: true,</span><br><span class="line">        // 删除空格和换行</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        // 删除html标签中属性的双引号</span><br><span class="line">        removeAttributeQuotes: true</span><br><span class="line">        // 更多配置查看html-minifier插件</span><br><span class="line">        // more options:</span><br><span class="line">        // https://github.com/kangax/html-minifier#options-quick-reference</span><br><span class="line">      &#125;,</span><br><span class="line">      // necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br><span class="line">      // 在chunk被插入到html之前，你可以控制它们的排序。允许的值 ‘none’ | ‘auto’ | ‘dependency’ | &#123;function&#125; 默认为‘auto’.</span><br><span class="line">      // dependency 依赖（从属）</span><br><span class="line">      chunksSortMode: &apos;dependency&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    // keep module.id stable when vendor modules does not change</span><br><span class="line">    // 根据代码内容生成普通模块的id，确保源码不变，moduleID不变。</span><br><span class="line">    new webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    // enable scope hoisting</span><br><span class="line">    // 开启作用域提升 webpack3新的特性，作用是让代码文件更小、运行的更快</span><br><span class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    // split vendor js into its own file</span><br><span class="line">    // 提取公共代码</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &apos;vendor&apos;,</span><br><span class="line">      minChunks (module) &#123;</span><br><span class="line">        // any required modules inside node_modules are extracted to vendor</span><br><span class="line">        return (</span><br><span class="line">          module.resource &amp;&amp;</span><br><span class="line">          /\.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">          module.resource.indexOf(</span><br><span class="line">            path.join(__dirname, &apos;../node_modules&apos;)</span><br><span class="line">          ) === 0</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // extract webpack runtime and module manifest to its own file in order to</span><br><span class="line">    // prevent vendor hash from being updated whenever app bundle is updated</span><br><span class="line">    // 提取公共代码</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      // 把公共的部分放到 manifest 中</span><br><span class="line">      name: &apos;manifest&apos;,</span><br><span class="line">      // 传入 `Infinity` 会马上生成 公共chunk，但里面没有模块。</span><br><span class="line">      minChunks: Infinity</span><br><span class="line">    &#125;),</span><br><span class="line">    // This instance extracts shared chunks from code splitted chunks and bundles them</span><br><span class="line">    // in a separate chunk, similar to the vendor chunk</span><br><span class="line">    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span><br><span class="line">    // 提取动态组件</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &apos;app&apos;,</span><br><span class="line">      // 如果设置为 `true`，一个异步的  公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。</span><br><span class="line">      // 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。</span><br><span class="line">      async: &apos;vendor-async&apos;,</span><br><span class="line">      // 如果设置为 `true`，所有  公共chunk 的子模块都会被选择</span><br><span class="line">      children: true,</span><br><span class="line">      // 最小3个，包含3，chunk的时候提取</span><br><span class="line">      minChunks: 3</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    // copy custom static assets</span><br><span class="line">    // 把static资源复制到相应目录。</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        from: path.resolve(__dirname, &apos;../static&apos;),</span><br><span class="line">        // 这里配置是static</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git</span><br><span class="line">        ignore: [&apos;.*&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">// 如果开始gzip压缩，使用compression-webpack-plugin插件处理。这里配置是false</span><br><span class="line">// 需要使用是需要安装 npm i compression-webpack-plugin -D</span><br><span class="line">if (config.build.productionGzip) &#123;</span><br><span class="line">  const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(&#123;</span><br><span class="line">      // asset： 目标资源名称。 [file] 会被替换成原始资源。</span><br><span class="line">      // [path] 会被替换成原始资源的路径， [query] 会被替换成查询字符串。默认值是 &quot;[path].gz[query]&quot;。</span><br><span class="line">      asset: &apos;[path].gz[query]&apos;,</span><br><span class="line">      // algorithm： 可以是 function(buf, callback) 或者字符串。对于字符串来说依照 zlib 的算法(或者 zopfli 的算法)。默认值是 &quot;gzip&quot;。</span><br><span class="line">      algorithm: &apos;gzip&apos;,</span><br><span class="line">      // test： 所有匹配该正则的资源都会被处理。默认值是全部资源。</span><br><span class="line">      // config.build.productionGzipExtensions 这里是[&apos;js&apos;, &apos;css&apos;]</span><br><span class="line">      test: new RegExp(</span><br><span class="line">        &apos;\\.(&apos; +</span><br><span class="line">        config.build.productionGzipExtensions.join(&apos;|&apos;) +</span><br><span class="line">        &apos;)$&apos;</span><br><span class="line">      ),</span><br><span class="line">      // threshold： 只有大小大于该值的资源会被处理。单位是 bytes。默认值是 0。</span><br><span class="line">      threshold: 10240,</span><br><span class="line">      // minRatio： 只有压缩率小于这个值的资源才会被处理。默认值是 0.8。</span><br><span class="line">      minRatio: 0.8</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出分析的插件 运行npm run build --report</span><br><span class="line">// config.build.bundleAnalyzerReport这里是 process.env.npm_config_report</span><br><span class="line">// build结束后会自定打开 http://127.0.0.1:8888 链接</span><br><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  // 更多查看链接地址：https://www.npmjs.com/package/webpack-bundle-analyzer</span><br><span class="line">  const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line">// 当然也可以用官方提供的网站 http://webpack.github.io/analyse/#home</span><br><span class="line">// 运行类似 webpack --profile --json &gt; stats.json 命令</span><br><span class="line">// 把生成的构建信息stats.json上传即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 最终导出 webpackConfig</span><br><span class="line">module.exports = webpackConfig</span><br></pre></td></tr></table></figure><p>至此，我们就分析完了<code>package.json</code>中的<code>npm run dev</code>和<code>npm run build</code>两个命令。测试相关的类似就略过吧。</p><p><code>npm run lint</code>，<code>.eslintrc.js</code>中的配置不多，更多可以查看<a href="https://eslint.org/" target="_blank" rel="noopener">eslint英文文档</a>或<a href="http://eslint.cn/" target="_blank" rel="noopener"><code>eslint</code>中文官网</a>，所以也略过吧。不过提一下，把<code>eslint</code>整合到<code>git</code>工作流。可以安装<code>husky</code>，<code>npm i husky -S</code>。安装后，配置<code>package.json</code>的<code>scripts</code>中，配置<code>precommit</code>，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;,</span><br><span class="line">  &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>配置好后，每次<code>git commit -m</code>提交会检查代码是否通过<code>eslint</code>校验，如果没有校验通过则提交失败。还可以配置<code>prepush</code>。<code>husky</code>不断在更新，现在可能与原先的配置不太相同了，具体查看<a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky github仓库</a>。原理就是<code>git-hooks</code>,<code>pre-commit</code>的钩子。对<code>shell</code>脚本熟悉的同学也可以自己写一份<code>pre-commit</code>。复制到项目的<code>.git/hooks/pre-commit</code>中。不需要依赖<code>husky</code>包。我司就是用的<code>shell</code>脚本。</p><p>最后提一下<code>.babelrc</code>文件中的配置。</p><h3 id="babelrc-babel相关配置"><a href="#babelrc-babel相关配置" class="headerlink" title=".babelrc babel相关配置"></a><code>.babelrc</code> <code>babel</code>相关配置</h3><p>配置了一些转码规则。这里附上两个链接：<a href="https://babeljs.io/" target="_blank" rel="noopener"><code>babel</code>英文官网</a>和<a href="https://babel.bootcss.com/" target="_blank" rel="noopener"><code>babel</code>的中文官网</a>。</p><p>具体看文件中的配置注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // presets指明转码的规则</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    // env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;modules&quot;: false,</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line">  // plugins 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。</span><br><span class="line">  // transform-vue-jsx 表明可以在项目中使用jsx语法，会使用这个插件转换</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;],</span><br><span class="line">  // 在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;],</span><br><span class="line">      &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-es2015-modules-commonjs&quot;, &quot;dynamic-import-node&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件中<code>presets</code>中有配置<code>env</code>和<code>stage-2</code>，可能不知道是什么。这里引用<a href="http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-1%E4%BD%BF%E7%94%A8ES6%E8%AF%AD%E8%A8%80.html" target="_blank" rel="noopener">深入浅出webpack</a>书中，第三章，<code>3-1</code>使用<code>ES6</code>语言 小节的一段，解释一下。</p><blockquote><p><code>presets</code> 属性告诉 <code>Babel</code> 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 <code>Presets</code> 可以叠加。 <code>Presets</code> 其实是一组 <code>Plugins</code> 的集合，每一个 <code>Plugin</code> 完成一个新语法的转换工作。<code>Presets</code> 是按照 <code>ECMAScript</code> 草案来组织的，通常可以分为以下三大类（书中就是说三大类，我发现就两点~~~）：<br>1、已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为：<br>es2015 包含在2015里加入的新特性；<br>es2016 包含在2016里加入的新特性；<br>es2017 包含在2017里加入的新特性；<br>es2017 包含在2017里加入的新特性；<br>env 包含当前所有 ECMAScript 标准里的最新特性。<br>2、被社区提出来的但还未被写入 <code>ECMAScript</code> 标准里特性，这其中又分为以下四种：<br><code>stage0</code> 只是一个美好激进的想法，有 <code>Babel</code> 插件实现了对这些特性的支持，但是不确定是否会被定为标准；<br><code>stage1</code> 值得被纳入标准的特性；<br><code>stage2</code> 该特性规范已经被起草，将会被纳入标准里；<br><code>stage3</code> 该特性规范已经定稿，各大浏览器厂商和 <code></code> 社区开始着手实现；<br><code>stage4</code> 在接下来的一年将会加入到标准里去。</p></blockquote><p>至此，就算相对完整的分析完了<code>Vue-cli</code>(版本<code>v2.9.3</code>)搭建的<code>webpack</code>项目工程。希望对大家有所帮助。<br><strong>项目放在笔者的<code>github</code>上，<a href="https://github.com/lxchuan12/analyse-vue-cli" target="_blank" rel="noopener">分析vue-cli@2.9.3 搭建的webpack项目工程</a>。方便大家克隆下载，或者在线查看。同时也求个<code>star</code> <code>^_^</code>，也是对笔者的一种鼓励和支持。</strong><br>笔者知识能力有限，文章有什么不妥之处，欢迎指出~</p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<strong>轩辕Rowboat</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、分析这些，逐行注释，还是需要一些时间的。其中有些不是很明白的地方，及时查阅相应的官方文档和插件文档（建议看英文文档和最新的文档），不过文档没写明白的地方，可以多搜索一些别人的博客文章，相对比较清晰明了。<br>2、前端发展太快，这个<a href="mailto:`Vue-cli@2.9.3" target="_blank" rel="noopener">`Vue-cli@2.9.3</a><code></code>webpack<code>版本还是</code>v3.x<code>，webpack现在官方版本已经是</code>v4.12.0<code>，相信不久后，</code>Vue-cli<code>也将发布支持</code>webpack v4.x<code>的版本，</code>v3.0.0<code>已经是</code>beta.16<code>了。3、后续有余力，可能会继续分析新版的</code>vue-cli<code>构建的</code>webpack`项目工程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;已经有很多分析&lt;code&gt;Vue-cli&lt;/code&gt;搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，
      
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://lxchuan12.github.io/tags/vue/"/>
    
      <category term="vue-cli" scheme="https://lxchuan12.github.io/tags/vue-cli/"/>
    
      <category term="webpack" scheme="https://lxchuan12.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>win10 安装 oh my zsh 和 window git bash 设置别名提高效率</title>
    <link href="https://lxchuan12.github.io/2018/06/03/20180603-oh%20my%20zsh%20-%20window%20git%20bash%20alias/"/>
    <id>https://lxchuan12.github.io/2018/06/03/20180603-oh my zsh - window git bash alias/</id>
    <published>2018-06-03T15:19:55.030Z</published>
    <updated>2018-07-28T06:52:59.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 <code>oh my zsh</code></h3><p>公司使用<code>Ubuntu</code>系统。自己安装了 <code>oh my zsh</code><a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh my zsh官网</a>。这里简述下安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">// /bin/bash 默认是bash</span><br><span class="line">// 查看下有哪些shells</span><br><span class="line">cat /etc/shells</span><br><span class="line">// # /etc/shells: valid login shells</span><br><span class="line">// /bin/sh</span><br><span class="line">// /bin/bash</span><br><span class="line">// /bin/rbash</span><br><span class="line">// /bin/dash</span><br><span class="line">// /usr/bin/tmux</span><br><span class="line">// /usr/bin/screen</span><br><span class="line">// /bin/zsh</span><br><span class="line">// /usr/bin/zsh</span><br><span class="line">sudo apt-get install zsh</span><br><span class="line">zsh --version</span><br><span class="line">// 5.1.1</span><br><span class="line">// 安装后zsh 后cat /etc/shells 才有/bin/zsh /usr/bin/zsh</span><br><span class="line"></span><br><span class="line">// 切换成zsh</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 两种安装方案可供选择：</span><br><span class="line">// Via curl</span><br><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">// Via Wget</span><br><span class="line">$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><p>安装成功后，配置信息会在<code>~/.zshrc</code>。可以通过<code>vim ~/.zshrc</code>打开编辑<code>zsh</code>配置信息，可以看到默认配置了<code>git</code> 插件<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">Plugin:git</a>。<br>也就是说，可以更加简便的使用<code>git</code> 相关的一些别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比如</span><br><span class="line">`git status`时，只需要输入`gst`。</span><br><span class="line">`git pull` 时，只需要输入`gl`。</span><br><span class="line">`git push 时，只需要输入`gp`等等。</span><br></pre></td></tr></table></figure></p><p>是因为配置里有这些简写，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">oh my zsh plugin git.plugin.zsh</a>。<br>安装成功后，同时会创建<code>~/.oh-my-zsh</code>的文件夹，其实就是<code>.oh-my-zsh</code> 的 <code>git</code> 仓库<code>master</code>分支。<br>可以发现文件夹中有一个<code>plugins</code>文件夹，内置了很多插件。可以自定义主题<code>theme</code>，具体可以看<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/themes/example.zsh-theme" target="_blank" rel="noopener">example.zsh-theme</a>。<br><code>custom</code>自定义相关。<br>插件相关会安装在这里，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/custom/plugins/example/example.plugin.zsh" target="_blank" rel="noopener">更多可以查看example.plugin.zsh</a></p><p>我暂时安装了这几个插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  // 内置插件，启用即可</span><br><span class="line">  git</span><br><span class="line">  cp</span><br><span class="line">  mv</span><br><span class="line">  // 按两下esc键，用sudo权限</span><br><span class="line">  sudo</span><br><span class="line">  // 记录历史输入的zsh命令，自动提示，快速使用</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  // zsh 命令高亮</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>顺带讲下后面两个插件的安装方法<br>安装 <code>zsh-autosuggestions</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></p><p>安装<code>zsh-syntax-highlighting</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p><p><code>$ZSH_CUSTOM</code> 其实是个变量，代表这个路径<code>~/.oh-my-zsh/custom</code>，<br>也就是安装到了这个目录下。还有很多高效插件，等您发掘~<a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh my zsh官网</a><br>不过插件安装多了，感觉会有些卡顿~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 每次修改了这个`.zshrc`配置文件，需要重载一下，才能生效。</span><br><span class="line">source .zshrc</span><br><span class="line">// 也可以封装成一个简写命令 alias</span><br><span class="line">alias rl=&apos;source ~/.zshrc&apos;</span><br></pre></td></tr></table></figure></p><p>也可以在这个配置文件中配置更多<code>alias</code>。<br><code>oh my zsh</code>命令工具确实好用，但还没买<code>mac</code>，又不想用<code>ubuntu</code>的童鞋怎么办呢~<br><code>win10</code> 支持安装<code>ubuntu</code>等子系统，就可以安装<code>oh my zsh</code>, 学习<code>linux</code>了。</p><h3 id="windows-10-安装-Ubuntu-子系统，安装oh-my-zsh"><a href="#windows-10-安装-Ubuntu-子系统，安装oh-my-zsh" class="headerlink" title="windows 10 安装 Ubuntu 子系统，安装oh my zsh"></a><code>windows 10</code> 安装 <code>Ubuntu</code> 子系统，安装<code>oh my zsh</code></h3><p>之前偶然发现自己电脑<code>windows 10</code> 有类似<code>linux</code> 功能（虽然这功能之前就有印象，但没去研究），这里有篇简短介绍文章：<a href="https://www.iplaysoft.com/ubuntu-for-windows10.html" target="_blank" rel="noopener">微软官方 Ubuntu for Win10 版免费 Linux 子系统下载！一键安装运行超简单</a></p><p>竟然也可以安装<code>oh my zsh</code><a href="http://ohmyz.sh/" target="_blank" rel="noopener">官网</a>。想学习 <code>linux</code> 又不想安装 <code>linux</code> 系统，这时候可以用<code>win10</code>自带的<code>Ubuntu</code>。<br>发现这篇写的比较详细，笔者就不再赘述了。<br>笔者安装<code>ubuntu 18.04</code>子系统后，文件目录在这个路径下。<code>C:\Users\lxchuan12\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs</code><br><a href="https://blog.csdn.net/sko121/article/details/78091083" target="_blank" rel="noopener">Win10 环境下安装配置 zsh</a></p><p><code>win10</code>安装了<code>ubuntu</code>子系统和<code>oh my zsh</code>后，则可以通过<code>/mnt/f/</code>访问<code>win10</code>下的<code>f</code>盘，或者其他盘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比如跳转到工作目录</span><br><span class="line">alias dgg=&apos;cd /mnt/f/git-source/github&apos;</span><br><span class="line">// vscode 打开要编辑的文件或文件夹</span><br><span class="line">code sticky-notes</span><br></pre></td></tr></table></figure></p><p>也就是相当于<code>win10</code>下解锁了<code>oh my zsh</code>。<br>那不是<code>win10</code>，也想通过设置别名来提高效率，是不是就没有办法了呢，可以使用<code>git bash</code>设置<code>alias</code>，安装<code>git</code>，自带<code>git bash</code>。</p><h3 id="windows-git-bash-设置别名提高效率"><a href="#windows-git-bash-设置别名提高效率" class="headerlink" title="windows git bash 设置别名提高效率"></a><code>windows</code> <code>git bash</code> 设置别名提高效率</h3><p><code>windows</code> 桌面或任意资源管理器位置，右击，选择<code>Git Bash Here</code>，即打开了<code>git bash</code>命令行。<br>先设置下主题，右击选择<code>options</code>, <code>Looks &gt; theme &gt; dracula</code><br>我选择的是<code>dracula</code>主题，看起来比较舒适。还可以设置字体等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 跳转到根路径</span><br><span class="line">cd ~</span><br><span class="line">// 查看下是否有.bash_profile文件</span><br><span class="line">la</span><br><span class="line">// 如果没有.bash_profile文件，需要创建</span><br><span class="line">touch .bash_profile</span><br><span class="line">// 打开编辑 （笔者这里安装了vscode，所以直接用其打开文件）</span><br><span class="line">code .bash_profile</span><br></pre></td></tr></table></figure></p><p>可以根据修改设置一些别名。<br>比如我们常用的<code>git status</code>命令，可以封装成<code>gst</code>。清屏<code>clear</code>命令封装成<code>cls</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias gst=&apos;git status&apos;</span><br><span class="line">alias cls=&apos;clear&apos;</span><br></pre></td></tr></table></figure></p><p>每次修改这个文件需要输入<code>source ~/.bash_profile</code>重载这个文件，才会生效。<br><code>code ~/.bash_profile</code>，用<code>vscode</code>编辑这个配置文件，封装成一个命令。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias rl=&apos;source ~/.bash_profile&apos;</span><br><span class="line">alias bashconfig=&apos;code ~/.bash_profile&apos;</span><br></pre></td></tr></table></figure></p><p>这样每次修改保存后就只需要输入<code>rl</code>，即可重载生效了。<br>还可以把一些工作目录封装，笔者的一些项目是放在<code>/f/git-source/github</code>文件下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// github上的项目</span><br><span class="line">alias dgg=&apos;cd F:/git-source/github&apos;</span><br><span class="line">// 周报相关</span><br><span class="line">alias dcwk=&apos;cd F:/git-source/coding/weekly&apos;</span><br></pre></td></tr></table></figure></p><p>每次进入项目，就直接<code>dgg</code>，即可跳转到这个目录，然后选择相应的目录即可。<br>比如<code>dgg</code>进入工作目录，<code>cd analyse-vue-cli</code>进入项目目录,（输入<code>anal</code>按<code>tab</code>键智能提示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  /f/git-source/github/analyse-vue-cli (dev)</span><br><span class="line">// 查看状态 git status</span><br><span class="line">gst</span><br><span class="line">// 用vscode 打开这个文件夹，开始编辑~</span><br><span class="line">code ./</span><br></pre></td></tr></table></figure></p><p>git 相关的，<br>例举一些平时用的比较多的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias g=&apos;git&apos;</span><br><span class="line">alias ga=&apos;git add&apos;</span><br><span class="line">alias gaa=&apos;git add -all&apos;</span><br><span class="line">alias gp=&apos;git push&apos;</span><br><span class="line">alias gl=&apos;git pull&apos;</span><br><span class="line">alias gcmsg=&apos;git commit -m&apos;</span><br><span class="line">// 分支相关</span><br><span class="line">alias gb=&apos;git branch&apos;</span><br><span class="line">alias gbr=&apos;git branch -r&apos;</span><br><span class="line">alias gba=&apos;git branch -a&apos;</span><br><span class="line">// checkout</span><br><span class="line">alias gco=&apos;git checkout&apos;</span><br><span class="line">alias gcb=&apos;git checkout -b&apos;</span><br><span class="line">// merge</span><br><span class="line">alias gm=&apos;git merge&apos;</span><br><span class="line">// diff</span><br><span class="line">alias gd=&apos;git diff&apos;</span><br><span class="line">alias gdw=&apos;git diff --word-diff&apos;</span><br></pre></td></tr></table></figure></p><p>更多可以把<code>oh my zsh</code>的插件一些命令拷贝过来，留<code>alias</code>相关的即可，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">oh my zsh plugin git.plugin.zsh</a><br><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">Plugin:git wiki</a><br>相当于解锁了<code>oh my zsh</code> 的<code>git</code>插件。还有很多插件，比如<code>npm</code><a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/npm/npm.plugin.zsh" target="_blank" rel="noopener">点击查看</a>, <code>node 等</code>，都可以研究下。</p><p><code>git bash</code>，有没有类似<code>oh my zsh</code>的插件呢，笔者暂时没发现，如果您知道，欢迎告诉笔者。<br>目录相关的操作，也可以设置一些别名。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 回退到上一级</span><br><span class="line">alias ..=&apos;cd ..&apos;</span><br><span class="line">alias ...=&apos;cd ../..&apos;</span><br><span class="line">alias ....=&apos;cd ../../..&apos;</span><br><span class="line">alias .....=&apos;cd ../../../..&apos;</span><br><span class="line">alias ......=&apos;cd ../../../../..&apos;</span><br></pre></td></tr></table></figure></p><p>更多别名可以自定义～<br><code>windows</code>上命令行工具还可以使用<code>cmder</code><a href="http://cmder.net/" target="_blank" rel="noopener">点击查看cmder官网</a>命令行工具。虽然笔者几年前就安装了，但发现还是<code>git bash</code>用的顺畅些，可能是我还不太习惯<code>cmder</code>。<br>关于<code>cmder</code>配置相关，这里推荐晚晴幽草轩轩主的一篇文章：<br><a href="https://jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">《Win下必备神器之Cmder》</a></p><p>也有<a href="http://www.cygwin.com/" target="_blank" rel="noopener">cygwin</a>，也是<code>windows</code>命令行工具，也可以安装<code>on my zsh</code>。</p><p>当然，<code>git</code>也是可以设置别名的。</p><h3 id="git设置别名，使用tig神器"><a href="#git设置别名，使用tig神器" class="headerlink" title="git设置别名，使用tig神器"></a><code>git</code>设置别名，使用<code>tig</code>神器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// git status =&gt; git st</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><p>更多可以查看廖雪峰老师的这篇文章<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000" target="_blank" rel="noopener">git 配置别名</a>。不过可能大多数人不知道，他们可能用着可视化工具。笔者觉得可视化工具也是对<code>git</code>的一些封装，具体背后是什么命令，我们还是需要去了解熟悉的。命令行使用<code>git</code>，笔者推荐使用<code>tig</code>。<code>git log</code>增强版，性能很好。<code>Ubuntu</code>、<code>linux</code>、<code>mac</code>可以直接安装，<code>windows</code>稍微麻烦些。具体安装方法查看<a href="https://github.com/jonas/tig/blob/master/INSTALL.adoc" target="_blank" rel="noopener">tig github仓库中的官方安装文档</a>，或者查看这篇文章：<a href="https://www.jianshu.com/p/e4ca3030a9d5" target="_blank" rel="noopener">颠覆 Git 命令使用体验的神器 – tig</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<strong>轩辕Rowboat</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>磨刀不误砍柴工，花时间折腾研究工具，有利于提高开发效率。</p><p>最新更新于 <code>2018-07-28 14:46:08</code></p><p>文章首发于<code>segmentfault</code> <a href="https://segmentfault.com/a/1190000015155864" target="_blank" rel="noopener">win10 安装 oh my zsh 和 windows git bash 设置别名提高效率</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装-oh-my-zsh&quot;&gt;&lt;a href=&quot;#安装-oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;安装 oh my zsh&quot;&gt;&lt;/a&gt;安装 &lt;code&gt;oh my zsh&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;公司使用&lt;code&gt;Ubuntu&lt;
      
    
    </summary>
    
      <category term="tool" scheme="https://lxchuan12.github.io/categories/tool/"/>
    
    
      <category term="git" scheme="https://lxchuan12.github.io/tags/git/"/>
    
      <category term="tool" scheme="https://lxchuan12.github.io/tags/tool/"/>
    
      <category term="zsh" scheme="https://lxchuan12.github.io/tags/zsh/"/>
    
      <category term="oh my zsh" scheme="https://lxchuan12.github.io/tags/oh-my-zsh/"/>
    
      <category term="git bash" scheme="https://lxchuan12.github.io/tags/git-bash/"/>
    
      <category term="ubuntu" scheme="https://lxchuan12.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴</title>
    <link href="https://lxchuan12.github.io/2018/05/16/20180515-vue%20qrcode%20clipboard/"/>
    <id>https://lxchuan12.github.io/2018/05/16/20180515-vue qrcode clipboard/</id>
    <published>2018-05-15T16:15:21.000Z</published>
    <updated>2018-06-12T14:30:15.237Z</updated>
    
    <content type="html"><![CDATA[<p>近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。<br>老模块是用的<a href="http://code.ciaoca.com/javascript/qrcode/" target="_blank" rel="noopener">qrocode中文文档</a>，<a href="https://github.com/davidshimjs/qrcodejs" target="_blank" rel="noopener">qrcode github</a>。</p><p>先想着新模块中是否有生成二维码的插件，看了下<code>package.json</code>。<br>有安装一个<a href="https://github.com/theomessin/vue-qriously" target="_blank" rel="noopener">vue-qriously</a>…<a id="more"></a>但搜索了一下，竟然没有使用，可能是因为很多二维码都是后端生成返回链接给前端的。而在其他H5、微信项目中使用了。看了下这个项目<code>star</code>数是<code>113</code>。但我不想重新引入老模块的<code>qrcodejs</code>，重新引入其他的二维码插件，相对比较麻烦。于是就保持统一用<code>vue-qriously</code>了。<br>猜想当时引入这个是<a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">vue 资源合集<code>awesome-vue</code></a>中，<code>qrcode</code>相关第一个就是<code>vue-qriously</code>。</p><h3 id="vue-qriously插件使用"><a href="#vue-qriously插件使用" class="headerlink" title="vue-qriously插件使用"></a><code>vue-qriously</code>插件使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 入口js文件</span><br><span class="line">// npm install vue-qriously -S</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import VueQriously from &apos;vue-qriously&apos;;</span><br><span class="line">Vue.use(VueQriously);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// vue 文件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;qriously :value=&quot;value&quot; size=&quot;size&quot; :backgroundAlpha=&quot;backgroundAlpha&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;app&apos;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            // 可以自定义，必填项。</span><br><span class="line">            value: &apos;http://lxchuan12.github.io/&apos;,</span><br><span class="line">            // 二维码大小 默认 100</span><br><span class="line">            size: 80,</span><br><span class="line">            // 背景透明度，默认透明 0 </span><br><span class="line">            backgroundAlpha： 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更多参数配置可以查看：<a href="https://github.com/theomessin/vue-qriously/blob/master/src/components/v-qriously.vue" target="_blank" rel="noopener">github 仓库 v-qriously.vue源码</a><br>查看代码可以发现，开头引用了<code>qrious</code>，这个<code>star</code>就多一点，<code>600</code>多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Qrious from &apos;qrious&apos;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/neocotic/qrious" target="_blank" rel="noopener"><code>qrious</code> github 地址</a><br><a href="https://neocotic.com/qrious/" target="_blank" rel="noopener"><code>qrious</code> 文档</a></p><h3 id="下载二维码"><a href="#下载二维码" class="headerlink" title="下载二维码"></a>下载二维码</h3><p>粗略的翻看下以上相关文档，写完正准备要做下载功能。这时发现，哎呀，竟然就是只生成了一个<code>canvas</code>。<br>于是百度(暴露了用百度…我也想用谷歌，但现在不行…)了下<code>canvas</code>如何转图片。<br><a href="https://stackoverflow.com/questions/923885/capture-html-canvas-as-gif-jpg-png-pdf" target="_blank" rel="noopener">stackoverflow Capture HTML Canvas as gif/jpg/png/pdf?</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&quot;mycanvas&quot;);</span><br><span class="line">var imgSrc    = canvas.toDataURL(&quot;image/png&quot;);</span><br><span class="line">document.write(&apos;&lt;img src=&quot;&apos;+img+&apos;&quot;/&gt;&apos;);</span><br><span class="line">// 搜索到一些其他的方案，感觉挺麻烦。</span><br><span class="line">// 嗯，这个简单。想着我们项目兼容性没什么要求，于是就用这个了。</span><br></pre></td></tr></table></figure></p><p>生成了<code>img</code>的<code>src</code>资源，那么就可以下载了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 老模块是用的`jquery` + `seajs` + `vue1.x`</span><br><span class="line">// 新模块尽量要去除`jquery`。</span><br><span class="line">let src = $(&apos;.img&apos;).src;</span><br><span class="line">let aLink = $(&apos;&lt;a&gt;&lt;/a&gt;&apos;).attr(&apos;href&apos;, src).attr(&apos;download&apos;, &apos;xxx二维码.png&apos;).appendTo(&apos;body&apos;);</span><br><span class="line">aLink[0].click();</span><br><span class="line">aLink.remove();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 新模块 去除jquery</span><br><span class="line">let elem = document.createElement(&apos;a&apos;);</span><br><span class="line">elem.setAttribute(&apos;href&apos;, imgSrc);</span><br><span class="line">elem.setAttribute(&apos;download&apos;, &apos;xxx二维码.png&apos;);</span><br><span class="line">document.body.appendChild(elem);</span><br><span class="line">elem.click();</span><br><span class="line">document.body.removeChild(elem);</span><br></pre></td></tr></table></figure><p>但这样写也相对比较麻烦。<br>项目中封装了一个<code>v-click</code>指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vClick 触发点击</span><br><span class="line"> * @type &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const vClick = &#123;</span><br><span class="line">directives: &#123;</span><br><span class="line">click: &#123;</span><br><span class="line">/**</span><br><span class="line"> * 值更新时候触发点击</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> * @param  &#123;HTMLElement&#125; el                指令所绑定的元素</span><br><span class="line"> * @param  &#123;Boolean&#125;     options.value     绑定值(新)</span><br><span class="line"> * @param  &#123;Boolean&#125;     options.oldValue  绑定值(旧)</span><br><span class="line"> */</span><br><span class="line">update(el, &#123; value, oldValue &#125;)&#123;</span><br><span class="line">if(value &amp;&amp; !oldValue)&#123;</span><br><span class="line">el.click();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot; v-show=&quot;listShareShow&quot;&gt;</span><br><span class="line">        &lt;qriously id=&quot;qriously&quot; :backgroundAlpha=&quot;1&quot; :value=&quot;listSharingLink&quot; :size=&quot;160&quot; v-show=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;img :src=&quot;listSharingLinkSrc&quot; alt=&quot;xxx二维码&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;a :href=&quot;exportLink&quot; v-click=&quot;download&quot; :download=&quot;downloadFilename&quot;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a  @click.stop=&quot;listShare&quot;&gt;查看链接/二维码&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    // 提取出主要代码</span><br><span class="line">    data()&#123;</span><br><span class="line">        retrun &#123;</span><br><span class="line">            // 下载</span><br><span class="line">download: false,</span><br><span class="line">downloadFilename: &apos;xxx二维码&apos;,</span><br><span class="line">listSharingLinkSrc: &apos;&apos;,</span><br><span class="line">            listSharingLinkSrc: &apos;&apos;,</span><br><span class="line">            listShareShow: false,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        /**</span><br><span class="line"> * 查看链接/二维码</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> */</span><br><span class="line">listShare(event)&#123;</span><br><span class="line">if(!this.listSharingLinkSrc)&#123;</span><br><span class="line">let canvas = document.querySelector(&apos;#qriously canvas&apos;);</span><br><span class="line">let imgSrc = canvas.toDataURL(&apos;image/png&apos;);</span><br><span class="line">this.listSharingLinkSrc = imgSrc;</span><br><span class="line">&#125;</span><br><span class="line">this.listShareShow = !this.listShareShow;</span><br><span class="line">&#125;,</span><br><span class="line">        /**</span><br><span class="line"> * 表格上方：下载二维码列表</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> */</span><br><span class="line">downloadQrcode(event, linkSrc, downloadFilename)&#123;</span><br><span class="line">event.stopPropagation();</span><br><span class="line">this.exportLink = linkSrc;</span><br><span class="line">this.downloadFilename = downloadFilename;</span><br><span class="line">this.download = true;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.exportLink = &apos;&apos;;</span><br><span class="line">this.download = false;</span><br><span class="line">this.downloadFilename = &apos;&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>代码写到这里，嗯，实现完了下载。但又发现又一需求，显示大小是<code>80 * 80</code>，下载需要是<code>160 * 160</code>。</p><h3 id="显示大小和下载大小不一样。"><a href="#显示大小和下载大小不一样。" class="headerlink" title="显示大小和下载大小不一样。"></a>显示大小和下载大小不一样。</h3><p>参考了下老模块，<code>qrcodejs</code>渲染出来的<code>html</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  跟这个类似</span><br><span class="line">&lt;div id=&quot;qrcode_1&quot; title=&quot;your content&quot;&gt;</span><br><span class="line">    &lt;canvas width=&quot;256&quot; height=&quot;256&quot; style=&quot;display: none;&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;img alt=&quot;Scan me!&quot; style=&quot;display: block;&quot; src=&quot;data:image/png;base64,xxx&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><code>vue-qriously</code>渲染出来是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;canvas width=&quot;80&quot; width=&quot;80&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>于是我可以把生成的<code>imgSrc</code>资源,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;canvas width=&quot;160&quot; width=&quot;160&quot; v-show=&quot;false&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;img class=&quot;img&quot; :src=&quot;imgSrc&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">.img&#123;</span><br><span class="line">    width: 80px;</span><br><span class="line">    height: 80px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>这就实现了下载的资源是<code>160 * 160</code>，用样式控制图片显示<code>80 * 80</code>。<br>代码写完，觉得应该给<code>vue-qriously</code>写个<code>pr</code>,实现 不仅仅是渲染<code>canvas</code>，而是让大家可以选择时<code>img</code>还是<code>canvas</code>。又去翻了翻这个项目的<code>issue</code>,有一个<code>issue</code><a href="https://github.com/theomessin/vue-qriously/issues/10" target="_blank" rel="noopener">链接：how to make this canvas exchange to img</a> 就是说的这个。还没关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i think u can create type let user select img and canvas.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 有一个回复</span><br><span class="line">If you want to make it become downloadable, maybe you can transform it from canvas easily by canvas.toDataURL()</span><br></pre></td></tr></table></figure><p>文章写到这里，我发现这样似乎不太妥。我的场景，是点击时显示浮层（浮层有二维码和复制链接地址和下载二维码按钮等），获取<code>canvas</code>元素，去转成<code>img</code> <code>src</code>，再去渲染到页面，而且图片可能会闪，因为是实际大小是<code>160</code>，样式强制控制在<code>80</code>。<br>何不生成两份，一份是用来获取资源下载的。一份用来显示的。嗯，之后去优化下。<br>顺带说一下，复制粘贴</p><h3 id="cliploard-复制粘贴"><a href="#cliploard-复制粘贴" class="headerlink" title="cliploard 复制粘贴"></a>cliploard 复制粘贴</h3><p>老模块中是用的<code>cliploard</code><a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard github仓库</a>。就是我引入的。</p><p>新模块还没使用过，但依然使用这个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">// npm install clipboard --save</span><br><span class="line">&lt;template @click=&quot;Clip($event, &apos;快来复制&apos;)&quot;&gt;&lt;template&gt;</span><br><span class="line">// 封装成一个函数</span><br><span class="line">import Clipboard from &apos;clipboard&apos;;</span><br><span class="line">export default function Clip(event，text) &#123;</span><br><span class="line">  const clipboard = new Clipboard(event.target, &#123;</span><br><span class="line">    text: () =&gt; text</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.on(&apos;success&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;复制成功&apos;);</span><br><span class="line">    clipboard.off(&apos;error&apos;);</span><br><span class="line">    clipboard.off(&apos;success&apos;);</span><br><span class="line">    clipboard.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.on(&apos;error&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;复制失败，请刷新试试&apos;);</span><br><span class="line">    clipboard.off(&apos;error&apos;)</span><br><span class="line">    clipboard.off(&apos;success&apos;)</span><br><span class="line">    clipboard.destroy()</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.onClick(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以封装成<code>vue</code>指令。<br>可以参考<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin这个项目</a><br>之前我看的时候还是<code>3000</code>多<code>star</code>，现在<code>1.2w+</code>，说明值得学习。<br>另外推荐<a href="https://www.awesomes.cn/" target="_blank" rel="noopener"><code>awesomes</code>网站 工具类库合集</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<strong>轩辕Rowboat</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、引入第三方插件等使用时，多查看<code>github</code> 文档 <code>issue</code>等，在技术社区搜索别人使用的方案。<br>2、选用第三方插件时，尽可能挑选<code>star</code>比较多的，<code>issue</code>处理比较及时的，在更新维护的。<br>3、富余时间可以多研究下别人的项目是如何组织文件，和实现的一些常用功能的。<br>4、尽可能去优化自己的代码，总结回顾。</p><p>文章首发于<a href="https://segmentfault.com/a/1190000014875645" target="_blank" rel="noopener">vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。&lt;br&gt;老模块是用的&lt;a href=&quot;http://code.ciaoca.com/javascript/qrcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qrocode中文文档&lt;/a&gt;，&lt;a href=&quot;https://github.com/davidshimjs/qrcodejs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qrcode github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;先想着新模块中是否有生成二维码的插件，看了下&lt;code&gt;package.json&lt;/code&gt;。&lt;br&gt;有安装一个&lt;a href=&quot;https://github.com/theomessin/vue-qriously&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-qriously&lt;/a&gt;…
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://lxchuan12.github.io/tags/vue/"/>
    
      <category term="qrcode" scheme="https://lxchuan12.github.io/tags/qrcode/"/>
    
      <category term="clipboard" scheme="https://lxchuan12.github.io/tags/clipboard/"/>
    
  </entry>
  
  <entry>
    <title>参加有赞前端技术开放日所感所想</title>
    <link href="https://lxchuan12.github.io/2018/04/21/20180421-youzan%20front-end%20tech%20open%20day/"/>
    <id>https://lxchuan12.github.io/2018/04/21/20180421-youzan front-end tech open day/</id>
    <published>2018-04-21T12:08:26.000Z</published>
    <updated>2018-05-27T06:07:07.006Z</updated>
    
    <content type="html"><![CDATA[<p>从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。<br>之前参加过网易云课堂学习节、拉勾网理想之上、<a href="https://coding.net/" target="_blank" rel="noopener">coding.net</a> 技术小馆、阿里<code>D2</code>两次、阿里<code>work like alibaba</code>沙龙、<code>freeCodeCamp</code>线下分享等…自己也参与到<code>freeCodeCamp</code>(<code>FCC</code>)，<a href="https://freecodecamp.cn/" target="_blank" rel="noopener">点击访问freeCodeCamp</a>，杭州线下分享活动的组织中<a id="more"></a></p><h3 id="为什么这么热衷于参加这类活动呢？"><a href="#为什么这么热衷于参加这类活动呢？" class="headerlink" title="为什么这么热衷于参加这类活动呢？"></a>为什么这么热衷于参加这类活动呢？</h3><p>可能拿之前D2填写的参会理由可以很好的解答这个问题。</p><p><strong>D2报名填写的参会理由:</strong><br>1、了解讲师碰到的问题，有哪些解决方案，是如何解决的，学习他们的解决思路和方案。<br>2、了解现在前端技术发展情况和未来发展趋势，把握学习方向。<br>3、结交前端圈内朋友，让自己融入到更积极的技术氛围，促进自己的技术提升。</p><h3 id="为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？"><a href="#为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？" class="headerlink" title="为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？"></a>为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？</h3><p>刚好看到知乎上有这个帖子。<a href="https://www.zhihu.com/question/274150609" target="_blank" rel="noopener">参加有赞前端技术开放日是种怎样的体验？</a></p><p>因为之前都是免费的活动。好像也没什么可写的。觉得发条朋友圈简明扼要的总结下即可。这次有赞的活动是收费的，都这么多人参加，直播观看量3w人次（最高时），而且有其他城市的人过来。比如：罗辑思维（北京），简书（上海）。<strong>可见前端圈的小伙伴对参与这类活动也是十分活跃的，同时说明了有赞宣传的比较好。</strong>所以，觉得有必要写一下。技术方面不多写，可以回看PPT，或视频。</p><p>可以看下官方微信公众号发布的活动总结文章，里面有PPT，视频回放等。<br><a href="https://mp.weixin.qq.com/s/9FIESH8rGaV0JPR1lMgUTQ" target="_blank" rel="noopener">有赞技术活动首秀——有赞前端技术开放日圆满结束</a><br>主题主要有：<br>1、主题一：有赞开源项目最佳实践<br>2、主题二：本地调试线上代码——<a href="https://github.com/youzan/zan-proxy" target="_blank" rel="noopener">已开源，点击访问<code>ZanProxy</code></a><br>3、主题三：让前后端协作更高效——<code>ZanAPI</code><br>4、主题四：<code>Node</code> 在有赞的实践<br>5、主题五：有赞内部代码管理工具串讲</p><p>为什么会有这么多产出，主要有三点：<br>1、业务逼的<br>2、工程师文化<br>3、注重技术基础</p><p>感觉就是有赞前端技术团队，碰到什么问题，奔着高效工作的目的，提出解决方案，团队内部适用、推广，最后把做得比较好的项目开源。<br>总之有赞前端技术团队靠谱、有追求。值得加入。</p><p>我是12点多到达场地。这时人还不多。拍了两张照。</p><img src="/2018/04/21/20180421-youzan%20front-end%20tech%20open%20day/first-1.jpg" title="开场前场外"><img src="/2018/04/21/20180421-youzan%20front-end%20tech%20open%20day/first-2.jpg" title="开场前场内"><h3 id="回顾一下整场活动，主要有六点："><a href="#回顾一下整场活动，主要有六点：" class="headerlink" title="回顾一下整场活动，主要有六点："></a>回顾一下整场活动，主要有六点：</h3><p><strong>1、人脉圈子</strong></p><p>有赞前端技术负责人施德来（下文简称<strong>德来</strong>）分享的缘起，说杭州兑吧公司想去有赞参观参观，交流交流。于是干脆办一个技术开放日。然后邀请了杭州一些公司来参与。比如点我达、丁香园、兑吧等。<br>说明杭州各个公司的前端负责人的有技术圈子，都相互认识熟悉，而且比较注重交流。<br>有人脉圈子，对于程序员来说，很重要。</p><p><strong>2、正向反馈</strong><br>虽然有赞搞了很多成功的项目，但也有失败的项目。<br>所有的失败项目，总结起来，就一条：没有准确估计投入产出比。<br>就是说没有正向反馈，就最后不了了之了。平时自己学习也是如此，如果没能看到正反馈，很难坚持下去。</p><p><strong>3、演讲能力</strong></p><p>德来宣称他们内部演讲已经练习过几次了。<br>程序员可能比较欠缺演讲能力，毕竟很少机会上台面对上百人演讲，分享技术。</p><p><strong>4、救场解围</strong><br>Q/A问答环节，可能有些问题讲师解答不是很清晰，或者说提问者不停追问，就容易导致僵持下去，现场尴尬，时间不可控等。<br>于是好几次都是德来来解答提问者的问题。</p><p><strong>5、技术（开源）项目本质上是：理念、套路、规范的工具化。</strong><br>这句话是德来说的，印象比较深刻。<br>比如开源的项目<a href="https://github.com/youzan/felint" target="_blank" rel="noopener">点击访问<code>felint</code></a>就是一个集成了 <code>eslint</code>、<code>stylelint</code>、<code>git hook</code> 的前端代码检查工具。<br>规范定好，提交代码时强制校验，或者说<strong>随你怎么写，代码都一样</strong>，最后提交会验证一遍。<br>我司用的就是<code>githooks</code> <code>git commit</code> 时校验代码规范性。</p><p><strong>6、参与到开源项目</strong><br>有余力的情况下，可以参与到开源项目，也是对自己的一种提升。</p><p>最后放两张照片</p><img src="/2018/04/21/20180421-youzan%20front-end%20tech%20open%20day/rest-time.jpg" title="茶歇时间场外交流"><img src="/2018/04/21/20180421-youzan%20front-end%20tech%20open%20day/full.jpg" title="微信群中工作人员拍的场内全景图">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。&lt;br&gt;之前参加过网易云课堂学习节、拉勾网理想之上、&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coding.net&lt;/a&gt; 技术小馆、阿里&lt;code&gt;D2&lt;/code&gt;两次、阿里&lt;code&gt;work like alibaba&lt;/code&gt;沙龙、&lt;code&gt;freeCodeCamp&lt;/code&gt;线下分享等…自己也参与到&lt;code&gt;freeCodeCamp&lt;/code&gt;(&lt;code&gt;FCC&lt;/code&gt;)，&lt;a href=&quot;https://freecodecamp.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击访问freeCodeCamp&lt;/a&gt;，杭州线下分享活动的组织中
    
    </summary>
    
      <category term="随笔" scheme="https://lxchuan12.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lxchuan12.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结，一如既往</title>
    <link href="https://lxchuan12.github.io/2018/01/05/20180105-2017-annual-summary/"/>
    <id>https://lxchuan12.github.io/2018/01/05/20180105-2017-annual-summary/</id>
    <published>2018-01-05T15:56:52.000Z</published>
    <updated>2018-01-10T14:33:54.066Z</updated>
    
    <content type="html"><![CDATA[<p>斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。</p><p>年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。<br>比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…<a id="more"></a><br><img src="/2018/01/05/20180105-2017-annual-summary/2017-cover.png" title="封面"><br>翻看着电脑上【N-年度总结】文件夹中2014~2016年年度总结。一般文件夹中有一份PPT和一份思维导图。</p><p>新建了一个【2017年】的文件夹，翻看2017年微博整理出2017微博时间轴，继而整理出2017年的各个方面的思维导图。</p><img src="/2018/01/05/20180105-2017-annual-summary/2017xmind.png" title="2017年八大层面"><p>再看看2017年年初的年度大体计划，付出、收获这样的词汇，似乎不太合适。2018年的年度计划不敢写了。</p><img src="/2018/01/05/20180105-2017-annual-summary/2017plan.jpg" title="2016年总结的最后一页PPT"><p>如果说2015年关键词是<strong>PPT</strong>，2016年说是<strong>毕业、开发</strong>，那么2017年依旧是<strong>开发</strong>。2017年和2016年基本一样，没什么波澜，一如既往。</p><h3 id="“丰富多彩的生活”"><a href="#“丰富多彩的生活”" class="headerlink" title="“丰富多彩的生活”"></a>“丰富多彩的生活”</h3><p>1月份，过年期间去舅舅家拜年，舅舅和姐夫都说我2016年工作后变了挺多，尤其酒量不错。大学室友说我工作后比较爱玩了，大学期间比较喜欢宅在寝室。其实我是那种宅也可以，游山玩水也可以的一类人。</p><p>12月份，和一朋友聊天，她说了一句：<strong>看你朋友圈各方面蛮精彩的</strong>。想起高中关系比较好的几个同学都在985、211读研，虽然他们表示比较羡慕我朋友圈发的”丰富多彩”的生活，但我也比较羡慕他们的。这也许就是人们常说的围城吧。城外的人想进城，城里的人想出城。</p><p>但事实上，我们总是习惯地去推测：看到一个人去图书馆，就推测TA博览群书。看到一个人发朋友圈在旅行，就推测TA经常在旅行。看到一个人去参加各种线下活动学习，就推测TA经常去参加这类活动。<br>于是将美好的别人与糟糕的自己对比，从而心生羡慕。但往往这种推测不准确。</p><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h3><p>这一年，每天基本都是12点10分左右，有时睡得比较晚上班就容易打哈欠，同事开玩笑说是不是早起偷能量了。</p><p>基本也没怎么锻炼，（半小时左右）上半年基本走路上下班，下半年就成基本骑车上下班了。</p><p>年初体检了一次，年底体检了一次，虽无大碍，但还是要注意身体。体检时听到体检机构的工作人员讨论，别看现在的年轻人年轻，但他们经常很晚才睡，熬夜，不吃早餐等。是啊，年轻人更应该注意身体，尤其是IT行业的程序员。</p><h3 id="慢慢打造“个人品牌”"><a href="#慢慢打造“个人品牌”" class="headerlink" title="慢慢打造“个人品牌”"></a>慢慢打造“个人品牌”</h3><p>这一年，换了工作，在前端开发上有所成长，偶尔会在segmentFault社区答题，主要是10月份，一个月声望值增长976分。月度排行榜排名第六。现在声望值2.2K。虽然比较少，但基本是今年才涨的。全年只在segmentFault社区、掘金发布了两篇文章。</p><p>5月份，开通了“前端视野”，知识星球（原“小密圈”），偶尔发一些前端开发相关的知识和感想，没怎么推广的情况下，没想到到年底有91人加入。</p><p>很多人努力学习知识，参加各种沙龙，向前辈学习，参加开源项目，把自己的心得无私的分享出来，慢慢的，他们踏上了不一样的平台，快速成长。</p><p>这样努力的人我朋友圈就有一位。毕业四年在北京，月薪早已超出同龄人的水平。但基本学习到2点左右睡，6:50起，午休睡一会，一般一天不少于6小时。还读着英文文档，玩转各种开发语言。想想我身边他这层次的人也没有这么拼啊，他解释道：个人追求也不同，追求也不一样。他都这样的努力确实让我敬佩不已。真是应了那句话：比你优秀的人不可怕，可怕的是比你优秀的人比你更努力。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>这一年，清明假期和同学去了江苏无锡鼋头渚、惠山古镇、三国城等。<br>太湖四月天，无锡鼋头渚。登上赏樱楼，樱花似白雪。<br>惠山古镇，历史悠久，古迹众多，人文荟萃。宝界山林，远眺太湖。湖光山色，相映生辉。<br><img src="/2018/01/05/20180105-2017-annual-summary/img1.jpg" title="太湖"><br><img src="/2018/01/05/20180105-2017-annual-summary/img2.jpg" title="三英醒狮会"><br><img src="/2018/01/05/20180105-2017-annual-summary/img3.jpg" title="三国城门口"></p><p>五一假期去了浙江舟山。人生中的第一次看海，海上日出日落。</p><img src="/2018/01/05/20180105-2017-annual-summary/img4.jpg" title="舟山海上日出"><img src="/2018/01/05/20180105-2017-annual-summary/img5.jpg"><p>随便放了几张照片。<br>2017年初上写的旅行计划去黄山、上海、出境游通通没有实现，现实版的计划赶不上变化，是多么痛的领悟。</p><h3 id="危机感"><a href="#危机感" class="headerlink" title="危机感"></a>危机感</h3><p>5月13日，和课题组的两位同学，一起回学校参加课题组老师的婚礼，老师说：“到时你们婚礼的时候派代表参加”。一次和毕业几年的表哥聊天，聊到年轻的时候最重要的两件事就是结婚和买房。同事也会问准备一直在杭州吗。感觉这类话题，不管和谁聊天都会聊到。我就感慨到：现如今，大学毕业生靠自己在杭州买房，真是难于上青天。</p><blockquote><p>到底有多难，我大概算了下。假如杭州郊区算3万一平，那么一套房算300万，首付30%则需90万。假如一年存款能有10万，那么也要攒9年。你可能会说工资会涨，但可以肯定没有房价涨得快…而且只是付完首付而已，就要9年。9年后又到了人们常说的中年危机，面对各方面的压力，那么以后的日子更加艰难。照这样想想都后怕。<br>但在大城市还是有一定机会的，虽然比较渺茫。<br>退一步回老家买房，但小县城房价均价据说都6K+了。而且感觉在老家买房，自己在外漂泊也不是办法啊。</p></blockquote><p>写到这里，看到统计的字数是1818字，刚好2018年，很吉利。2017年度总结算是收尾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。&lt;/p&gt;
&lt;p&gt;年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。&lt;br&gt;比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…
    
    </summary>
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践 读书笔记 - 未完待续...不用点开了~</title>
    <link href="https://lxchuan12.github.io/2017/12/05/20171205-JavaScript%20design%20patterns/"/>
    <id>https://lxchuan12.github.io/2017/12/05/20171205-JavaScript design patterns/</id>
    <published>2017-12-05T15:25:01.000Z</published>
    <updated>2018-06-23T13:41:18.067Z</updated>
    
    <content type="html"><![CDATA[<p>看完此书，打算慢慢整理下读书笔记。便于巩固消化。</p><h3 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h3><h3 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h3><h4 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h4><h5 id="定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。"><a href="#定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。" class="headerlink" title="定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。"></a>定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。</h5><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>比如弹窗</p><h5 id="通用的惰性单例"><a href="#通用的惰性单例" class="headerlink" title="通用的惰性单例"></a>通用的惰性单例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function(fn)&#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result ||  (result = fn.apply(this, arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三部分-设计原则和编程技巧"><a href="#第三部分-设计原则和编程技巧" class="headerlink" title="第三部分 设计原则和编程技巧"></a>第三部分 设计原则和编程技巧</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完此书，打算慢慢整理下读书笔记。便于巩固消化。&lt;/p&gt;
&lt;h3 id=&quot;第一部分-基础知识&quot;&gt;&lt;a href=&quot;#第一部分-基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 基础知识&quot;&gt;&lt;/a&gt;第一部分 基础知识&lt;/h3&gt;&lt;h3 id=&quot;第二部分-
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>移动端双击事件和PC端</title>
    <link href="https://lxchuan12.github.io/2017/12/04/20171204-mobile%20pc%20dblclick/"/>
    <id>https://lxchuan12.github.io/2017/12/04/20171204-mobile pc dblclick/</id>
    <published>2017-12-04T13:37:29.000Z</published>
    <updated>2017-12-04T14:49:57.395Z</updated>
    
    <content type="html"><![CDATA[<p>SF上，有个问题<a href="https://segmentfault.com/q/1010000012279336/a-1020000012280637" target="_blank" rel="noopener">想请教一下，一般类似于微信那样的，双击屏幕回到顶部是怎么做的呀？</a><br>刚开始我回答的直接是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 原生JS、PC端可以在`body`上添加双击事件</span><br><span class="line">document.addEventListener(&apos;dblclick&apos;, function()&#123;</span><br><span class="line">    window.scrollTo(0, 0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在PC端测试了下，没问题。然后再看到别人的回答，似乎好像在移动端不起作用。于是用<code>Chrome</code>浏览器的移动端模拟试了下果然没用。<br>然后百度搜索了下，看到两篇文章<a href="http://www.mzwu.com/article.asp?id=4276" target="_blank" rel="noopener">移动手机端不能触发jQuery双击事件dblclick解决方法</a>，<br><a href="http://drunkhero.com/bingolife/home.php/home/blog/detail/passage/59.html" target="_blank" rel="noopener">双击事件dblclick在移动端不起作用？</a>，<br>加上了下面的答案。测试通过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 移动端双击不起作用。</span><br><span class="line">// 可以用单击事件模拟</span><br><span class="line">var touchTime = Date.now();</span><br><span class="line">function handleClick()&#123;</span><br><span class="line">    if( Date.now() - touchTime &lt; 800 )&#123;</span><br><span class="line">         window.scrollTo(0, 0);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果第二次点击在第一次点击0.8秒后，</span><br><span class="line">        //则第二次点击默认为下一次双击判断的第一次点击</span><br><span class="line">        touchTime = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.addEventListener(&apos;click&apos;, handleClick);</span><br></pre></td></tr></table></figure></p><p>那么问题又来了，我知道直接在<code>document</code>上挂载事件是正确的。但为什么不用<code>document.body</code>呢，我一下说不上来。document.body是<code>&lt;body&gt;&lt;/body&gt;</code>。是<strong>只适用于<code>HTML</code>对象的<code>DOM</code>对象</strong>。类似这样的还有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.images -- 当前页面中所有图片的集合。等价于Core DOM组件中的document.getElementsByTagName(&apos;img&apos;)调用。</span><br><span class="line">document.applets -- 等价于document.getElementsByTagName(&apos;applets&apos;)。</span><br><span class="line">document.links -- 是一个列表，包含了页面中所有的`&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;`标签，也就是页面中所有含有`href`属性的A标签。</span><br><span class="line">document.anchors -- 是包含所有带name熟悉的链接。即`&lt;a name=&quot;...&quot;&gt;&lt;/a&gt;`</span><br><span class="line">document.forms -- 用的比较广泛。forms标签的集合。document.forms[0] === document.getElementsByTagName(&apos;form&apos;)[0]</span><br><span class="line">// 以上只适用于`HTML`对象的`DOM`对象内容，摘抄于《JavaScript面向对象编程指南 · 第2版》</span><br></pre></td></tr></table></figure></p><p>我们常见的获取元素是<code>document.querySelector(&#39;body&#39;)</code>，<code>document.getElementById()</code>，或者<code>document.getElementsByClassName()</code>,<code>document.getElementsByTagName()</code>,<code>document.getElementsByName()</code>等。<br>于是我谷歌了一下，<code>document</code>和<code>document.body</code>却出来了<code>document.ducumentElement</code>的对比。<br>我们知道<code>document.documentElement</code>是<code>HTML</code>节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(document)</span><br><span class="line">&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(document.body)</span><br><span class="line">&quot;[object HTMLBodyElement]&quot;</span><br><span class="line">Object.prototype.toString.call(document.documentElement)</span><br><span class="line">&quot;[object HTMLHtmlElement]&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var divNode = document.createElement(&apos;div&apos;);</span><br><span class="line">document.appendChild(divNode);</span><br><span class="line">// 报错：</span><br><span class="line">// VM396:1 Uncaught DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: Only one element on document allowed.</span><br><span class="line">document.body.appendChild(divNode);</span><br></pre></td></tr></table></figure><p>我翻了翻<code>w3c规范</code><br><a href="http://w3help.org/zh-cn/standards/" target="_blank" rel="noopener">W3C 标准内容列表</a><br><a href="https://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html" target="_blank" rel="noopener">1.文档对象模型（核心）级别1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptors(document);</span><br><span class="line">// &#123;location: &#123;&#125;&#125;</span><br><span class="line">document.location === window.location;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SF上，有个问题&lt;a href=&quot;https://segmentfault.com/q/1010000012279336/a-1020000012280637&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;想请教一下，一般类似于微信那样的，双击屏幕回到顶部
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript上卷-读书笔记 - 未完待续...不用点开了~</title>
    <link href="https://lxchuan12.github.io/2017/10/26/20171026-you%20don&#39;t%20know%20js-1/"/>
    <id>https://lxchuan12.github.io/2017/10/26/20171026-you don&#39;t know js-1/</id>
    <published>2017-10-26T15:36:52.000Z</published>
    <updated>2018-06-20T13:13:08.541Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望<br>你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之<br>后， 无论什么技术、 框架和流行词语你都能轻松理解。<br>使用代码示例<br>可以在这里下载本书第一部分“作用域和闭包” 随附的资料（代码示例、 练习题等） ：<br><a href="http://bit.ly/1c8HEWF。" target="_blank" rel="noopener">http://bit.ly/1c8HEWF。</a><br>可以在这里下载本书第二部分“this 和对象原型” 随附的资料（代码示例、 练习题等） ：<br><a href="http://bit.ly/ydkjs-this-code" target="_blank" rel="noopener">http://bit.ly/ydkjs-this-code</a><br>要了解更多 O’Reilly 图书、 培训课程、 会议和新闻的信息， 请访问以下网站：<br><a href="http://www.oreilly.com" target="_blank" rel="noopener">http://www.oreilly.com</a><br>我们在 Facebook 的地址如下： <a href="http://facebook.com/oreilly" target="_blank" rel="noopener">http://facebook.com/oreilly</a><br>请关注我们的 Twitter 动态： <a href="http://twitter.com/oreillymedia" target="_blank" rel="noopener">http://twitter.com/oreillymedia</a><br>我们的 YouTube 视频地址如下： <a href="http://www.youtube.com/oreillymedia" target="_blank" rel="noopener">http://www.youtube.com/oreillymedia</a><br>要查看“你不知道的 JavaScript” 系列丛书中的全部图书， 请访问：<br><a href="http://YouDontKnowJS.com" target="_blank" rel="noopener">http://YouDontKnowJS.com</a></p><h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><p>知其然， 也要知其所以然。</p><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h2><h4 id="分词-词法分析（Tokenizing-Lexing）"><a href="#分词-词法分析（Tokenizing-Lexing）" class="headerlink" title="分词/词法分析（Tokenizing/Lexing）"></a>分词/词法分析（Tokenizing/Lexing）</h4><p>这个过程会将由字符组成的字符串分解成（对编程语言来说） 有意义的代码块， 这些代<br>码块被称为词法单元（token）。 例如， 考虑程序 var a = 2;。 这段程序通常会被分解成<br>为下面这些词法单元： var、 a、 =、 2 、 ;。 空格是否会被当作词法单元， 取决于空格在<br>这门语言中是否具有意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望&lt;br&gt;你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之&lt;br&gt;后， 无论什么技术、 框架和流行词语你都能轻松理解。&lt;br&gt;使用
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript正则表达式迷你书-阅读笔记</title>
    <link href="https://lxchuan12.github.io/2017/10/12/20171012-JavaScript%20regex%20mini%20books%20reading%20record/"/>
    <id>https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/</id>
    <published>2017-10-12T15:45:52.000Z</published>
    <updated>2017-10-21T15:52:11.461Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">正则可视化工具</a><br><a href="https://regexper.com/#jsah" target="_blank" rel="noopener">正则可视化工具-regexper</a><br><a href="http://regex101.com/" target="_blank" rel="noopener">正则在线测试工具-regex101</a></p><h1 id="勘误："><a href="#勘误：" class="headerlink" title="勘误："></a>勘误：</h1><p>2.4.2.5. 格式化<br>$ 1888.00 -&gt; $ 1,888.00</p><p>3.3.1. 括号嵌套怎么办？<br>最后的是 \4，找到第3个开括号  -&gt; 最后的是 \4，找到第4个开括号</p><p>3.5.6. 匹配成对标签<br>其中开标签 &lt;[\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;  -&gt;  其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt;</p><p>5.1. 结构和操作符<br>在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构—&gt;按照原文：这里的因此应该不标红。</p><p>6.3.2. 匹配浮点数<br>因此整个正则是这三者的或的关系，提取公众部分后是：—-&gt;公共部分</p><p>[《JavaScript 正则表达式迷你书》问世了！]（<a href="https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）</a></p><h1 id="记录一些学到的"><a href="#记录一些学到的" class="headerlink" title="记录一些学到的"></a>记录一些学到的</h1><h1 id="1-第一章-正则表达式字符匹配攻略"><a href="#1-第一章-正则表达式字符匹配攻略" class="headerlink" title="1. 第一章 正则表达式字符匹配攻略"></a>1. 第一章 正则表达式字符匹配攻略</h1><h3 id="1-2-1-范围表示法"><a href="#1-2-1-范围表示法" class="headerlink" title="1.2.1. 范围表示法"></a>1.2.1. 范围表示法</h3><p>因为连字符有特殊用途，那么要匹配 “a”、”-“、”z” 这三者中任意一个字符，该怎么做呢？<br>不能写成 [a-z]，因为其表示小写字符中的任何一个字符。<br>可以写成如下的方式：[-az] 或 [az-] 或 [a-z]。<br>即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</p><h3 id="1-2-3-常见的简写形式"><a href="#1-2-3-常见的简写形式" class="headerlink" title="1.2.3. 常见的简写形式"></a>1.2.3. 常见的简写形式</h3><p>如果要匹配任意字符怎么办？可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。</p><h3 id="1-3-2-贪婪匹配与惰性匹配"><a href="#1-3-2-贪婪匹配与惰性匹配" class="headerlink" title="1.3.2. 贪婪匹配与惰性匹配"></a>1.3.2. 贪婪匹配与惰性匹配</h3><p>其中 /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。</p><h2 id="1-4-多选分支"><a href="#1-4-多选分支" class="headerlink" title="1.4. 多选分支"></a>1.4. 多选分支</h2><p>但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 “goodbye” 字符串时，结果是 “good”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|goodbye/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;good&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /goodbye|good/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;goodbye&quot;]</span><br></pre></td></tr></table></figure><p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</p><h3 id="1-5-1-匹配-16-进制颜色值"><a href="#1-5-1-匹配-16-进制颜色值" class="headerlink" title="1.5.1. 匹配 16 进制颜色值"></a>1.5.1. 匹配 16 进制颜色值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line">var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;]</span><br></pre></td></tr></table></figure><h3 id="1-5-2-匹配时间"><a href="#1-5-2-匹配时间" class="headerlink" title="1.5.2. 匹配时间"></a>1.5.2. 匹配时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><p>如果也要求匹配 “7:9”，也就是说时分前面的 “0” 可以省略。<br>此时正则变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">console.log( regex.test(&quot;7:9&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-3-匹配日期"><a href="#1-5-3-匹配日期" class="headerlink" title="1.5.3. 匹配日期"></a>1.5.3. 匹配日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line">console.log( regex.test(&quot;2017-06-10&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-4-window-操作系统文件路径"><a href="#1-5-4-window-操作系统文件路径" class="headerlink" title="1.5.4. window 操作系统文件路径"></a>1.5.4. window 操作系统文件路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/;</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\regular expression.pdf&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-5-匹配-id"><a href="#1-5-5-匹配-id" class="headerlink" title="1.5.5. 匹配 id"></a>1.5.5. 匹配 id</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 解决之道，可以使用惰性匹配：</span><br><span class="line">var regex = /id=&quot;.*?&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br></pre></td></tr></table></figure><p>当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;[^&quot;]*&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br><span class="line">// 思考：id里有特殊字符呢。</span><br></pre></td></tr></table></figure><h1 id="2-第二章-正则表达式位置匹配攻略"><a href="#2-第二章-正则表达式位置匹配攻略" class="headerlink" title="2. 第二章 正则表达式位置匹配攻略"></a>2. 第二章 正则表达式位置匹配攻略</h1><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p><h2 id="2-2-如何匹配位置呢？"><a href="#2-2-如何匹配位置呢？" class="headerlink" title="2.2. 如何匹配位置呢？"></a>2.2. 如何匹配位置呢？</h2><p>在 ES5 中，共有 6 个锚：<br>^、$、\b、\B、(?=p)、(?!p)</p><h3 id="2-2-1-和"><a href="#2-2-1-和" class="headerlink" title="2.2.1. ^ 和 $"></a>2.2.1. ^ 和 $</h3><p>^（脱字符）匹配开头，在多行匹配中匹配行开头。<br>$（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p><h3 id="2-2-2-b-和-B"><a href="#2-2-2-b-和-B" class="headerlink" title="2.2.2. \b 和 \B"></a>2.2.2. \b 和 \B</h3><p>\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。<br>比如考察文件名 “[JS] Lesson_01.mp4” 中的 \b，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\b/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></pre></td></tr></table></figure></p><p>\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。<br>具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。<br>比如上面的例子，把所有 \B 替换成 “#”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\B/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-p-和-p"><a href="#2-2-3-p-和-p" class="headerlink" title="2.2.3. (?=p) 和 (?!p)"></a>2.2.3. (?=p) 和 (?!p)</h3><p>(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。<br>比如 (?=l)，表示 “l” 字符前面的位置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;he#l#lo&quot;</span><br></pre></td></tr></table></figure></p><p>而 (?!p) 就是 (?=p) 的反面意思，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#h#ell#o#&quot;</span><br></pre></td></tr></table></figure></p><p>二者的学名分别是 positive lookahead 和 negative lookahead。<br>中文翻译分别是正向先行断言和负向先行断言。<br>ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。<br>具体是 (?&lt;=p) 和 (?&lt;!p)。<br>也有书上把这四个东西，翻译成环视，即看看右边和看看左边。<br>但一般书上，没有很好强调这四者是个位置。<br>比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。<br><strong>而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。</strong></p><h2 id="2-3-位置的特性"><a href="#2-3-位置的特性" class="headerlink" title="2.3. 位置的特性"></a>2.3. 位置的特性</h2><p><strong>对于位置的理解，我们可以理解成空字符 “”。</strong><br>也等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /^^hello$$$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>甚至可以写成更复杂的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /(?=he)^^he(?=\w)llo$\b\b$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>也就是说字符之间的位置，可以写成多个。</p><p><strong>TIP 把位置理解空字符，是对位置非常有效的理解方式。</strong></p><h2 id="2-4-相关案例"><a href="#2-4-相关案例" class="headerlink" title="2.4. 相关案例"></a>2.4. 相关案例</h2><h3 id="2-4-1-不匹配任何东西的正则"><a href="#2-4-1-不匹配任何东西的正则" class="headerlink" title="2.4.1. 不匹配任何东西的正则"></a>2.4.1. 不匹配任何东西的正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.^/</span><br></pre></td></tr></table></figure><h3 id="2-4-2-数字的千位分隔符表示法"><a href="#2-4-2-数字的千位分隔符表示法" class="headerlink" title="2.4.2 数字的千位分隔符表示法"></a>2.4.2 数字的千位分隔符表示法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。</span><br><span class="line">var regex = /(?!^)(?=(\d&#123;3&#125;)+$)/g;</span><br><span class="line">var result = &quot;12345678&quot;.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678&quot;</span><br><span class="line">result = &quot;123456789&quot;.replace(regex, &apos;,&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;123,456,789&quot;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/lxchuan12/html5/blob/gh-pages/JS%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/5.2%E3%80%81%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D.html" target="_blank" rel="noopener">github上 demo 5.2、添加千分位</a></p><p><a href="https://idiotwu.me/milli-formatting-digitals-with-regex/" target="_blank" rel="noopener">千位分隔符的完整攻略</a></p><h4 id="2-4-2-4-支持其他形式"><a href="#2-4-2-4-支持其他形式" class="headerlink" title="2.4.2.4. 支持其他形式"></a>2.4.2.4. 支持其他形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345678 123456789&quot;,</span><br><span class="line">regex = /(?!\b)(?=(\d&#123;3&#125;)+\b)/g;</span><br><span class="line">var result = string.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678 123,456,789&quot;</span><br></pre></td></tr></table></figure><p>其中 (?!\b) 怎么理解呢？<br>要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。<br>因此最终正则变成了：/\B(?=(\d{3})+\b)/g。</p><h4 id="2-4-2-5-格式化"><a href="#2-4-2-5-格式化" class="headerlink" title="2.4.2.5. 格式化"></a>2.4.2.5. 格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function format (num) &#123;</span><br><span class="line">return num.toFixed(2).replace(/\B(?=(\d&#123;3&#125;)+\b)/g, &quot;,&quot;).replace(/^/, &quot;$$ &quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log( format(1888) );</span><br><span class="line">// =&gt; &quot;$ 1,888.00&quot;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-验证密码问题（TODO-Read-again）"><a href="#2-4-3-验证密码问题（TODO-Read-again）" class="headerlink" title="2.4.3. 验证密码问题（TODO Read again）"></a>2.4.3. 验证密码问题（TODO Read again）</h3><p>密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。<br>此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。<br>那么，我们就来挑战一下。看看我们对位置的理解是否深刻。<br>（(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。）</p><p>// 扩展： 密码中必须包含字母、数字、特称字符，至少8个字符，最多30个字符。</p><p><a href="https://segmentfault.com/q/1010000007500712/a-1020000007500959" target="_blank" rel="noopener">Array.apply(null, {length: 10})和Array(10)有什么区别?</a></p><p><a href="https://segmentfault.com/q/1010000006793990" target="_blank" rel="noopener">关于apply，Array.apply(null, {length:5})怎么理解</a></p><h1 id="第三章-正则表达式括号的作用"><a href="#第三章-正则表达式括号的作用" class="headerlink" title="第三章 正则表达式括号的作用"></a>第三章 正则表达式括号的作用</h1><p><strong>NOTE</strong> match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的<br>内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match<br>返回的数组格式是不一样的。</p><h3 id="3-2-1-提取数据"><a href="#3-2-1-提取数据" class="headerlink" title="3.2.1. 提取数据"></a>3.2.1. 提取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 提取日期</span><br><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">console.log( regex.exec(string) );  // 这里的结果一样。</span><br><span class="line">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span><br></pre></td></tr></table></figure><p>同时，也可以使用构造函数的全局属性 $1 至 $9 来获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">//regex.exec(string);</span><br><span class="line">//string.match(regex);</span><br><span class="line">console.log(RegExp.$1); // &quot;2017&quot;</span><br><span class="line">console.log(RegExp.$2); // &quot;06&quot;</span><br><span class="line">console.log(RegExp.$3); // &quot;12&quot;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-替换"><a href="#3-2-2-替换" class="headerlink" title="3.2.2. 替换"></a>3.2.2. 替换</h3><p>比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">var result = string.replace(regex, &quot;$2/$3/$1&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;06/12/2017&quot;</span><br></pre></td></tr></table></figure></p><p>其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result = string.replace(regex, function () &#123;</span><br><span class="line">return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 也等价于</span><br><span class="line">var result = string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">return month + &quot;/&quot; + day + &quot;/&quot; + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h2 id="3-3-反向引用"><a href="#3-3-反向引用" class="headerlink" title="3.3. 反向引用"></a>3.3. 反向引用</h2><p>除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。(\1,\2)这类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = &quot;2017-06-12&quot;;</span><br><span class="line">var string2 = &quot;2017/06/12&quot;;</span><br><span class="line">var string3 = &quot;2017.06.12&quot;;</span><br><span class="line">var string4 = &quot;2016-06/12&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // true</span><br><span class="line">console.log( regex.test(string4) ); // false</span><br></pre></td></tr></table></figure></p><h3 id="3-3-1-括号嵌套怎么办？"><a href="#3-3-1-括号嵌套怎么办？" class="headerlink" title="3.3.1. 括号嵌套怎么办？"></a>3.3.1. 括号嵌套怎么办？</h3><p>以左括号（开括号）为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = &quot;1231231233&quot;;</span><br><span class="line">console.log( regex.test(string) ); // true</span><br><span class="line">console.log( RegExp.$1 ); // 123</span><br><span class="line">console.log( RegExp.$2 ); // 1</span><br><span class="line">console.log( RegExp.$3 ); // 23</span><br><span class="line">console.log( RegExp.$4 ); // 3</span><br></pre></td></tr></table></figure></p><p><a href="https://regexper.com/#%5E((%5Cd" target="_blank" rel="noopener">该正则图形化</a>(%5Cd(%5Cd)))%5C1%5C2%5C3%5C4%24)</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">在线正则测试</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((\d)(\d([a-z])))\1\2\3\4$</span><br><span class="line">12a12a12aa</span><br></pre></td></tr></table></figure></p><h3 id="3-3-2-10-表示什么呢？"><a href="#3-3-2-10-表示什么呢？" class="headerlink" title="3.3.2. \10 表示什么呢？"></a>3.3.2. \10 表示什么呢？</h3><p>另外一个疑问可能是，即 \10 是表示第 10 个分组，还是 \1 和 0 呢？<br>答案是前者，虽然一个正则里出现 \10 比较罕见。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;</span><br><span class="line">var string = &quot;123456789# ######&quot;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p><strong>TIP</strong> 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)。</p><h3 id="3-3-3-引用不存在的分组会怎样？"><a href="#3-3-3-引用不存在的分组会怎样？" class="headerlink" title="3.3.3. 引用不存在的分组会怎样？"></a>3.3.3. 引用不存在的分组会怎样？</h3><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配<br>反向引用的字符本身。例如 \2，就匹配 “\2”。注意 “\2” 表示对 “2” 进行了转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(&quot;\1\2\3\4\5\6\7\8\9&quot;) );</span><br><span class="line">console.log( &quot;\1\2\3\4\5\6\7\8\9&quot;.split(&quot;&quot;) );</span><br><span class="line">// Chrome 浏览器打印的结果（不同的浏览器和版本，打印的结果可能不一样）</span><br></pre></td></tr></table></figure></p><h3 id="3-3-4-分组后面有量词会怎样？"><a href="#3-3-4-分组后面有量词会怎样？" class="headerlink" title="3.3.4. 分组后面有量词会怎样？"></a>3.3.4. 分组后面有量词会怎样？</h3><p>分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+/;</span><br><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p><p>同理对于反向引用，也是这样的。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+ \1/;</span><br><span class="line">console.log( regex.test(&quot;12345 1&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( regex.test(&quot;12345 5&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h2 id="3-4-非捕获括号"><a href="#3-4-非捕获括号" class="headerlink" title="3.4. 非捕获括号"></a>3.4. 非捕获括号</h2><p>之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分<br>支。<br>如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。<br>此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)。</p><h2 id="3-5-相关案例"><a href="#3-5-相关案例" class="headerlink" title="3.5. 相关案例"></a>3.5. 相关案例</h2><h3 id="3-5-1-字符串-trim-方法模拟"><a href="#3-5-1-字符串-trim-方法模拟" class="headerlink" title="3.5.1. 字符串 trim 方法模拟"></a>3.5.1. 字符串 trim 方法模拟</h3><p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim(str) &#123;</span><br><span class="line">return str.replace(/^\s+|\s+$/g, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar&quot;</span><br></pre></td></tr></table></figure></p><p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim (str) &#123;</span><br><span class="line">return str.replace(/^\s*(.*?)\s*$/g, &quot;$1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar</span><br></pre></td></tr></table></figure></p><p>当然，前者效率高。</p><h3 id="3-5-2-将每个单词的首字母转换为大写"><a href="#3-5-2-将每个单词的首字母转换为大写" class="headerlink" title="3.5.2. 将每个单词的首字母转换为大写"></a>3.5.2. 将每个单词的首字母转换为大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unction titleize (str) &#123;</span><br><span class="line">    return str.toLowerCase().replace(/(?:^|\s)\w/g, function (c) &#123;</span><br><span class="line">        return c.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(&apos;my name is epeli&apos;) );</span><br><span class="line">// =&gt; &quot;My Name Is Epeli&quot;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-驼峰化"><a href="#3-5-3-驼峰化" class="headerlink" title="3.5.3. 驼峰化"></a>3.5.3. 驼峰化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function camelize (str) &#123;</span><br><span class="line">    return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123;</span><br><span class="line">        return c ? c.toUpperCase() : &apos;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(&apos;-moz-transform&apos;) );</span><br><span class="line">// =&gt; &quot;MozTransform&quot;</span><br><span class="line">// 这里c不需要判断。&apos;&apos;.toUpperCase() === &apos;&apos;; // true</span><br></pre></td></tr></table></figure><h3 id="3-5-4-中划线化"><a href="#3-5-4-中划线化" class="headerlink" title="3.5.4. 中划线化"></a>3.5.4. 中划线化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function dasherize (str) &#123;</span><br><span class="line">    return str.replace(/([A-Z])/g, &apos;-$1&apos;).replace(/[-_\s]+/g, &apos;-&apos;).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">console.log( dasherize(&apos;MozTransform&apos;) );</span><br><span class="line">// =&gt; &quot;-moz-transform&quot;</span><br></pre></td></tr></table></figure><h3 id="3-5-5-HTML-转义和反转义"><a href="#3-5-5-HTML-转义和反转义" class="headerlink" title="3.5.5. HTML 转义和反转义"></a>3.5.5. HTML 转义和反转义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 将HTML特殊字符转换成等值的实体</span><br><span class="line">function escapeHTML (str) &#123;</span><br><span class="line">    var escapeChars = &#123;</span><br><span class="line">    &apos;&lt;&apos; : &apos;lt&apos;,</span><br><span class="line">    &apos;&gt;&apos; : &apos;gt&apos;,</span><br><span class="line">    &apos;&quot;&apos; : &apos;quot&apos;,</span><br><span class="line">    &apos;&amp;&apos; : &apos;amp&apos;,</span><br><span class="line">    &apos;\&apos;&apos; : &apos;#39&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(new RegExp(&apos;[&apos; + Object.keys(escapeChars).join(&apos;&apos;) +&apos;]&apos;, &apos;g&apos;),</span><br><span class="line">    function (match) &#123;</span><br><span class="line">        return &apos;&amp;&apos; + escapeChars[match] + &apos;;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( escapeHTML(&apos;&lt;div&gt;Blah blah blah&lt;/div&gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;;</span><br></pre></td></tr></table></figure><p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。<br>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 实体字符转换为等值的HTML。</span><br><span class="line">function unescapeHTML (str) &#123;</span><br><span class="line">    var htmlEntities = &#123;</span><br><span class="line">        nbsp: &apos; &apos;,</span><br><span class="line">        lt: &apos;&lt;&apos;,</span><br><span class="line">        gt: &apos;&gt;&apos;,</span><br><span class="line">        quot: &apos;&quot;&apos;,</span><br><span class="line">        amp: &apos;&amp;&apos;,</span><br><span class="line">        apos: &apos;\&apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(/\&amp;([^;]+);/g, function (match, key) &#123;</span><br><span class="line">        if (key in htmlEntities) &#123;</span><br><span class="line">            return htmlEntities[key];</span><br><span class="line">        &#125;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure></p><p>通过 key 获取相应的分组引用，然后作为对象的键。</p><h3 id="3-5-6-匹配成对标签"><a href="#3-5-6-匹配成对标签" class="headerlink" title="3.5.6. 匹配成对标签"></a>3.5.6. 匹配成对标签</h3><p>要求匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line">&lt;p&gt;laoyao bye bye&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;，<br>匹配一个闭标签，可以使用 &lt;\/[^&gt;]+&gt;，<br>但是要求匹配成对标签，那就需要使用反向引用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;</span><br><span class="line">var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;</span><br><span class="line">var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // false</span><br></pre></td></tr></table></figure></p><p><strong>疑惑</strong>：为什么这里没有用.<em>匹配呢，或者说为啥没用.</em>?阻止贪婪匹配模式（惰性模式）呢</p><h1 id="4-第四章-正则表达式回溯法原理"><a href="#4-第四章-正则表达式回溯法原理" class="headerlink" title="4. 第四章 正则表达式回溯法原理"></a>4. 第四章 正则表达式回溯法原理</h1><p>学习正则表达式，是需要懂点儿匹配原理的。<br>而研究匹配原理时，有两个字出现的频率比较高：“回溯”。</p><h2 id="4-1-没有回溯的匹配"><a href="#4-1-没有回溯的匹配" class="headerlink" title="4.1. 没有回溯的匹配"></a>4.1. 没有回溯的匹配</h2><p>假设我们的正则是 /ab{1,3}c/，<br>而当目标字符串是 “abbbc” 时，就没有所谓的“回溯”。</p><h2 id="4-2-有回溯的匹配"><a href="#4-2-有回溯的匹配" class="headerlink" title="4.2. 有回溯的匹配"></a>4.2. 有回溯的匹配</h2><p>如果目标字符串是”abbc”，中间就有回溯。</p><p>图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 “b”，准备尝试第三个时，<br>结果发现接下来的字符是 “c”。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即<br>第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 “c”。当然，此时整个表达式匹配成功了。<br>图中的第 6 步，就是“回溯”。</p><p>再举一个例子：<br>/ab{1,3}bbc/</p><p>目标字符串是”abbbc”，匹配过程是：<br>/“.*”/<br>目标字符串是：”abc”de，</p><p>图中省略了尝试匹配双引号失败的过程。可以看出 .<em> 是非常影响效率的。<br>为了减少一些不必要的回溯，可以把正则修改为 /“[^”]</em>“/。</p><h2 id="4-3-常见的回溯形式"><a href="#4-3-常见的回溯形式" class="headerlink" title="4.3. 常见的回溯形式"></a>4.3. 常见的回溯形式</h2><p>正则表达式匹配字符串的这种方式，有个学名，叫<strong>回溯法</strong>。</p><p>本质上就是<strong>深度优先搜索算法</strong>。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中<br>，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。<br>道理，我们是懂了。<strong>那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？</strong></p><h3 id="4-3-1-贪婪量词"><a href="#4-3-1-贪婪量词" class="headerlink" title="4.3.1 贪婪量词"></a>4.3.1 贪婪量词</h3><p>之前的例子都是贪婪量词相关的。</p><p>此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？<br>答案是，先下手为强！因为深度优先搜索。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">var regex = /(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="4-3-2-惰性量词"><a href="#4-3-2-惰性量词" class="headerlink" title="4.3.2 惰性量词"></a>4.3.2 惰性量词</h3><p>虽然惰性量词不贪，但也会有回溯的现象。<br>比如正则式：/^\d{1,3}?\d{1,3}$/<br>目标字符串是 “12345”。</p><p>知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \d{1,3}? 匹配的字<br>符是 “12”，是两个数字，而不是一个。</p><h3 id="4-3-3-分支结构"><a href="#4-3-3-分支结构" class="headerlink" title="4.3.3 分支结构"></a>4.3.3 分支结构</h3><p>我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 “candy”，得到的结果是 “can”，因为分支会<br>一个一个尝试，如果前面的满足了，后面就不会再试验了。<br>分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分<br>支。这种尝试也可以看成一种回溯。</p><p>比如：/^(?:can|candy)$/ 目标字符串是’candy’</p><p>上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是<br>一种回溯的。</p><h2 id="4-4-本章小结"><a href="#4-4-本章小结" class="headerlink" title="4.4. 本章小结"></a>4.4. 本章小结</h2><p>其实回溯法，很容易掌握的。<br>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最<br>后都试完后，发现整体匹配不成功。</p><blockquote><p>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。<br>• 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。<br>• 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。<br>既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动<br>机”的简写。<br>而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。<br>大部分语言中的正则都是 NFA，为啥它这么流行呢？<br>答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。</p></blockquote><h1 id="5-第五章-正则表达式的拆分"><a href="#5-第五章-正则表达式的拆分" class="headerlink" title="5. 第五章 正则表达式的拆分"></a>5. 第五章 正则表达式的拆分</h1><h2 id="5-1-结构和操作符"><a href="#5-1-结构和操作符" class="headerlink" title="5.1. 结构和操作符"></a>5.1. 结构和操作符</h2><p>JavaScript 正则表达式中，都有哪些结构呢？<br>字符字面量、字符组、量词、锚、分组、选择分支、反向引用。</p><p><strong>其中涉及到的操作符有：</strong><br>操作符描述 操作符 优先级<br>转义符  \  1<br>括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2<br>量词限定符 {m}、{m,n}、{m,}、?、*、+ 3<br>位置和序列 ^、$、\元字符、一般字符 4<br>管道符（竖杠） | 5</p><h2 id="5-2-注意要点"><a href="#5-2-注意要点" class="headerlink" title="5.2. 注意要点"></a>5.2. 注意要点</h2><h3 id="5-2-1-匹配字符串整体问题"><a href="#5-2-1-匹配字符串整体问题" class="headerlink" title="5.2.1 匹配字符串整体问题"></a>5.2.1 匹配字符串整体问题</h3><p>比如要匹配目标字符串 “abc” 或者 “bcd” 时，如果一不小心，就会写成 /^abc|bcd$/。<br>而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是。</p><p>开始-abc<br>bcd-结束<br>应该是：<br>/^(abc|bcd)$/</p><h3 id="5-2-2-量词连缀问题"><a href="#5-2-2-量词连缀问题" class="headerlink" title="5.2.2 量词连缀问题"></a>5.2.2 量词连缀问题</h3><ol><li>每个字符为 “a、”b”、”c” 任选其一，</li><li>字符串的长度是 3 的倍数。<br><code>/^[abc]{3}+$/</code>，这样会报错，说 + 前面没什么可重复的。<br>应该为：<br>/([abc]{3})+/</li></ol><h3 id="5-2-3-元字符转义问题"><a href="#5-2-3-元字符转义问题" class="headerlink" title="5.2.3 元字符转义问题"></a>5.2.3 元字符转义问题</h3><p>所谓元字符，就是正则中有特殊含义的字符。<br>所有结构里，用到的元字符总结如下：<br>^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,<br>当匹配上面的字符本身时，可以一律转义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,/;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>其中 string 中的 \ 字符也要转义的。<br>另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var string2 = &quot;\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,&quot;;</span><br><span class="line">console.log( string == string2 );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>现在的问题是，是不是每个字符都需要转义呢？否，看情况。</p><h4 id="5-2-3-1-字符组中的元字符"><a href="#5-2-3-1-字符组中的元字符" class="headerlink" title="5.2.3.1. 字符组中的元字符"></a>5.2.3.1. 字符组中的元字符</h4><p>跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然<br>会把整个字符组，看成反义字符组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /[\^$.*+?|\\/\[\]&#123;&#125;=!:\-,]/g;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;,</span><br><span class="line">&quot;-&quot;, &quot;,&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="5-2-3-2-匹配-“-abc-”-和-“-3-5-”"><a href="#5-2-3-2-匹配-“-abc-”-和-“-3-5-”" class="headerlink" title="5.2.3.2. 匹配 “[abc]” 和 “{3,5}”"></a>5.2.3.2. 匹配 “[abc]” 和 “{3,5}”</h4><p>我们知道 [abc]，是个字符组。如果要匹配字符串 “[abc]” 时，该怎么办？<br>可以写成 /[abc]/，也可以写成 /[abc]/<br>只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。</p><p>同理，要匹配字符串 “{3,5}”，只需要把正则写成 /{3,5}/ 即可。<br>另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报<br>错。当然，匹配的字符串也是 “{,n}”，测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;&#123;,3&#125;&quot;;</span><br><span class="line">var regex = /&#123;,3&#125;/g;</span><br><span class="line">console.log( string.match(regex)[0] );</span><br><span class="line">// =&gt; &quot;&#123;,3&#125;&quot;</span><br></pre></td></tr></table></figure></p><h4 id="5-2-3-3-其余情况"><a href="#5-2-3-3-其余情况" class="headerlink" title="5.2.3.3. 其余情况"></a>5.2.3.3. 其余情况</h4><p>比如 =、!、:、-、, 等符号，只要不在特殊结构中，并不需要转义。<br>但是，括号需要前后都转义的，如 /(123)/。<br>至于剩下的 ^、$、.、*、+、?、|、\、/ 等字符，只要不在字符组内，都需要转义的。</p><h2 id="5-3-案例分析"><a href="#5-3-案例分析" class="headerlink" title="5.3. 案例分析"></a>5.3. 案例分析</h2><h3 id="5-3-1-身份证"><a href="#5-3-1-身份证" class="headerlink" title="5.3.1 身份证"></a>5.3.1 身份证</h3><p>正则表达式是：<br>/^(\d{15}|\d{17}[\dxX])$/</p><h3 id="5-3-2-IPV4-地址"><a href="#5-3-2-IPV4-地址" class="headerlink" title="5.3.2 IPV4 地址"></a>5.3.2 IPV4 地址</h3><p>正则表达式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)&#123;3&#125;(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/</span><br></pre></td></tr></table></figure></p><p>这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：<br>((…).){3}(…)<br>其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是<br>3位数.3位数.3位数.3位数<br>然后再来分析 (…)：<br>(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])</p><h1 id="6-第六章-正则表达式的构建"><a href="#6-第六章-正则表达式的构建" class="headerlink" title="6. 第六章 正则表达式的构建"></a>6. 第六章 正则表达式的构建</h1><h2 id="6-1-平衡法则"><a href="#6-1-平衡法则" class="headerlink" title="6.1. 平衡法则"></a>6.1. 平衡法则</h2><p>构建正则有一点非常重要，需要做到下面几点的平衡：<br>1.• 匹配预期的字符串<br>2.• 不匹配非预期的字符串<br>3.• 可读性和可维护性<br>4.• 效率</p><h2 id="6-2-构建正则前提"><a href="#6-2-构建正则前提" class="headerlink" title="6.2. 构建正则前提"></a>6.2. 构建正则前提</h2><p>比如匹配这样的字符串：1010010001…。<br>虽然很有规律，但是只靠正则就是无能为力。</p><h3 id="6-2-2-是否有必要使用正则？"><a href="#6-2-2-是否有必要使用正则？" class="headerlink" title="6.2.2. 是否有必要使用正则？"></a>6.2.2. 是否有必要使用正则？</h3><p>要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。<strong>能用字符串 API 解决的简单问题，就不该正则出马。</strong></p><p>比如，从日期中提取出年月日，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var regex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;]</span><br></pre></td></tr></table></figure></p><p>其实，可以使用字符串的 split 方法来做，即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var result = string.split(&quot;-&quot;);</span><br><span class="line">console.log( result );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]</span><br></pre></td></tr></table></figure></p><p>比如，判断是否有问号，虽然可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.search(/\?/) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p><p>其实，可以使用字符串的 indexOf 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.indexOf(&quot;?&quot;) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p><p>比如获取子串，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.match(/.&#123;4&#125;(.+)/)[1] );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p><p>其实，可以直接使用字符串的 substring 或 substr 方法（语言精粹中推荐使用slice,substr是在ES5规范附则里。）来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.substring(4) );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p><h3 id="6-2-3-是否有必要构建一个复杂的正则？"><a href="#6-2-3-是否有必要构建一个复杂的正则？" class="headerlink" title="6.2.3. 是否有必要构建一个复杂的正则？"></a>6.2.3. 是否有必要构建一个复杂的正则？</h3><p>6.2.3. 是否有必要构建一个复杂的正则？<br>比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字<br>符。<br>在第2章里，我们写出了正则是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">其实可以使用多个小正则来做：</span><br><span class="line">var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;</span><br><span class="line">var regex2 = /^[0-9]&#123;6,12&#125;$/;</span><br><span class="line">var regex3 = /^[A-Z]&#123;6,12&#125;$/;</span><br><span class="line">var regex4 = /^[a-z]&#123;6,12&#125;$/;</span><br><span class="line">function checkPassword (string) &#123;</span><br><span class="line">    if (!regex1.test(string)) return false;</span><br><span class="line">    if (regex2.test(string)) return false;</span><br><span class="line">    if (regex3.test(string)) return false;</span><br><span class="line">    if (regex4.test(string)) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-准确性"><a href="#6-3-准确性" class="headerlink" title="6.3. 准确性"></a>6.3. 准确性</h2><p>所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。<br>这里提到了“预期”二字，那么我们就需要知道目标的组成规则。</p><h3 id="6-3-1-匹配固定电话"><a href="#6-3-1-匹配固定电话" class="headerlink" title="6.3.1. 匹配固定电话"></a>6.3.1. 匹配固定电话</h3><p>比如要匹配如下格式的固定电话号码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">055188888888</span><br><span class="line">0551-88888888</span><br><span class="line">(0551)88888888</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(0\d&#123;2,3&#125;-?|\(0\d&#123;2,3&#125;\))[1-9]\d&#123;6,7&#125;$/</span><br></pre></td></tr></table></figure><p>这就是一个平衡取舍问题，一般够用就行。</p><h3 id="6-3-2-匹配浮点数"><a href="#6-3-2-匹配浮点数" class="headerlink" title="6.3.2. 匹配浮点数"></a>6.3.2. 匹配浮点数</h3><p>要求匹配如下的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.23、+1.23、-1.23</span><br><span class="line">10、+10、-10</span><br><span class="line">.2、+.2、-.2</span><br></pre></td></tr></table></figure></p><p>上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：<br>/^[+-]?(\d+)?(.\d+)?$/<br>此正则看似没问题，但这个正则也会匹配空字符 “”。<br>因为目标字符串的形式关系不是要求每部分都是可选的。<br>/^[+-]?(\d+.\d+|\d+|.\d+)$/</p><h2 id="6-4-效率"><a href="#6-4-效率" class="headerlink" title="6.4. 效率"></a>6.4. 效率</h2><p>保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正<br>则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。<br>正则表达式的运行分为如下的阶段：</p><p>• 1. 编译；<br>• 2. 设定起始位置；<br>• 3. 尝试匹配；<br>• 4. 匹配失败的话，从下一位开始继续第 3 步；<br>• 5. 最终结果：匹配成功或失败</p><p>当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。<br>但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。</p><h3 id="6-4-1-使用具体型字符组来代替通配符，来消除回溯"><a href="#6-4-1-使用具体型字符组来代替通配符，来消除回溯" class="headerlink" title="6.4.1. 使用具体型字符组来代替通配符，来消除回溯"></a>6.4.1. 使用具体型字符组来代替通配符，来消除回溯</h3><p>而在第三阶段，最大的问题就是回溯。<br>因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。</p><h3 id="6-4-2-使用非捕获型分组"><a href="#6-4-2-使用非捕获型分组" class="headerlink" title="6.4.2. 使用非捕获型分组"></a>6.4.2. 使用非捕获型分组</h3><p>因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。<br>当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。</p><h3 id="6-4-3-独立出确定字符"><a href="#6-4-3-独立出确定字符" class="headerlink" title="6.4.3. 独立出确定字符"></a>6.4.3. 独立出确定字符</h3><p>例如，/a+/ 可以修改成 /aa*/。</p><h3 id="6-4-4-提取分支公共部分"><a href="#6-4-4-提取分支公共部分" class="headerlink" title="6.4.4. 提取分支公共部分"></a>6.4.4. 提取分支公共部分</h3><p>比如，<code>/^abc|^def/</code> 修改成 <code>/^(?:abc|def)/</code>。<br>又比如， /this|that/修改成 /th(?:is|at)/。<br>这样做，可以减少匹配过程中可消除的重复。</p><h3 id="6-4-5-减少分支的数量，缩小它们的范围"><a href="#6-4-5-减少分支的数量，缩小它们的范围" class="headerlink" title="6.4.5. 减少分支的数量，缩小它们的范围"></a>6.4.5. 减少分支的数量，缩小它们的范围</h3><p>/red|read/ 可以修改成 /rea?d/。<br>此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。</p><h1 id="7-第七章-正则表达式编程"><a href="#7-第七章-正则表达式编程" class="headerlink" title="7. 第七章 正则表达式编程"></a>7. 第七章 正则表达式编程</h1><h2 id="7-1-正则表达式的四种操作"><a href="#7-1-正则表达式的四种操作" class="headerlink" title="7.1. 正则表达式的四种操作"></a>7.1. 正则表达式的四种操作</h2><p>正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。<br>有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。</p><h3 id="7-1-1-验证"><a href="#7-1-1-验证" class="headerlink" title="7.1.1. 验证"></a>7.1.1. 验证</h3><p>比如，判断一个字符串中是否有数字。<br>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!~string.search(regex) );</span><br><span class="line">// ~0 === -1</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><p>使用 match：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!string.match(regex) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>使用 exec：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!regex.exec(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>其中，最常用的是 test。</p><h3 id="7-1-2-切分"><a href="#7-1-2-切分" class="headerlink" title="7.1.2. 切分"></a>7.1.2. 切分</h3><p>匹配上了，我们就可以进行一些操作，比如切分。<br>所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。</p><h3 id="7-1-3-提取"><a href="#7-1-3-提取" class="headerlink" title="7.1.3. 提取"></a>7.1.3. 提取</h3><p>虽然整体匹配上了，但有时需要提取部分匹配的数据。<br>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。<br>这里，还是以日期为例，提取出年月日。注意下面正则中的括号：<br>使用 match：<br>使用 exec：<br>使用 test：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">regex.test(string);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p><p>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">string.search(regex);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p><p>使用 replace：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">var date = [];</span><br><span class="line">string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">date.push(year, month, day);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(date);</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span><br></pre></td></tr></table></figure></p><p>其中，最常用的是 match。</p><h3 id="7-1-4-替换"><a href="#7-1-4-替换" class="headerlink" title="7.1.4. 替换"></a>7.1.4. 替换</h3><p>找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。</p><h2 id="7-2-相关-API-注意要点"><a href="#7-2-相关-API-注意要点" class="headerlink" title="7.2. 相关 API 注意要点"></a>7.2. 相关 API 注意要点</h2><p>从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String#search</span><br><span class="line">String#split</span><br><span class="line">String#match</span><br><span class="line">String#replace</span><br><span class="line">RegExp#test</span><br><span class="line">RegExp#exec</span><br></pre></td></tr></table></figure></p><h3 id="7-2-1-search-和-match-的参数问题"><a href="#7-2-1-search-和-match-的参数问题" class="headerlink" title="7.2.1. search 和 match 的参数问题"></a>7.2.1. search 和 match 的参数问题</h3><p>我们知道字符串实例的那 4 个方法参数都支持正则和字符串。<br>但 search 和 match，会把字符串转换为正则的。<br>replace和split不会。</p><h3 id="7-2-2-match-返回结果的格式问题"><a href="#7-2-2-match-返回结果的格式问题" class="headerlink" title="7.2.2. match 返回结果的格式问题"></a>7.2.2. match 返回结果的格式问题</h3><p>match 返回结果的格式，与正则对象是否有修饰符 g 有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017.06.27&quot;;</span><br><span class="line">var regex1 = /\b(\d+)\b/;</span><br><span class="line">var regex2 = /\b(\d+)\b/g;</span><br><span class="line">console.log( string.match(regex1) );</span><br><span class="line">console.log( string.match(regex2) );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;]</span><br></pre></td></tr></table></figure></p><p>没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然<br>后是整体匹配的第一个下标，最后是输入的目标字符串。<br>有 g，返回的是所有匹配的内容。<br>当没有匹配时，不管有无 g，都返回 null。</p><h3 id="7-2-3-exec-比-match-更强大"><a href="#7-2-3-exec-比-match-更强大" class="headerlink" title="7.2.3. exec 比 match 更强大"></a>7.2.3. exec 比 match 更强大</h3><p>当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。<br>而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配：<br>其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。<br>比如第一次匹配了 “2017”，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配<br>的位置是 4。<br>从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环：</p><h3 id="7-2-4-修饰符-g，对-exex-和-test-的影响"><a href="#7-2-4-修饰符-g，对-exex-和-test-的影响" class="headerlink" title="7.2.4. 修饰符 g，对 exex 和 test 的影响"></a>7.2.4. 修饰符 g，对 exex 和 test 的影响</h3><p>上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。<br><strong>字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。</strong><br>而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。</p><h3 id="7-2-5-test-整体匹配时需要使用-和"><a href="#7-2-5-test-整体匹配时需要使用-和" class="headerlink" title="7.2.5. test 整体匹配时需要使用 ^ 和 $"></a>7.2.5. test 整体匹配时需要使用 ^ 和 $</h3><p>这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。<br>如果，要整体匹配，正则前后需要添加开头和结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log( /123/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">console.log( /^123$/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( /^123$/.test(&quot;123&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-2-6-split-相关注意事项"><a href="#7-2-6-split-相关注意事项" class="headerlink" title="7.2.6. split 相关注意事项"></a>7.2.6. split 相关注意事项</h3><p>split 方法看起来不起眼，但要注意的地方有两个的。<br>第一，它可以有第二个参数，表示结果数组的最大长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/,/, 2) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;css&quot;]</span><br></pre></td></tr></table></figure></p><p>第二，正则使用分组时，结果数组中是包含分隔符的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/(,)/) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="7-2-7-replace-是很强大的"><a href="#7-2-7-replace-是很强大的" class="headerlink" title="7.2.7. replace 是很强大的"></a>7.2.7. replace 是很强大的</h3><p>《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。<br>因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。<br>总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。<br>当第二个参数是字符串时，如下的字符有特殊的含义：</p><p><pre><br>属性 描述<br>$1,$2,…,$99 匹配第 1-99 个 分组里捕获的文本<br>$&amp; 匹配到的子串文本<br>$` 匹配到的子串的左边文本<br>$’ 匹配到的子串的右边文本<br>$$ 美元符号<br>记忆中语言精粹中有列举更多。<br></pre><br>再例如，把 “2+3=5”，变成 “2+3=2+3=5=5”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;2+3=2+3=5=5</span><br></pre></td></tr></table></figure></p><p>我们对最后这个进行一下说明。要把 “2+3=5”，变成 “2+3=2+3=5=5”，其实就是想办法把 = 替换成<br>=2+3=5=，其中，$&amp; 匹配的是 =， $<code>匹配的是 2+3，$&#39; 匹配的是 5。因此使用 &quot;$&amp;$</code>$&amp;$’$&amp;” 便达成了<br>目的。<br>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;1234 2345 3456&quot;.replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123;</span><br><span class="line">console.log([match, $1, $2, index, input]);</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;]</span><br></pre></td></tr></table></figure></p><p>此时我们可以看到 replace 拿到的信息，并不比 exec 少。</p><h3 id="7-2-8-使用构造函数需要注意的问题"><a href="#7-2-8-使用构造函数需要注意的问题" class="headerlink" title="7.2.8. 使用构造函数需要注意的问题"></a>7.2.8. 使用构造函数需要注意的问题</h3><p>一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 <code>\</code>。</p><h3 id="7-2-9-修饰符"><a href="#7-2-9-修饰符" class="headerlink" title="7.2.9. 修饰符"></a>7.2.9. 修饰符</h3><p><code>ES5</code> 中修饰符，共 3 个：g,i,m<br>当然正则对象也有相应的只读属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\w/img;</span><br><span class="line">console.log( regex.global );</span><br><span class="line">console.log( regex.ignoreCase );</span><br><span class="line">console.log( regex.multiline );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-2-10-source-属性"><a href="#7-2-10-source-属性" class="headerlink" title="7.2.10. source 属性"></a>7.2.10. source 属性</h3><p>正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source<br>属性。<br>它什么时候有用呢？<br>比如，<strong>在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var className = &quot;high&quot;;</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">console.log( regex.source )</span><br><span class="line">// =&gt; (^|\s)high(\s|$) 即字符串&quot;(^|\\s)high(\\s|$)&quot;</span><br></pre></td></tr></table></figure></p><h3 id="7-2-11-构造函数属性"><a href="#7-2-11-构造函数属性" class="headerlink" title="7.2.11. 构造函数属性"></a>7.2.11. 构造函数属性</h3><p>构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的<br>属性（有兼容性问题）：</p><p><pre><br>静态属性 描述 简写形式<br>RegExp.input 最近一次目标字符串 RegExp[“$_”]<br>RegExp.lastMatch 最近一次匹配的文本 RegExp[“$&amp;”]<br>RegExp.lastParen 最近一次捕获的文本 RegExp[“$+”]<br>RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”]<br>RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[“$’”]<br></pre></p><h2 id="7-3-真实案例"><a href="#7-3-真实案例" class="headerlink" title="7.3. 真实案例"></a>7.3. 真实案例</h2><h3 id="7-3-1-使用构造函数生成正则表达式"><a href="#7-3-1-使用构造函数生成正则表达式" class="headerlink" title="7.3.1. 使用构造函数生成正则表达式"></a>7.3.1. 使用构造函数生成正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3333&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function getElementsByClassName (className) &#123;</span><br><span class="line">var elements = document.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var i = 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">var element = elements[i];</span><br><span class="line">if (regex.test(element.className)) &#123;</span><br><span class="line">result.push(element)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">var highs = getElementsByClassName(&apos;high&apos;);</span><br><span class="line">highs.forEach(function (item) &#123;</span><br><span class="line">item.style.color = &apos;red&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-使用字符串保存数据"><a href="#7-3-2-使用字符串保存数据" class="headerlink" title="7.3.2. 使用字符串保存数据"></a>7.3.2. 使用字符串保存数据</h3><p>一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。<br>使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var utils = &#123;&#125;;</span><br><span class="line">&quot;Boolean|Number|String|Function|Array|Date|RegExp|Object|Error&quot;.split(&quot;|&quot;).forEach(fun</span><br><span class="line">ction (item) &#123;</span><br><span class="line">utils[&quot;is&quot; + item] = function (obj) &#123;</span><br><span class="line">return &#123;&#125;.toString.call(obj) == &quot;[object &quot; + item + &quot;]&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log( utils.isArray([1, 2, 3]) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-3-3-if-语句中使用正则替代-amp-amp"><a href="#7-3-3-if-语句中使用正则替代-amp-amp" class="headerlink" title="7.3.3. if 语句中使用正则替代 &amp;&amp;"></a>7.3.3. if 语句中使用正则替代 &amp;&amp;</h3><p>比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var readyRE = /complete|loaded|interactive/;</span><br><span class="line">function ready (callback) &#123;</span><br><span class="line">if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">document.addEventListener(</span><br><span class="line">&apos;DOMContentLoaded&apos;,</span><br><span class="line">function () &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;,</span><br><span class="line">false</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ready(function () &#123;</span><br><span class="line">alert(&quot;加载完毕！&quot;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="7-3-4-使用强大的-replace"><a href="#7-3-4-使用强大的-replace" class="headerlink" title="7.3.4. 使用强大的 replace"></a>7.3.4. 使用强大的 replace</h3><p>因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。<br>这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何<br>东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function compress (source) &#123;</span><br><span class="line">var keys = &#123;&#125;;</span><br><span class="line">source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123;</span><br><span class="line">keys[key] = (keys[key] ? keys[key] + &apos;,&apos; : &apos;&apos;) + value;</span><br><span class="line">&#125;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var key in keys) &#123;</span><br><span class="line">result.push(key + &apos;=&apos; + keys[key]);</span><br><span class="line">&#125;</span><br><span class="line">return result.join(&apos;&amp;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;) );</span><br><span class="line">// =&gt; &quot;a=1,3&amp;b=2,4&quot;</span><br></pre></td></tr></table></figure></p><p>完。<br>84/89</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jex.im/regulex/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则可视化工具&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://regexper.com/#jsah&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>github使用小技巧</title>
    <link href="https://lxchuan12.github.io/2017/09/21/20170921-github%20tips/"/>
    <id>https://lxchuan12.github.io/2017/09/21/20170921-github tips/</id>
    <published>2017-09-21T15:15:52.000Z</published>
    <updated>2017-09-21T15:44:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>大多数开发者都有github账号，但github这些日常小技巧估计不知道。<br>1、<a href="https://github.com/explore/subscribe" target="_blank" rel="noopener">subscribe订阅github周报，每周会把你关注的开发语言和关注的人的动态等发邮件给你：</a><br><a href="https://github.com/trending" target="_blank" rel="noopener">每天github的热点</a><br>2、快捷键：在github某个项目面板（页面），按shift+?，可以看到所有支持的快捷键。<br>其中常用的主要有。</p><blockquote><p>T，搜索文件<br>S:定位到搜索输入框<br>GC:跳转到code面板<br>GI:跳转到issue面板<br>GP:跳转到 pull request面板<br>GW:跳转到 Wiki<br>搜索issue和pull request时可以使用过滤器。比如：is:open<br>回答输入时，可以用#号来匹配相应的issue.<br>3、Code Line<br>可以标注一些代码。按住shift,选择行号。对应的代码就高亮了。对应链接加上了hash#L1-L21<br>4、<a href="https://github.com/buunguyen/octotree" target="_blank" rel="noopener">octotree chrome插件github</a>可以像编辑器目录文件形式。<br><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="noopener">octotree chrome插件地址</a><br>如果翻墙苦难，可以直接下载dist目录下chrome.crx，拖拽到chrome浏览器插件即可安装。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数开发者都有github账号，但github这些日常小技巧估计不知道。&lt;br&gt;1、&lt;a href=&quot;https://github.com/explore/subscribe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;subscribe订阅githu
      
    
    </summary>
    
      <category term="github" scheme="https://lxchuan12.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://lxchuan12.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象所有API解析</title>
    <link href="https://lxchuan12.github.io/2017/08/17/20170817-Object%20API/"/>
    <id>https://lxchuan12.github.io/2017/08/17/20170817-Object API/</id>
    <published>2017-08-17T15:51:52.000Z</published>
    <updated>2018-06-12T14:31:58.615Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000010753942" target="_blank" rel="noopener">首发于segmentfault:JavaScript 对象所有API解析</a></p><blockquote><p>之前看到<a href="http://louiszhai.github.io/2017/04/28/array/" target="_blank" rel="noopener">【深度长文】JavaScript数组所有API全解密</a>和<a href="http://louiszhai.github.io/2016/01/12/js.String/" target="_blank" rel="noopener">JavaScript字符串所有API全解密</a>这两篇高质量的文章。发现没写对象API解析（估计是博主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。</p></blockquote><p>创建对象的两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">var o = &#123;&#125;; // 推荐</span><br></pre></td></tr></table></figure></p><p>该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object(&apos;something&apos;);</span><br><span class="line">o.constructor; // ƒ String() &#123; [native code] &#125;</span><br><span class="line">var n = new Object(123);</span><br><span class="line">n.constructor; // ƒ Number() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、Object构造器的成员"><a href="#一、Object构造器的成员" class="headerlink" title="一、Object构造器的成员"></a>一、Object构造器的成员</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>该属性是所有对象的原型（包括 <code>Object</code>对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;xuanyuan&apos;);</span><br><span class="line">Object.prototype.custom = 1;</span><br><span class="line">console.log(s.custom); // 1</span><br></pre></td></tr></table></figure></p><h2 id="二、Object-prototype-的成员"><a href="#二、Object-prototype-的成员" class="headerlink" title="二、Object.prototype 的成员"></a>二、Object.prototype 的成员</h2><h3 id="Object-prototype-constructor"><a href="#Object-prototype-constructor" class="headerlink" title="Object.prototype.constructor"></a>Object.prototype.constructor</h3><p>该属性指向用来构造该函数对象的构造器，在这里为<code>Object()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.constructor === Object; // true</span><br><span class="line">var o = new Object();</span><br><span class="line">o.constructor === Object; // true</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-toString-radix"><a href="#Object-prototype-toString-radix" class="headerlink" title="Object.prototype.toString(radix)"></a>Object.prototype.toString(radix)</h3><p>该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数<code>radix</code>，该参数<code>radix</code>，该参数的默认值为10。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop:1&#125;;</span><br><span class="line">o.toString(); // &apos;[object object]&apos;</span><br><span class="line">var n = new Number(255);</span><br><span class="line">n.toString(); // &apos;255&apos;</span><br><span class="line">n.toString(16); // &apos;ff&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p>该方法的作用与<code>toString()</code>基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如<code>Date()</code>,<code>Number()</code>,<code>Array()</code>,它们的值都会以本地化的形式输出。当然，对于包括<code>Object()</code>在内的其他大多数对象来说，该方法与<code>toString()</code>是基本相同的。<br>在浏览器环境下，可以通过<code>BOM</code>对象<code>Navigator</code>的<code>language</code>属性（在<code>IE</code>中则是<code>userLanguage</code>）来了解当前所使用的语言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.language; //&apos;en-US&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p>该方法返回的是用基本类型所表示的<code>this</code>值，如果它可以用基本类型表示的话。如果<code>Number</code>对象返回的是它的基本数值，而<code>Date</code>对象返回的是一个时间戳（<code>timestamp</code>）。如果无法用基本数据类型表示，该方法会返回<code>this</code>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Object</span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">typeof o.valueOf(); // &apos;object&apos;</span><br><span class="line">o.valueOf() === o; // true</span><br><span class="line">// Number</span><br><span class="line">var n = new Number(101);</span><br><span class="line">typeof n; // &apos;object&apos;</span><br><span class="line">typeof n.vauleOf; // &apos;function&apos;</span><br><span class="line">typeof n.valueOf(); // &apos;number&apos;</span><br><span class="line">n.valueOf() === n; // false</span><br><span class="line">// Date</span><br><span class="line">var d = new Date();</span><br><span class="line">typeof d.valueOf(); // &apos;number&apos;</span><br><span class="line">d.valueOf(); // 1503146772355</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-hasOwnProperty-prop"><a href="#Object-prototype-hasOwnProperty-prop" class="headerlink" title="Object.prototype.hasOwnProperty(prop)"></a>Object.prototype.hasOwnProperty(prop)</h3><p>该方法仅在目标属性为对象自身属性时返回<code>true</code>,而当该属性是从原型链中继承而来或根本不存在时，返回<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop:1&#125;;</span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;); // true</span><br><span class="line">o.hasOwnProperty(&apos;toString&apos;); // false</span><br><span class="line">o.hasOwnProperty(&apos;formString&apos;); // false</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-isPrototypeOf-obj"><a href="#Object-prototype-isPrototypeOf-obj" class="headerlink" title="Object.prototype.isPrototypeOf(obj)"></a>Object.prototype.isPrototypeOf(obj)</h3><p>如果目标对象是当前对象的原型，该方法就会返回<code>true</code>，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;&apos;);</span><br><span class="line">Object.prototype.isPrototypeOf(s); // true</span><br><span class="line">String.prototype.isPrototypeOf(s); // true</span><br><span class="line">Array.prototype.isPrototypeOf(s); // false</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-propertyIsEnumerable-prop"><a href="#Object-prototype-propertyIsEnumerable-prop" class="headerlink" title="Object.prototype.propertyIsEnumerable(prop)"></a>Object.prototype.propertyIsEnumerable(prop)</h3><p>如果目标属性能在<code>for in</code>循环中被显示出来，该方法就返回<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.propertyIsEnumerable(&apos;length&apos;); // false</span><br><span class="line">a.propertyIsEnumerable(0); // true</span><br></pre></td></tr></table></figure></p><h2 id="三、在ES5中附加的Object属性"><a href="#三、在ES5中附加的Object属性" class="headerlink" title="三、在ES5中附加的Object属性"></a>三、在<code>ES5</code>中附加的<code>Object</code>属性</h2><p>在<code>ES3</code>中，除了一些内置属性（如：<code>Math.PI</code>），对象的所有的属性在任何时候都可以被修改、插入、删除。在<code>ES5</code>中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。<code>ES5</code>中引入了<strong>属性描述符</strong>的概念，我们可以通过它对所定义的属性有更大的控制权。这些<strong>属性描述符</strong>（特性）包括：</p><blockquote><p><code>value</code>——当试图获取属性时所返回的值。<br><code>writable</code>——该属性是否可写。<br><code>enumerable</code>——该属性在<code>for in</code>循环中是否会被枚举<br><code>configurable</code>——该属性是否可被删除。<br><code>set()</code>——该属性的更新操作所调用的函数。<br><code>get()</code>——获取属性值时所调用的函数。<br>另外，<strong>数据描述符</strong>（其中属性为：<code>enumerable</code>，<code>configurable</code>，<code>value</code>，<code>writable</code>）与<strong>存取描述符</strong>（其中属性为<code>enumerable</code>，<code>configurable</code>，<code>set()</code>，<code>get()</code>）之间是有互斥关系的。在定义了<code>set()</code>和<code>get()</code>之后，描述符会认为存取操作已被 定义了，其中再定义<code>value</code>和<code>writable</code>会<strong>引起错误</strong>。<br>以下是<em>ES3</em>风格的属性定义方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.legs = 2;</span><br></pre></td></tr></table></figure></p></blockquote><p>以下是等价的ES5通过<strong>数据描述符</strong>定义属性的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其中， 除了value的默认值为<code>undefined</code>以外，其他的默认值都为<code>false</code>。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为<code>true</code>。<br>或者，我们也可以通过<code>ES5</code>的存储描述符来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</span><br><span class="line">    set:function(v) &#123;</span><br><span class="line">        return this.value = v;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function(v) &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br><span class="line">person.legs = 2;</span><br></pre></td></tr></table></figure></p><p>这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容<code>ES3</code>方面所做的考虑。例如，跟添加<code>Array.prototype</code>属性不一样，我们不能再旧版的浏览器中使用<code>shim</code>这一特性。<br>另外，我们还可以（通过定义<code>nonmalleable</code>属性），在具体行为中运用这些描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;heads&apos;, &#123;value: 1&#125;);</span><br><span class="line">person.heads = 0; // 0</span><br><span class="line">person.heads; // 1  (改不了)</span><br><span class="line">delete person.heads; // false</span><br><span class="line">person.heads // 1 (删不掉)</span><br></pre></td></tr></table></figure></p><h3 id="Object-defineProperty-obj-prop-descriptor-ES5"><a href="#Object-defineProperty-obj-prop-descriptor-ES5" class="headerlink" title="Object.defineProperty(obj, prop, descriptor) (ES5)"></a>Object.defineProperty(obj, prop, descriptor) (ES5)</h3><p>具体用法可参见上文，或者查看MDN。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN Object.defineProperty(obj, descriptor)</a></p><blockquote><p>Vue.js文档：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener"><strong>如何追踪变化</strong></a> 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote><h3 id="Object-defineProperties-obj-props-ES5"><a href="#Object-defineProperties-obj-props-ES5" class="headerlink" title="Object.defineProperties(obj, props) (ES5)"></a>Object.defineProperties(obj, props) (ES5)</h3><p>该方法的作用与<code>defineProperty()</code>基本相同，只不过它可以用来一次定义多个属性。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var glass = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    &apos;color&apos;: &#123;</span><br><span class="line">        value: &apos;transparent&apos;,</span><br><span class="line">        writable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;fullness&apos;: &#123;</span><br><span class="line">        value: &apos;half&apos;,</span><br><span class="line">        writable: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">glass.fullness; // &apos;half&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getPrototypeOf-obj-ES5"><a href="#Object-getPrototypeOf-obj-ES5" class="headerlink" title="Object.getPrototypeOf(obj) (ES5)"></a>Object.getPrototypeOf(obj) (ES5)</h3><p>之前在<code>ES3</code>中，我们往往需要通过<code>Object.prototype.isPrototypeOf()</code>去猜测某个给定的对象的原型是什么，如今在<code>ES5</code>中，我们可以直接询问改对象“你的原型是什么？”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf([]) === Array.prototype; // true</span><br><span class="line">Object.getPrototypeOf(Array.prototype) === Object.prototype; // true</span><br><span class="line">Object.getPrototypeOf(Object.prototype) === null; // true</span><br></pre></td></tr></table></figure></p><h3 id="Object-create-obj-descr-ES5"><a href="#Object-create-obj-descr-ES5" class="headerlink" title="Object.create(obj, descr) (ES5)"></a>Object.create(obj, descr) (ES5)</h3><p>该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;hi: &apos;Hello&apos;&#125;;</span><br><span class="line">var o = Object.create(parent, &#123;</span><br><span class="line">    prop: &#123;</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.hi; // &apos;Hello&apos;</span><br><span class="line">// 获得它的原型</span><br><span class="line">Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototype</span><br><span class="line">Object.getPrototypeOf(o); // &#123;hi: &quot;Hello&quot;&#125; // 说明o的原型是&#123;hi: &quot;Hello&quot;&#125;</span><br><span class="line">o.hasOwnProperty(&apos;hi&apos;); // false 说明hi是原型上的</span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;); // true 说明prop是原型上的自身上的属性。</span><br></pre></td></tr></table></figure></p><p>现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在<code>ES3</code>中可是做不到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o = Object.create(null);</span><br><span class="line">typeof o.toString(); // &apos;undefined&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertyDesciptor-obj-property-ES5"><a href="#Object-getOwnPropertyDesciptor-obj-property-ES5" class="headerlink" title="Object.getOwnPropertyDesciptor(obj, property) (ES5)"></a>Object.getOwnPropertyDesciptor(obj, property) (ES5)</h3><p>该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</span><br><span class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertyNames-obj-ES5"><a href="#Object-getOwnPropertyNames-obj-ES5" class="headerlink" title="Object.getOwnPropertyNames(obj) (ES5)"></a>Object.getOwnPropertyNames(obj) (ES5)</h3><p>该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用<code>Object.keys()</code>来单独返回可枚举的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(Object.prototype);</span><br><span class="line">// [&quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;]</span><br><span class="line">Object.keys(Object.prototype);</span><br><span class="line">// []</span><br><span class="line">Object.getOwnPropertyNames(Object);</span><br><span class="line">// [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;prototype&quot;, &quot;assign&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getOwnPropertyDescriptors&quot;, &quot;getOwnPropertyNames&quot;, &quot;getOwnPropertySymbols&quot;, &quot;is&quot;, &quot;preventExtensions&quot;, &quot;seal&quot;, &quot;create&quot;, &quot;defineProperties&quot;, &quot;defineProperty&quot;, &quot;freeze&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;isFrozen&quot;, &quot;isSealed&quot;, &quot;keys&quot;, &quot;entries&quot;, &quot;values&quot;]</span><br><span class="line">Object.keys(Object);</span><br><span class="line">// []</span><br></pre></td></tr></table></figure></p><h3 id="Object-preventExtensions-obj-ES5"><a href="#Object-preventExtensions-obj-ES5" class="headerlink" title="Object.preventExtensions(obj) (ES5)"></a>Object.preventExtensions(obj) (ES5)</h3><h3 id="Object-isExtensible-obj-ES5"><a href="#Object-isExtensible-obj-ES5" class="headerlink" title="Object.isExtensible(obj) (ES5)"></a>Object.isExtensible(obj) (ES5)</h3><p><code>preventExtensions()</code>方法用于禁止向某一对象添加更多属性，而<code>isExtensible()</code>方法则用于检查某对象是否还可以被添加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var deadline = &#123;&#125;;</span><br><span class="line">Object.isExtensible(deadline); // true</span><br><span class="line">deadline.date = &apos;yesterday&apos;; // &apos;yesterday&apos;</span><br><span class="line">Object.preventExtensions(deadline);</span><br><span class="line">Object.isExtensible(deadline); // false</span><br><span class="line">deadline.date = &apos;today&apos;;</span><br><span class="line">deadline.date; // &apos;today&apos;</span><br><span class="line">// 尽管向某个不可扩展的对象中添加属性不算是一个错误操作，但它没有任何作用。</span><br><span class="line">deadline.report = true;</span><br><span class="line">deadline.report; // undefined</span><br></pre></td></tr></table></figure></p><h3 id="Object-seal-obj-ES5"><a href="#Object-seal-obj-ES5" class="headerlink" title="Object.seal(obj) (ES5)"></a>Object.seal(obj) (ES5)</h3><h3 id="Object-isSeal-obj-ES5"><a href="#Object-isSeal-obj-ES5" class="headerlink" title="Object.isSeal(obj) (ES5)"></a>Object.isSeal(obj) (ES5)</h3><p><code>seal()</code>方法可以让一个对象密封，并返回被密封后的对象。<br><code>seal()</code>方法的作用与<code>preventExtensions()</code>基本相同，但除此之外，它还会将现有属性<br>设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用<code>defineProperty()</code>）重新配置这些属性，例如不能将一个可枚举的属性改成不可枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;legs:2&#125;;</span><br><span class="line">// person === Object.seal(person); // true</span><br><span class="line">Object.isSealed(person); // true</span><br><span class="line">Object.getOwnPropertyDescriptor(person, &apos;legs&apos;);</span><br><span class="line">// &#123;value: 2, writable: true, enumerable: true, configurable: false&#125;</span><br><span class="line">delete person.legs; // false (不可删除，不可配置)</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;,&#123;value:2&#125;);</span><br><span class="line">person.legs; // 2</span><br><span class="line">person.legs = 1;</span><br><span class="line">person.legs; // 1 (可写)</span><br><span class="line">Object.defineProperty(person, &quot;legs&quot;, &#123; get: function() &#123; return &quot;legs&quot;; &#125; &#125;);</span><br><span class="line">// 抛出TypeError异常</span><br></pre></td></tr></table></figure></p><h3 id="Object-freeze-obj-ES5"><a href="#Object-freeze-obj-ES5" class="headerlink" title="Object.freeze(obj) (ES5)"></a>Object.freeze(obj) (ES5)</h3><h3 id="Object-isFrozen-obj-ES5"><a href="#Object-isFrozen-obj-ES5" class="headerlink" title="Object.isFrozen(obj) (ES5)"></a>Object.isFrozen(obj) (ES5)</h3><p><code>freeze()</code>方法用于执行一切不受<code>seal()</code>方法限制的属性值变更。<code>Object.freeze()</code> 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var deadline = Object.freeze(&#123;date: &apos;yesterday&apos;&#125;);</span><br><span class="line">deadline.date = &apos;tomorrow&apos;;</span><br><span class="line">deadline.excuse = &apos;lame&apos;;</span><br><span class="line">deadline.date; // &apos;yesterday&apos;</span><br><span class="line">deadline.excuse; // undefined</span><br><span class="line">Object.isSealed(deadline); // true;</span><br><span class="line">Object.isFrozen(deadline); // true</span><br><span class="line">Object.getOwnPropertyDescriptor(deadline, &apos;date&apos;);</span><br><span class="line">// &#123;value: &quot;yesterday&quot;, writable: false, enumerable: true, configurable: false&#125; (不可配置，不可写)</span><br><span class="line">Object.keys(deadline); // [&apos;date&apos;] (可枚举)</span><br></pre></td></tr></table></figure></p><h3 id="Object-keys-obj-ES5"><a href="#Object-keys-obj-ES5" class="headerlink" title="Object.keys(obj) (ES5)"></a>Object.keys(obj) (ES5)</h3><p>该方法是一种特殊的<code>for-in</code>循环。它只返回当前对象的属性（不像<code>for-in</code>），而且这些属性也必须是可枚举的（这点和<code>Object.getOwnPropertyNames()</code>不同，不论是否可以枚举）。返回值是一个字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.customProto = 101;</span><br><span class="line">Object.getOwnPropertyNames(Object.prototype);</span><br><span class="line">// [..., &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;, &quot;customProto&quot;]</span><br><span class="line">Object.keys(Object.prototype); // [&apos;customProto&apos;]</span><br><span class="line">var o = &#123;own: 202&#125;;</span><br><span class="line">o.customProto; // 101</span><br><span class="line">Object.keys(o); // [&apos;own&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="四、在ES6中附加的Object属性"><a href="#四、在ES6中附加的Object属性" class="headerlink" title="四、在ES6中附加的Object属性"></a>四、在<code>ES6</code>中附加的<code>Object</code>属性</h3><h3 id="Object-is-value1-value2-ES6"><a href="#Object-is-value1-value2-ES6" class="headerlink" title="Object.is(value1, value2) (ES6)"></a>Object.is(value1, value2) (ES6)</h3><p>该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。<br>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，而是<code>NaN</code>等于自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.is(&apos;xuanyuan&apos;, &apos;xuanyuan&apos;); // true</span><br><span class="line">Object.is(&#123;&#125;,&#123;&#125;); // false</span><br><span class="line">Object.is(+0, -0); // false</span><br><span class="line">+0 === -0; // true</span><br><span class="line">Object.is(NaN, NaN); // true</span><br><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure></p><p><code>ES5</code>可以通过以下代码部署<code>Object.is</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</span><br><span class="line">    value: function() &#123;x, y&#125; &#123;</span><br><span class="line">        if (x === y) &#123;</span><br><span class="line">           // 针对+0不等于-0的情况</span><br><span class="line">           return x !== 0 || 1 / x === 1 / y;</span><br><span class="line">        &#125;</span><br><span class="line">        // 针对 NaN的情况</span><br><span class="line">        return x !== x &amp;&amp; y !== y;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Object-assign-target-…sources-ES6"><a href="#Object-assign-target-…sources-ES6" class="headerlink" title="Object.assign(target, …sources) (ES6)"></a>Object.assign(target, …sources) (ES6)</h3><p>该方法用来源对象（<code>source</code>）的所有可枚举的属性复制到目标对象（<code>target</code>）。它至少需要两个对象作为参数，第一个参数是目标对象<code>target</code>，后面的参数都是源对象（<code>source</code>）。只有一个参数不是对象，就会抛出<code>TypeError</code>错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;a: 1&#125;;</span><br><span class="line">var source1 = &#123;b: 2&#125;;</span><br><span class="line">var source2 = &#123;c: 3&#125;;</span><br><span class="line">obj = Object.assign(target, source1, source2);</span><br><span class="line">target; // &#123;a:1,b:2,c:3&#125;</span><br><span class="line">obj; // &#123;a:1,b:2,c:3&#125;</span><br><span class="line">target === obj; // true</span><br><span class="line">// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</span><br><span class="line">var source3 = &#123;a:2,b:3,c:4&#125;;</span><br><span class="line">Object.assign(target, source3);</span><br><span class="line">target; // &#123;a:2,b:3,c:4&#125;</span><br></pre></td></tr></table></figure></p><p><code>Object.assign</code>只复制自身属性，不可枚举的属性（<code>enumerable</code>为<code>false</code>）和继承的属性不会被复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;b: &apos;c&apos;&#125;, </span><br><span class="line">    Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123;</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: &apos;hello&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">// &#123;b: &apos;c&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>属性名为<code>Symbol</code>值的属性，也会被<code>Object.assign()</code>复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;a: &apos;b&apos;&#125;, &#123;[Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</span><br><span class="line">// &#123;a: &apos;b&apos;, Symbol(c): &apos;d&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>对于嵌套的对象，<code>Object.assign()</code>的处理方法是替换，而不是添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;a: &#123;b:&apos;c&apos;,d:&apos;e&apos;&#125;&#125;, &#123;a:&#123;b:&apos;hello&apos;&#125;&#125;);</span><br><span class="line">// &#123;a: &#123;b:&apos;hello&apos;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>对于数组，<code>Object.assign()</code>把数组视为属性名为0、1、2的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1,2,3], [4,5]);</span><br><span class="line">// [4,5,3]</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertySymbols-obj-ES6"><a href="#Object-getOwnPropertySymbols-obj-ES6" class="headerlink" title="Object.getOwnPropertySymbols(obj) (ES6)"></a>Object.getOwnPropertySymbols(obj) (ES6)</h3><p>该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 <code>symbol</code> 属性键。<br>该方法和 <code>Object.getOwnPropertyNames()</code> 类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertySymbols(&#123;a: &apos;b&apos;, [Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</span><br><span class="line">// [Symbol(c)]</span><br></pre></td></tr></table></figure></p><h3 id="Object-setPrototypeOf-obj-prototype-ES6"><a href="#Object-setPrototypeOf-obj-prototype-ES6" class="headerlink" title="Object.setPrototypeOf(obj, prototype) (ES6)"></a>Object.setPrototypeOf(obj, prototype) (ES6)</h3><p>该方法设置一个指定的对象的原型 ( 即, 内部<code>[[Prototype]]</code>属性）到另一个对象或  <code>null</code>。<br><code>__proto__</code>属性用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括<code>IE11</code>）都部署了这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ES6写法</span><br><span class="line">var obj = &#123;</span><br><span class="line">    method: function()&#123;</span><br><span class="line">        // code ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// obj.__proto__ = someOtherObj;</span><br><span class="line">// ES5写法</span><br><span class="line">var obj = Object.create(someOtherObj);</span><br><span class="line">obj.method = function()&#123;</span><br><span class="line">    // code ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>该属性没有写入<code>ES6</code>的正文，而是写入了附录。<code>__proto__</code>前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。而是使用<code>Object.setPrototypeOf()</code>（写操作），<code>Object.getPrototypeOf()</code>（读操作），或<code>Object.create()</code>（生成操作）代替。<br>在实现上，<code>__proto__</code>调用的<code>Object.prototype.__proto__</code>。<br><code>Object.setPrototypeOf()</code>方法的作用与<code>__proto__</code>作用相同，用于设置一个对象的<code>prototype</code>对象。它是<code>ES6</code>正式推荐的设置原型对象的方法。</p><h2 id="五、在ES8中附加的Object属性"><a href="#五、在ES8中附加的Object属性" class="headerlink" title="五、在ES8中附加的Object属性"></a>五、在<code>ES8</code>中附加的<code>Object</code>属性</h2><h3 id="Object-getOwnPropertyDescriptors-obj-ES8"><a href="#Object-getOwnPropertyDescriptors-obj-ES8" class="headerlink" title="Object.getOwnPropertyDescriptors(obj) (ES8)"></a>Object.getOwnPropertyDescriptors(obj) (ES8)</h3><p>该方法基本与<code>Object.getOwnPropertyDescriptor(obj, property)</code>用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</span><br><span class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</span><br><span class="line">Object.getOwnPropertyDescriptors(Object.prototype); // 可以自行在浏览器控制台查看效果。</span><br></pre></td></tr></table></figure></p><h3 id="Object-values-obj-ES8"><a href="#Object-values-obj-ES8" class="headerlink" title="Object.values(obj) (ES8)"></a>Object.values(obj) (ES8)</h3><p><code>Object.values()</code> 方法与<code>Object.keys</code>类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用<code>for...in</code>循环的顺序相同 ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">Object.values(obj); // [1,2,3]</span><br></pre></td></tr></table></figure></p><h3 id="Object-entries-obj-ES8"><a href="#Object-entries-obj-ES8" class="headerlink" title="Object.entries(obj) (ES8)"></a>Object.entries(obj) (ES8)</h3><p><code>Object.entries()</code> 方法返回一个给定对象自己的可枚举属性<code>[key，value]</code>对的数组，数组中键值对的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致（区别在于一个<code>for-in</code>循环也枚举原型链中的属性）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">Object.values(obj); // [1,2,3]</span><br><span class="line">Object.entries(obj); // [[&apos;a&apos;,1],[&apos;b&apos;,2],[&apos;c&apos;,3]]</span><br></pre></td></tr></table></figure></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<strong>轩辕Rowboat</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>您可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有<code>Object.prototype.toString()</code>，<code>Object.prototype.hasOwnProperty()</code>， <code>Object.getPrototypeOf(obj)</code>，<code>Object.create()</code>，<code>Object.defineProperty</code>，<code>Object.keys(obj)</code>，<code>Object.assign()</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN Object API</a><br><a href="https://book.douban.com/subject/26302623/" target="_blank" rel="noopener">JavaScript面向对象编程指南（第2版）（豆瓣读书链接）</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰 ES6标准入门2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010753942&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;首发于segmentfault:JavaScript 对象所有API解析&lt;/a&gt;&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 语言精粹 修订版》 读书笔记</title>
    <link href="https://lxchuan12.github.io/2017/07/23/20170723-JavaScript%20essence%20of%20reading%20notes/"/>
    <id>https://lxchuan12.github.io/2017/07/23/20170723-JavaScript essence of reading notes/</id>
    <published>2017-07-23T14:23:52.000Z</published>
    <updated>2018-06-12T14:31:49.677Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000010313101" target="_blank" rel="noopener">首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记</a></p><blockquote><p>之前看到这篇文章，<a href="https://zhuanlan.zhihu.com/p/23265155?refer=dreawer" target="_blank" rel="noopener">前端网老姚浅谈：怎么学JavaScript？</a>，说到怎么学习JavaScript，那就是<strong>看书、分析源码。</strong><br><strong>10本书读2遍的好处，应该大于一本书读20遍。</strong><br><strong>看书主动学习，看视频是被动学习。</strong><br><strong>看书和分析源码的时机</strong>。但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来学习，那&gt;肯定是必须的，工作本身就是一个学习的过程。<br><strong>怎么把一本书看完呢？</strong>很简单，敲。文字加代码都敲。<br>比较认同老姚的说法。去年毕业到现在，我也算是工作一年了，是时候看书查缺补漏了。</p></blockquote><p>于是我就先把这本薄的经典书《JavaScript语言精粹 修订版》<a href="https://book.douban.com/subject/11874748/" target="_blank" rel="noopener">豆瓣读书本书简介</a>（总共10章，除去附录，才100页），读完并记录了一些笔记。基本算是摘抄书本的，自己联想到了一些知识和资料也扩展了一下。总体写下来近一万字。读书笔记还可以分享给别人看。回顾时，书不在身边还可以看看自己的笔记。想想这类经典书记一遍动手敲一遍也是很值得的。不过这读书笔记中可能会有一些错别字，阅读时如果发现欢迎指正。</p><h3 id="第1章-精华"><a href="#第1章-精华" class="headerlink" title="第1章 精华"></a>第1章 精华</h3><p>大多数语言都有精华和糟粕。<code>JavaScript</code>令人诡异的事情是，在对这门语言没有的太多了解，甚至对编程都没有太多了解的情况下，你也能用它来完成工作。<br>看到这里不禁想起：</p><blockquote><p>张鑫旭大牛在<a href="http://www.zhangxinxu.com/wordpress/2017/06/ten-question-about-frontend-zhihu/" target="_blank" rel="noopener">《我对知乎前端相关问题的十问十答》</a><br>非计算机专业背景学习JS要点有这一条：<br>所有继承和原型相关内容跳过，注意，是跳过，不要看！没有这些JS一样可以活得很好，你的日常工作一样玩得飞起，当然，你没忍住看了相关知识也没关系，因为你会发现自己看不懂的；</p></blockquote><p><code>JavaScript</code>的函数是（主要）基于<strong>词法作用域</strong>的顶级对象。</p><blockquote><p>译注：<code>JavaScript</code>中的函数是根据词法来划分作用域的，而不是动态划分作用域的。具体内容参见《<code>JavaScript</code>权威指南》中译第5版相关章节“8.8.1 词法作用域”。<br>JavaScript有非常强大的对象字面量表示法。这种表示法是JSON的灵感来源。<br>原型继承是JavaScript中一个有争议的特性。</p></blockquote><p>《<code>ECMAScript</code>编程语言》第3版定义了<code>JavaScript</code>的标准。<br><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="noopener">ES3标准</a><br><strong>扩展：</strong><a href="http://yanhaijing.com/es5/ECMAScript%E8%A7%84%E8%8C%83-%E7%AC%AC%E4%B8%89%E7%89%88_%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">颜海镜大牛整理的ES3中文版</a><br><a href="http://yanhaijing.com/es5/#about" target="_blank" rel="noopener">颜海镜大牛整理的ES5中文版</a><br><a href="https://www.w3.org/html/ig/zh/wiki/ES5#.E7.A8.8B.E5.BA.8F" target="_blank" rel="noopener">W3c ES5中文版</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰大牛的书籍《ES6标准入门2》</a><br>更多内容可参见这篇文章：<a href="https://zhuanlan.zhihu.com/p/27537439" target="_blank" rel="noopener">ECMAScript 2018 标准导读</a></p><p>一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function(name, func) &#123;</span><br><span class="line">  this.prototype[name] = func;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>书中贯彻始终都会用到这个<code>method</code>方案，作者将会在第4章解释它。</p><h3 id="第2章-语法"><a href="#第2章-语法" class="headerlink" title="第2章 语法"></a>第2章 语法</h3><p>本章主要用铁路图（语法图）表示语法。<br>主要有：空白、标识符、数字、字符串、语句、表达式、字面量、函数。<br><code>typeof</code> 运算符产生的值有<code>&#39;number&#39;</code>, <code>&#39;string&#39;</code>,<code>&#39;boolean&#39;</code>,<code>&#39;undefined&#39;</code>,<code>&#39;function&#39;</code>,<code>&#39;object&#39;</code>。如果运算数是一个数组或者是<code>null</code>,那么结果是<code>&#39;object&#39;</code>,这其实是不对的。</p><h3 id="第3章-对象"><a href="#第3章-对象" class="headerlink" title="第3章 对象"></a>第3章 对象</h3><p><code>JavaScript</code>简单数据类型包括数字、字符串、布尔值，<code>null</code>值和<code>undefined</code>值。其他所有值都是对象。<br>数组、字符串和布尔值“貌似”对象，因为它们拥有方法（包装对象），但它们是不可变的。<br>对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的所有字符串，属性值可以是除了<code>undefined</code>值之外的任何值。</p><p><code>JavaScript</code>包含一种原型链的特性，允许对象继承到另一个对象的属性。正确地使用它能减少对象初始化时的消耗的时间和内存。<br><strong>检索</strong><br><code>.</code>,<code>[]</code>两种检索方式，推荐点<code>.</code>表示法。<br>尝试重<code>undefined</code>的成员属性中取值将会导致<code>TypeError</code>异常，这时可以通过<code>&amp;&amp;</code>来避免错误。<br><strong>更新</strong><br>如果属性名已经存在对象里。那么属性的值会被替换。如果之前没有拥有那个属性名，那么该属性将被扩充到对象中。<br><strong>引用</strong><br>对象通过引用来传递。它们永远不会被复制。<br><strong>原型</strong><br>所有通过对象字面量创建的对象都链接到<code>Object.prototype</code>。<br>创建新对象时，可以选择某个对象作为它的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.create !== &apos;function&apos;) &#123;</span><br><span class="line">  Object.create = function(o) &#123;</span><br><span class="line">    var F = function () &#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原型连接只有在检索值的时候才被用到。如果尝试去获取对象的某个属性值，但对象没有此属性名，那么<code>JavaScript</code>会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到终点<code>Object.prototype</code>。如果想要的属性完全不存在原型链中，那么结果就是 <code>undefined</code>值。这个过程称为<strong>委托</strong>。<br>原型关系是一种动态的关系。<br><strong>反射</strong><br>原型链上的所有属性都会产生值。有两种方案可以处理掉对象上不需要的属性。<br>①程序检查时丢弃值为函数的属性。但有可能有些值确实是函数，所以该方法不可靠。<br>②使用<code>hasOwnProperty</code>方法，如果是对象拥有独有的属性，则返回<code>true</code>。该方法不会检查原型链。<br><strong>枚举</strong><br>① <code>for in</code>可以遍历一个对象中所有的属性名。但包含函数和一些不关心的原型中属性。而且顺序不确定，可以用 <code>hasOwnProperty</code>方法和<code>typeof</code>排除函数。<br>②<code>for</code> 循环不会出现<code>for in</code>那些情况。<br><strong>删除</strong><br>delete运算符可以用来删除对象的属性。<br><strong>减少全局变量的污染</strong><br>可以把全局性的资源纳入一个名称空间之下。这样做能减少冲突。</p><h3 id="第4章-函数"><a href="#第4章-函数" class="headerlink" title="第4章 函数"></a>第4章 函数</h3><p>函数用于①代码复用②信息隐藏③组合调用。一般来说，所谓编程，就是将一组需求分节成一组函数与数据结构的技能。<br><code>JavaScript</code>的函数就是对象。<br>函数对象连接到<code>Function.prototype</code>(该原型对象本身连接到<code>Object.prototype</code>)。<br>每个函数在创建时会附加两个隐藏属性，函数的上下文和实现函数行为的代码。<br>每个函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值为该函数的对象。<br><strong>函数字面量</strong><br>函数字面量包括4个部分。①保留字<code>function</code>②函数名，可以省略，③一组参数④一组语句。<br>函数字面量可以出现在任何允许表达式出现的地方。一个内部函数除了可以访问自己的参数和变量，同时也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个连接到外部上下文的连接。这被称为<strong>闭包</strong>。<br><strong>调用</strong><br>除了声明时定义的形式参数，每一个函数还接收两个附加的参数：<code>this</code>和<code>argument</code>。在<code>JavaScript</code>中一共有四种调用模式。①方法调用模式，②函数调用模式③构造器调用模式④<code>apply</code>调用模式。</p><p>（<code>this</code>指向问题一直困扰很多人。我一般是这样记的，谁调用<code>this</code>就指向谁。）</p><p><strong>方法调用模式</strong><br>对象的方法执行,<code>this</code>指向该对象。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  value: 0,</span><br><span class="line">  showValue: function() &#123;</span><br><span class="line">    console.log(&apos;value:&apos;, this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showValue();  // value: 0</span><br></pre></td></tr></table></figure></p><p><strong>函数调用模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var add = function(a,b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(3,4);  //7</span><br><span class="line">window.add(3,4);  //7</span><br><span class="line">// 这种this被绑定到全局对象（window）。</span><br><span class="line">// 可以理解是window.add(3,4);</span><br></pre></td></tr></table></figure></p><p>有种简单的办法就是<code>var that = this;</code>把<code>this</code>存储下。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  value: 0,</span><br><span class="line">  age: 20,</span><br><span class="line">  showValue: function() &#123;</span><br><span class="line">    console.log(&apos;value:&apos;,this.value);</span><br><span class="line">    var  that = this;</span><br><span class="line">    var showAge = function() &#123;</span><br><span class="line">        // window上没有age，所以是undefined</span><br><span class="line">        console.log(&apos;这里的this是window ---age:&apos;, this.age);  // undefined</span><br><span class="line">        console.log(&apos;age:&apos;, that.age);  // 20</span><br><span class="line">     &#125;</span><br><span class="line">     showAge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showValue();  // 0， undefined，</span><br></pre></td></tr></table></figure></p><p><strong>构造器调用模式</strong><br><code>JavaScript</code>是一门基于原型继承的语言。<br>如果在一个函数前面带上<code>new</code> 来调用。那么背地利将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时this会被绑定到那个新对象上。<br><code>new</code> 前缀也会改变<code>return</code> 语句的行为。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Quo = function (string) &#123;</span><br><span class="line">  this.status = string;</span><br><span class="line">&#125;</span><br><span class="line">Quo.prototype.get_status = function () &#123;</span><br><span class="line">  return this.status; </span><br><span class="line">&#125;</span><br><span class="line">var myQuo = new Quo(&apos;confused&apos;); // &apos;confused&apos;</span><br></pre></td></tr></table></figure></p><p>一个函数，如果创建的目的就是希望结合<code>new</code> 前缀来调用。那么它就被称为构造器函数。按照约定，它们保存在以大写函数命名的变量里。如果调用构造器函数时没有在前面加上<code>new</code>,可能会发生非常糟糕的事情，既没有编译时的警告，也没有运行时广告，所以大写约定非常重要。<br>作者不推荐这种形式的构造器函数。有更好的替代方式。<br><strong>Apply调用模式</strong><br><code>JavaScript</code>是一门函数式的面向对象编程语言，所以对象可以拥有方法。<br><code>apply</code>方法让我们构建一个参数数组传递给调用函数，它也允许我们选择<code>this</code>的值。<br><strong>参数</strong><br><code>arguments</code>，虽然拥有<code>length</code>属性，但不是真正的数组。而是类似数组（<code>array-like</code>）的对象。<br><strong>返回</strong><br><code>return</code> 可用来是函数提前返回。当<code>return</code> 被执行时，函数立即返回而不再执行余下的语句。<br>一个函数总会返回一个值，如果没指定，那就是返回<code>undefined</code>值。<br>如果函数调用时在前面加上了<code>new</code> 前缀，且返回值不是一个对象，则返回<code>this</code>（该新对象）。<br><strong>异常</strong><br><code>JavaScript</code>提供了一套异常处理机制。<br><code>throw</code>语句和<code>try catch</code>,<code>try catch</code>中<code>finally</code>是可选的。<br><strong>扩展类型的功能</strong><br><code>JavaScript</code>允许给语言的基本类型扩充功能。在第3章中我们已经看到，可以通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都可用。这样的方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function () &#123;</span><br><span class="line">  this.prototype[name]  = func;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本类型的原型是公用结构，所以在类库混用时务必小心。一个保险的做法就是只在确认没有该方法时才添加它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.methods = function(name, func) &#123;</span><br><span class="line">  if (!this.prototype[name]) &#123;</span><br><span class="line">      this.prototype[name] = func;</span><br><span class="line">  &#125;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>递归</strong><br>递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，递归是用一般的方式去解决每一个子问题。书中举了一个<strong>汉诺塔</strong>的例子，是程序设计中经典递归问题。详细说明可以参见 <a href="http://baike.baidu.com/view/191666.htm" target="_blank" rel="noopener">百度百科“汉诺塔”词条</a>。<br>一些语言提供了尾递归优化。尾递归是一种在函数的最后执行调用语句的特殊形式的递归。参见<a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">Tail call</a>。 ES6版本扩展了尾递归。参见阮一峰老师的《ES6标准入门》中的<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="noopener">尾调用优化</a><br><strong>作用域</strong><br>在编程语言中，作用域控制着变量与参数的可见性和声明周期。<br>书中指出当前<code>JavaScript</code>没有块级作用域。因为没有块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。不过<code>ES6</code>扩展了有块级作用域。<br><strong>闭包</strong><br>作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;0&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 点击相应节点时，显示对应的序号。可以使用闭包来解决。</span><br><span class="line">var add_the_handlers = function() &#123;</span><br><span class="line">    var helper = function(i) &#123;</span><br><span class="line">        return function(e) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var i;</span><br><span class="line">    for (i = 0; i &lt; nodes.length; i += 1) &#123;</span><br><span class="line">        nodes[i].onclick = helper(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 扩展 另外可以用let i = 0，或者把nodes类数组转成数组等方案实现。</span><br><span class="line">// 闭包特性：1、函数内再嵌套函数，2、内部函数可以调用外层的参数和变量，3、参数和变量不会被垃圾回收机制回收。</span><br><span class="line">// 闭包优点 灵活和方便，便于封装。缺点：空间浪费、内存泄露、性能消耗。</span><br></pre></td></tr></table></figure><p><strong>回调</strong><br>发起异步请求，提供一个当服务器响应到达时随即出发的回调函数。异步函数立即返回，这样客户端就不会被阻塞。<br><strong>模块</strong><br>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。<br>举例：给<code>String</code>添加一个<code>deentityify</code>方法。它的任务是寻找字符串中的<code>HTML</code>字符实体并把它们替换成对应的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String.method(&apos;deentityify&apos;, function () &#123;</span><br><span class="line">    // 字符实体表。它映射字符实体的名字到对应的字符。</span><br><span class="line">    var entity = &#123;</span><br><span class="line">        quot: &apos;&quot;&apos;,</span><br><span class="line">        lt: &apos;&lt;&apos;,</span><br><span class="line">        gt: &apos;&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 返回 deentityify方法</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return this.replace(/&amp;([^&amp;;]+);)/g,</span><br><span class="line">        function (a,b) &#123;</span><br><span class="line">            var r = entity[b];</span><br><span class="line">            return typeof r === &apos;string&apos;? r : a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>模块模式利用了函数作用域和闭包来创建被绑定对象与私有成员的关联，在上面例子中，只有<code>deentityify</code>方法有权访问字符实体表这个数据对象。<br>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。<br>使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。</p><blockquote><p>单例译注<br>模块模式通常结合单例模式使用。<code>JavaScript</code>的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化。更多内容参见：<a href="https://en.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">单例模式</a></p></blockquote><p><strong>级联</strong><br>有一些方法没有返回值。如果我们让这些方法返回<code>this</code>而不是<code>undefined</code>，就可以启用级联。<br>在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。比如<code>jQuery</code>获取元素、操作样式、添加事件、添加动画等。<br><strong>柯里化</strong><br>柯里化，是把多参数函数转换为一系列单参数函数并进行调用的技术。更多详情可参见：<a href="https://en.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a><br>函数也是值。柯里化允许我们把函数与传递给它的参数相结合，产生一个新的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var add1 = add.curry(1);</span><br><span class="line">document.writeln(add1(6));</span><br></pre></td></tr></table></figure></p><p>JavaScript并没有curry方法，但可以扩展该功能。<br>arguments不是真正的数组，所以使用了Array.prototype.slice方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.method(&apos;curry&apos;,function()&#123;</span><br><span class="line">    var slice = Array.prototype.slice,</span><br><span class="line">    args = slice.apply(arguments),</span><br><span class="line">    that = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return that.apply(null, args.concat(slice.apply(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>记忆</strong><br>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化称作记忆。<br>比如说，我们想要一个递归函数来计算<code>Fibonacci</code>(斐波那契)数列，它的特点是，前面相邻两项之和等于后一项的值。更多参考：<a href="https://en.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91" target="_blank" rel="noopener">斐波那契</a>。最前面两个数字是0和1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fibonacci = function() &#123;</span><br><span class="line">    return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样虽然能完成工作，但它做了很多无谓的工作。<br>构造一个带有记忆功能的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var memoizer = function(mome, formula) &#123;</span><br><span class="line">    var recur = function(n) &#123;</span><br><span class="line">        var result = meno[n];</span><br><span class="line">        if (typeof result !== &apos;number&apos;) &#123;</span><br><span class="line">            result = formula(recur, n);</span><br><span class="line">            meno[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    return recur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再用这个<code>memoizer</code>函数来定义<code>fibonacci</code>函数，提供其初始的<code>memo</code>数组和<code>formula</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fibonacci = memoizer([0,1],function(recur, n)&#123;</span><br><span class="line">    return recur(n-1) + recur (n-2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>极大的减少了我们的工作量。例如要产生一个记忆的阶乘函数，只需要提供基本的阶乘公式即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = meoizer([1,1], function(recur, n)&#123;</span><br><span class="line">    return n * recur(n-1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h3><p><strong>伪类</strong><br><code>JavaScript</code>的原型存在诸多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。<br><code>Function</code>构造器产生的函数对象会运行类似这样的一些代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.prototype =  &#123;constructor:this&#125;</span><br></pre></td></tr></table></figure></p><p>新函数对象被赋予一个<code>prototype</code>属性，这个<code>prototype</code>对象是存放继承特征的地方。</p><p>当采用构造器调用模式，即用<code>new</code>前缀去调用一个函数时，函数执行的方式会被修改。如果<code>new</code>运算符是一个方法而不是一个运算符，它可能像这样执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.method(&apos;new&apos;,function()&#123;</span><br><span class="line">    // 创建一个新对象，它继承自构造器函数的原型对象。</span><br><span class="line">    var that = Object.create(this.prototype);</span><br><span class="line">    // 调用构造器函数，绑定 -this- 到新对象上。</span><br><span class="line">    var other = this.apply(that,arguments);</span><br><span class="line">    // 如果它的返回值不是一个对象，就返回该新对象。</span><br><span class="line">    return (typeof other === &apos;object&apos; &amp;&amp; other) || that;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有构造器函数都约定命名成大写字母。一种更好的备选方案就是根本不使用<code>new</code>。<br><strong>对象说明符</strong><br>就是指传多个参数时，可以直接传递一个对象。<br><strong>原型</strong><br>可以用<code>Object.create</code>方法构造出更多实例来。<br><strong>函数化</strong><br>迄今为止，我们所看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。我们无法得到私有变量和私有函数。<br>幸运的是，我们有一个更好的选择，那就是<strong>应用模块模式</strong>。<br>我们从构造一个生成对象的函数开始。我们以小写字母开头来命名。<br>该函数包括以下四个步骤<br>1、创建一个新对象。<br>2、有选择地私有实例变量和方法。<br>3、给这个新对象扩充方法。<br>4、返回那个新对象。<br>以下是一个函数化构造器的伪代码模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constructor = function (spec, my) &#123;</span><br><span class="line">    var that, 其他的私有实例变量；</span><br><span class="line">    my = my || &#123;&#125;;</span><br><span class="line">    把共享的变量和函数添加到my中</span><br><span class="line">    that = 一个新对象</span><br><span class="line">    添加给 that 的特权方法</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们更好的封装和信息隐藏，以及访问父类方法的能力。<br><strong>部件</strong><br>我们可以从一套部件中把对象组装出来。</p><h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章 数组"></a>第6章 数组</h3><p>数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。<br>数组是一种性能出色的数据结构。不幸的是，<code>JavaScript</code>没有像此类数组一样的数据结构。<br><strong>数组字面量</strong><br>对象字面量<br>数组继承了<code>Array.prototype</code>大量有用的方法。而对象字面量是继承自<code>Object.prototype</code>。<br>数组有<code>length</code>属性，而对象没有。<br><strong>长度</strong><br>每个数组都有一个<code>length</code>属性。<br>可以直接设置<code>length</code>的值。设置更大的length不会给数组分配更多的空间，而设小导致所有下标大于等于新length的属性被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">arr.length = 1;</span><br><span class="line">console.log(arr) // [1]</span><br></pre></td></tr></table></figure></p><p>也可以通过<code>length</code>来通过添加值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">arr[arr.length] = 4;</span><br><span class="line">console.log(arr) // [1,2,3,4]</span><br></pre></td></tr></table></figure></p><p>有时用<code>push</code>方法更方便。<br><strong>删除</strong><br>由于<code>JavaScript</code>的数组也是对象，所以<code>delete</code>运算符可以用来从数组中移出元素。移除后，长度不变，原位置上变成了<code>undefined</code>。<br>可以使用<code>Array.prototype.splice</code>方法删除数组。<br><strong>枚举</strong><br>JS数组就是对象，所以<code>for in</code>语句可以用来遍历数据的所有属性。<br><strong>不过</strong>，<code>for in</code>无法保证属性顺序。并且可能从原型链中得到意外的属性。<br><code>for</code>循环可以避免以上问题。<br><strong>容易混淆的地方</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof [] === &quot;object&quot;; // true</span><br><span class="line">typeof &#123;&#125; === &quot;object&quot;; // true</span><br></pre></td></tr></table></figure></p><p>识别是否是数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 方法一、</span><br><span class="line">var is_array = function (value) &#123;</span><br><span class="line">  return value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但它在识别从不同窗口（window）或帧（frame）里的构造的数组时会失败。<br>有一个更好的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 方法二、</span><br><span class="line">var is_array = function (value) &#123;</span><br><span class="line">  return Object.prototype.toString.apply(value) === &apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>扩展</strong>：<br>ES5 提供了Array.isArray()的方法。不过兼容性是IE9+。<br>要做到兼容，可以用如下方法。MDN上提供的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="noopener">MDN Array.isArray</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 方法三、</span><br><span class="line">if (!Array.isArray)&#123;</span><br><span class="line">  Array.isArray = function(arg)&#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">// 方法四</span><br><span class="line">arr instanceof Array;</span><br><span class="line">// 方法五</span><br><span class="line">Array.prototype.isPrototypeOf(arr);</span><br><span class="line">// 方法六</span><br><span class="line">Object.getPrototypeOf(arr) === Array.prototype;</span><br></pre></td></tr></table></figure><p>方法四、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener"><strong>instanceof</strong> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</a><br>方法五、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="noopener"><strong>isPrototypeOf()</strong> 方法用于测试一个对象是否存在于另一个对象的原型链上。</a><br>方法六、[<strong>Object.getPrototypeOf()</strong> 方法返回指定对象的原型（即, 内部<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener">[Prototype]]属性的值）。</a><br>小结：除了方法二、三外，面对复杂的环境，其他的都不能准确的判断是否是数组。<br><strong>方法</strong><br><code>JavaScript</code>提供了一套数组可用的方法，这些方法是被存储在Array.prototype中的函数。<br><code>Object.prototype</code>是可以扩充的。<br><code>Array.prototype</code>也是可以扩充的。<br><code>ES5</code>中提供的<code>Object.create</code>方法。这方法用在数组是没有意义的，因为它产生的是一个对象，而不是一个数组，产生的对象将继承这个数组的值和方法，但它没有<code>length</code>特殊属性。<br><strong>指定初始值</strong><br><code>JavaScript</code>的数组通常不会预设值。书中写了一个循环来扩展，生成初始值。<br><strong>扩展：</strong><code>ES6</code>中提供了<code>fill</code>来填充。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(0);   // [0,0,0]</span><br><span class="line">new Array(3).fill(0);   // [0,0,0]</span><br><span class="line"></span><br><span class="line">// fill方法还可以接受第二、第三个参数，用于指定填充的起始位置和结束位置（不包含）。</span><br><span class="line">new Array(3).fill(0,1,2); // [ ,0, ,]  空位不是undefined。空位没有任何值。ES6则是明确将空位转为undefined。</span><br></pre></td></tr></table></figure></p><h3 id="第7章-正则表达式"><a href="#第7章-正则表达式" class="headerlink" title="第7章 正则表达式"></a>第7章 正则表达式</h3><p>正则表达式对字符串中的信息实现查找、替换和提取操作。<br>可处理正则表达式的方法有<code>regexp.exec</code>、<code>regexp.test</code>、<code>string.match</code>、<code>string.search</code>和<code>string.split</code>。通常来说，正则相较于等效的字符串处理有着显著的性能优势。</p><p><strong>一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正则表达式必须写在一行中</span><br><span class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</span><br><span class="line">var url = &quot;http://www.ora.com:80/goodparts?q#fragment&quot;;</span><br><span class="line">var result = parse_url.exec(url);</span><br><span class="line">// ……</span><br></pre></td></tr></table></figure></p><p>依次匹配到的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url: &apos;http://www.ora.com:80/goodparts?q#fragment&apos;,</span><br><span class="line">scheme: &apos;http&apos;,</span><br><span class="line">slash: &apos;//&apos;</span><br><span class="line">host: &apos;www.ora.com&apos;</span><br><span class="line">port:&apos;80&apos;</span><br><span class="line">path:&apos;goodparts&apos;</span><br><span class="line">query: &apos;q&apos;</span><br><span class="line">hash: &apos;fragment&apos;</span><br></pre></td></tr></table></figure></p><p>个人扩展：这里推荐 <a href="https://regex101.com/" target="_blank" rel="noopener">在线测试正则表达式的网站regex101</a>，默认是PHP语言，选择JavaScript语言。<br><a href="https://regexper.com/#%5Cd%2B" target="_blank" rel="noopener">在线图形化RegExp工具</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">MDN RegExp.prototype.exec()</a><br>大概解释下这个正则，<br>这里的<code>^</code> 起始位置，<code>$</code>结束位置<br><code>()</code> 分组捕获 <code>?:</code>不捕获<br><code>.</code>表示除换行以外的任意单个字符，对于码点大于<code>0xFFFF</code>的<code>Unicode</code>字符，点(<code>.</code>)不能识别（<code>ES6</code>中加<code>u</code>修饰符才可识别），<code>+</code>表示一个或多个，<code>*</code>表示零个或多个，<code>?</code>表示<code>0</code>个或一个。[]表示或者，里面符合一个即可。<br><code>\d</code>表示数字<code>0-9</code>。<br>不严谨的正则表达式是一个常见的安全漏洞的发源地。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。</p><p>再看一个 <strong>匹配数字</strong>的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;</span><br><span class="line">parse_number.test(&apos;1&apos;); // true</span><br><span class="line">parse_number.test(&apos;number&apos;); // false</span><br><span class="line">parse_number.test(&apos;98.6&apos;); // true</span><br><span class="line">parse_number.test(&apos;132.21.86.100&apos;); // false</span><br><span class="line">parse_number.test(&apos;123.45E-67&apos;); // true</span><br><span class="line">parse_number.test(&apos;123.45D-67&apos;); // false</span><br></pre></td></tr></table></figure></p><p><strong>结构</strong><br>有两个方法来创建一个<code>RegExp</code>对象。优先考虑的是正则表达式字面量，还有一种方式是<code>new RegExp(&#39;&#39;,&#39;g&#39;)</code>。<br>正则表达式标识：<code>g</code>全局(匹配多次，不同的方法对<code>g</code>标识的处理防范各不相同)，<code>i</code>忽略大小写。<code>m</code>多行<br><strong>元素</strong><br><strong>正则表达式分支</strong><br><code>|</code>表示或，也表示分支 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;info&apos;.match(/in|int/)  // 匹配成功，[&quot;in&quot;, index: 0, input: &quot;info&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式序列</strong><br>一个正则表达式序列饱和一个或多个正则表达式因子。每一个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，若没指定，这个因子则只匹配一次。<br><strong>正则表达式因子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\ / [ ] () &#123; &#125; ? + * | . ^ $</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式转义</strong><br>\ 表转义 <code>\f</code> 分页 <code>\n</code> 换行 <code>\r</code>回车 <code>\t</code> 制表<br><code>\u</code> 允许制定一个 Unicode 字符来表示一个十六进制的常量。<br><code>\d</code> 等同于[0-9] \D 取反等同于 <code>[^0-9]</code><br><code>\s</code> <code>Unicode</code> 空白符一个不完全子集。 \S 与\s相反<br><code>\w</code> <code>[0-9A-Z_a-z]</code> \W 与其相反 <code>[^0-9A-Z_a-z]</code><br><code>\b</code> 表示 字边界<br><code>\1</code> 表示 分组1所捕获的文本的一个引用，所以它能被再次匹配。<br><code>\2</code> 表示 指向分组2的引用，<code>\3</code> 是表示分组3的引用，以此类推。<br><strong>正则表达式分组</strong><br>捕获型<code>()</code><br>非捕获型<code>?:</code><br>向前正向匹配<code>?=</code><br>有一个<code>(?=</code>前缀。它类似于非捕获类型分组，但在这个组匹配后，文本会倒回到它它开始的地方，实际上并不匹配任何东西。也可以理解为匹配位置。<br>向后负向匹配<br>有一个<code>(?!</code>前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。<br><strong>正则表达式字符集</strong><br>正则表达式字符集是一种指定一组字符的便利方式。例如，要匹配一个元音字母，<code>(?:a|e|i|o|u)</code>,可以方便的写成<code>[aeiou]</code>。<br>类提供另外两个便利：①指定字符范围<br>所以，一组由<code>32</code>个<code>ASCII</code>的特殊组合，可以写成<code>[!-\/:-@\[-</code>{-~]`<br>②类的取反<br>取反<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^!-\/:-@\[-`&#123;-~]</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式字符转义</strong><br>字符类内部的转义规则和正则表达式因子的相比稍有不同。下面是在字符类中需要被转义的特殊字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- / [ \ ]</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式量词</strong><br>量词后缀决定正则表达式因子应该被匹配的次数。<br><code>{3}</code>三次<br><code>{3,6}</code> 3、4、5、6次<br><code>{3,}</code>3次或更多次<br><code>?</code>等同于<code>{0,1}</code>，<code>*</code>等同于<code>{0,}</code>，<code>+</code>等同于<code>{1,}</code>。</p><h3 id="第8章-方法"><a href="#第8章-方法" class="headerlink" title="第8章 方法"></a>第8章 方法</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><strong>array.concat(item…)</strong><br><code>concat</code> 方法产生一个新数组，它包含一份<code>array</code>的浅复制并把一个或多个参数<code>item</code>附加在其后。如果<code>item</code>是数组，那么每个元素分别被添加。后面有和它功能类似的<code>array.push(item...)</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</span><br><span class="line">var c = a.concat(b, true);</span><br><span class="line">// c =&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,true]</span><br></pre></td></tr></table></figure></p><p><strong>扩展：</strong> <code>ES6</code> 有更便捷的扩展运算符<code>...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</span><br><span class="line">var c = [...a,true,...b];   // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, true, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>array.join(separator)</strong><br><code>join</code>方法把一个<code>array</code>构造成一个字符串。<br><code>separator</code> 默认值就是逗号<code>&#39;,&#39;</code>。<br>如果你想把大量的字符串片段组装成一个字符串，把这些片段放在一个数组中，并用<code>join</code>方法连接起来通常比用<code>+</code>元素运算符连接起来要快。</p><blockquote><p>译注：对于<code>IE6/7</code>，使用join连接大量字符串效率确实优于加号运算符。但目前主流浏览器，包括<code>IE8</code>以后的版本，都对<code>+</code>元素运算符连接字符串做了优化，性能已经显著高于<code>Array.join()</code>。所以目前大多数情况下，建议首选使用+ 连接字符串。更多参看《高性能网站建设进阶指南》中字符串优化相关章节。</p></blockquote><p><strong>array.pop()</strong><br><code>pop</code>方法移除<code>array</code>中的最后一个元素，并返回这个元素。如果<code>array</code>为空，则返回<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">var c = a.pop(); // a 是 [&apos;a&apos;,&apos;b&apos;]  c是 &apos;c&apos;</span><br><span class="line">// pop 可以像这样实现。</span><br><span class="line">// 这里的 Array.method()在第一章例子中已经定义了，并且贯穿全书。其实就是相当于Array.prototype</span><br><span class="line">Array.method(&apos;pop&apos;, function () &#123;</span><br><span class="line">    return this.splice(this.length-1,1)[0];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>array.push(item…)</strong><br>与<code>concat</code>不同的是，它会修改array，如果参数<code>item</code>是数组，它会把参数数组作为单个元素整个添加到数组中。并返回这个<code>array</code>的新长度值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var b = [4,5,6];</span><br><span class="line">var c = a.push(b,true);</span><br><span class="line">// a 是 [1,2,3,[4,5,6],true]</span><br><span class="line">// c 是 5</span><br></pre></td></tr></table></figure></p><p><code>push</code>可以像这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.method(&apos;push&apos;, function () &#123;</span><br><span class="line">  this.splice.apply(</span><br><span class="line">  this,</span><br><span class="line">  [this.length,0].</span><br><span class="line">  concat(Array.prototype.slice.apply(arguments)));</span><br><span class="line">  return this.length;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>array.reverse()</strong><br><code>reverse</code>反转<code>array</code>元素顺序，并返回<code>array</code>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var b = a.reverse();</span><br><span class="line">// a 和 b都是 [3,2,1]</span><br></pre></td></tr></table></figure></p><p><strong>array.shift()</strong><br><code>shift</code>移除<code>array</code>的第一个元素并返回这个元素。如果<code>array</code>为空，则返回<code>undefined</code>。<code>shift</code>通常比<code>pop</code>慢的多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var c = a.shift(); // a 是[2,3] , c 是1</span><br></pre></td></tr></table></figure></p><p><code>shift</code>可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.method(&apos;shift&apos;, function()&#123;</span><br><span class="line">    return this.splice(0,1)[0];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>array.slice(start[, end])</strong><br><code>slice</code>是对<code>array</code>中的一段做浅复制。<code>end</code>是可选的。默认是<code>array.length</code>,如果两个参数任何一个是负数，<code>array.length</code>会和相加。如果<code>start</code>大于<code>array.length</code>,获得一个<code>[]</code>,字符串也有<code>Sting.slice</code>这个同名方法。<br><strong>array.sort</strong><br>默认不能给一组数字排序。默认把要被排序的元素都视为字符串。<br>幸运的是，可以使用自己的比较函数替换默认的比较函数。<br>比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。<br><code>sort</code>方法是不稳定的。<code>JavaScript</code>的<code>sort</code>方法的稳定性根据不同浏览器的实现而不一致。<br>可参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">MDN sort</a><br><strong>array.splice(start, deleteCount,item…)</strong><br><code>splice</code>方法从array中移除一个或多个元素，并用新的<code>item</code>替换它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// splice 可以像这样实现</span><br><span class="line">Array.method(&apos;splice&apos;,function (start, deleteCount) &#123;</span><br><span class="line">    var max = Math.max,</span><br><span class="line">        min = Math.min,</span><br><span class="line">        delta,</span><br><span class="line">        element,</span><br><span class="line">        insertCount = max(arguments.length - 2, 0),</span><br><span class="line">        k = 0,</span><br><span class="line">        len = this.length,</span><br><span class="line">        new_len,</span><br><span class="line">        result = [],</span><br><span class="line">        shift_count;</span><br><span class="line">    start = start || 0;</span><br><span class="line">    if (start &lt; 0) &#123;</span><br><span class="line">        start += len;</span><br><span class="line">    &#125;</span><br><span class="line">    start = max(min(start, len), 0);</span><br><span class="line">    deleteCount = max(min(typeof deleteCount === &apos;number&apos; ? deleteCount : len, len - start), 0);</span><br><span class="line">    delta = insertCount - deleteCount;</span><br><span class="line">    new_len = len + delta;</span><br><span class="line">    while (k &lt; deleteCount) &#123;</span><br><span class="line">        element = this[start + k];</span><br><span class="line">        if (element !== undefined) &#123;</span><br><span class="line">            result[k] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        k += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    shift_count = len - start - deleteCount;</span><br><span class="line">    if (delta &lt; 0) &#123;</span><br><span class="line">        k = start + insertCount;</span><br><span class="line">        while (shift_count) &#123;</span><br><span class="line">            this[k] = this[k - delta];</span><br><span class="line">            k += 1;</span><br><span class="line">            shift_count -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length = new_len;</span><br><span class="line">    &#125; else if (delta &gt; 0) &#123;</span><br><span class="line">        k = 1;</span><br><span class="line">        while (shift_count) &#123;</span><br><span class="line">            this[new_len - k] = this[len - k];</span><br><span class="line">            k += 1;</span><br><span class="line">            shift_count -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length = new_len;</span><br><span class="line">    &#125;</span><br><span class="line">    for (k = 0; k &lt; insertCount; k += 1) &#123;</span><br><span class="line">        this[start + k] = arguments[k + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>array.unshift(item…)</strong><br><code>unshift</code> 方法像<code>push</code>方法一样，不过是用于把元素添加到数组的开始部分，返回新<code>array</code>的<code>length</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// unshift 可以像这样实现</span><br><span class="line">Array.method(&apos;unshift&apos;, function()&#123;</span><br><span class="line">    this.splice.apply(this,</span><br><span class="line">    [0,0].concat(Array.prototype.slice.apply(arguments)));</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p><strong>function.apply(thisArg,argArray)</strong><br><code>apply</code>方法调用<code>function</code>,传递一个会被绑定到<code>this</code>上的对象和一个可选的数组作为参数。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p><strong>number.toExponential(fractionDigits)</strong><br><code>toExponential</code>方法 把这个<code>number</code>转换成一个指数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在<code>0~20</code>。</p><p><strong>number.toFixed(fractionDigits)</strong><br><code>toFixed</code>方法把这个number转换成一个十进制数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。</p><p><strong>number.toPrecision(precision)</strong><br><code>toPrecision</code>方法把这个<code>number</code>转换成一个十进制数形式的字符串。可选参数控制数字的精度。它的值必须在<code>0~21</code>。</p><p><strong>number.toString(radix)</strong><br>把<code>number</code>转换成字符串。可选参数控制基数。它的值必须是<code>2~36</code>。默认的<code>radix</code>是以<code>10</code>为基数的。<code>radix</code>参数最常用的是整数，但是它可以用任意的数字。</p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p><strong>object.hasOwnProperty(name)</strong><br>如果这个<code>object</code>包含名为<code>name</code>的属性，那么返回<code>true</code>。原型链中的同名方法不会被检测。这个方法对<code>name</code>就是<code>“hasOwnProperty”</code>时不起作用。</p><h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p><strong>regexp.exec(string)</strong><br><code>exec</code>是正则中最强大(和最慢）的方法。<br>如果成功匹配，它会返回一个数组。下标为0 的元素包含正则匹配的子字符串。下标为1的则是分组1捕获的文本。下标为2的则是分组2捕获的文本。以此类推。如果匹配失败则返回<code>null</code>。<br><strong>regexp.test(string)</strong><br><code>test</code>是最简单(和最快)的方法。匹配成功，返回<code>true</code>,否则返回<code>false</code>。不要对这个方法使用<code>g</code>标识。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\w+/g;</span><br><span class="line">reg.test(&apos;ab&apos;); // true</span><br><span class="line">// 再执行一遍就是false了。</span><br><span class="line">reg.test(&apos;ab&apos;); // false</span><br><span class="line">// 再执行一遍就是true了。</span><br><span class="line">reg.test(&apos;ab&apos;); // true</span><br><span class="line">// 再执行一遍又是false了，如此反复，所以用g标识后，看起来很诡异。应该每次匹配开始位置变了。</span><br><span class="line">reg.test(&apos;ab&apos;); // false</span><br></pre></td></tr></table></figure></p><p><code>test</code>可以像这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegExp.method(&apos;test&apos;, function(string)&#123;</span><br><span class="line">    return this.exec(string) !== null;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>string.charAt(pos)</strong><br>返回在<code>string</code>中的<code>pos</code>位置处的字符。</p><p><strong>string.charCodeAt(pos)</strong><br>与<code>charAt</code>一样，不过返回整数形式表示字符码位。</p><p><strong>string.concat(string)</strong><br>很少用，用<code>+</code>号运算符更方便。</p><p><strong>string.indexOf(searchString,position)</strong><br>在<code>string</code>中查找第一个参数，如果被找到返回该字符的位置，否则返回<code>-1</code>。<code>position</code>可设置指定位置开始查找。</p><p><strong>string.lastIndexOf(searchString,position)</strong><br><code>lastIndexOf</code> 方法和<code>indexOf</code>方法类似，不过它是从末尾开始查找，不是从头开始。</p><p><strong>string.localeCompare(that)</strong><br>比较两个字符串。类似于<code>array.sort</code>。</p><p><strong>string.match(regexp)</strong><br>如果没有<code>g</code>标识，那么调用<code>string.match(regexp)</code>和调用<code>regexp.exec(string)</code>结果相同。如果带有<code>g</code>标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组。</p><p><strong>string.replace(searchValue,replaceValue)</strong><br>对<code>string</code>进行查找和替换操作，并返回一个新的字符串。参数<code>searchvalue</code>可以是一个字符串也可以是一个正则表达式对象。参数<code>replaceValue</code>可以是一个字符串或一个函数。</p><p><strong>string.search(regexp)</strong><br>和<code>indexOf</code>类似，不过它接收正则为参数。</p><p><strong>string.slice(start, end)</strong><br><code>slice</code>方法复制<code>string</code>的一部分来构造一个新的字符串。如果<code>start</code>参数是负数，它将与<code>string.length</code>相加。<code>end</code>参数是可选的。</p><p><strong>string.split(separator,limit)</strong><br>把<code>string</code>分割成片段来创建一个字符串数组。可选参数<code>limit</code>可以限制分割的片段数量。<code>separator</code>参数可以是字符串或者正则。<br><strong>string.substring(start,end)</strong><br>与<code>slice</code>方法一样，不过它不能处理负数参数。<br><strong>string.toLocaleLowerCase()</strong><br>它使用本地化的规则把这个<code>string</code>中的字母转换成小写格式。这个方法主要用在土耳其语上。<br><strong>string.toLocaleUpperCase()</strong><br>它使用本地化的规则把这个<code>string</code>中的字母转换成大写格式。这个方法主要用在土耳其语上。<br><strong>string.toLowerCase()</strong><br>返回新字符串，所有字母转成小写格式。<br><strong>string.toUpperCase()</strong><br>返回新字符串，所有字母转成大写格式。<br><strong>String.fromCharCode(char…)</strong><br>根据一串数字编码返回一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = String.fromCharCode(67,97,116) // a是&apos;Cat&apos;</span><br></pre></td></tr></table></figure></p><h3 id="第9章-代码风格"><a href="#第9章-代码风格" class="headerlink" title="第9章 代码风格"></a>第9章 代码风格</h3><p>这一章中，简短的说了一些代码风格。事实证明代码风格在编程中是很重要的。</p><h3 id="第10章-优美的特性"><a href="#第10章-优美的特性" class="headerlink" title="第10章 优美的特性"></a>第10章 优美的特性</h3><p>精简的<code>JavaScript</code>里都是好东西。<br>包括：1、函数是顶级对象；2、基于原型继承的动态作用域；3、对象字面量和数组字面量。</p><p>到此，读书笔记已完结。文章有什么不妥之处，欢迎指出~</p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<strong>轩辕Rowboat</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010313101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记&lt;/a&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://lxchuan12.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="https://lxchuan12.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>工作一年后，我有些感悟</title>
    <link href="https://lxchuan12.github.io/2017/06/02/20170602-After%20a%20year&#39;s%20work,%20I%20had%20some%20insights/"/>
    <id>https://lxchuan12.github.io/2017/06/02/20170602-After a year&#39;s work, I had some insights/</id>
    <published>2017-06-02T14:20:53.000Z</published>
    <updated>2018-06-23T14:41:12.801Z</updated>
    
    <content type="html"><![CDATA[<p>去年6月1日，入职那天早上下着小雨。在公司取了一个花名：<strong>轩辕</strong>，后来把网上昵称基本都改成了<strong>轩辕Rowboat</strong>。还记得那天晚上朋友请我吃小龙虾。</p><p>今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。<a id="more"></a></p><h3 id="学习工作"><a href="#学习工作" class="headerlink" title="学习工作"></a>学习工作</h3><p><strong>从校园到职场</strong></p><p>主动认识同事。</p><p>虽然不太可能与每一个同事都能相处的特别熟。但对于新人，都会被拉入一些群。这时候，可以加同事QQ或者微信等（同事一般不会拒绝），便于之后沟通交流工作。</p><p>这时候有的人能够主动快速得认识团队里的同事。有的人则是入职了很久都不认识对面的同事。</p><p>把离别看得平淡了许多。大学毕业后，很多人一晃一年没见，是再正常不过的事了。</p><p>同事离职后，即使还在同一个城市，但交集就变少了。</p><p>有江湖的地方就有规矩，职场也有。在职场只要用心去发现，能够学到公司的管理方式等。</p><p><strong>认清自己的定位</strong></p><p>常和别人开玩笑说，自己是来自贫困的小山村的一个大学生，职业是：说的高端一点是<strong>前端开发工程师</strong>，说的通俗易懂点则是<strong>做网站的程序猿</strong>。嗯，这就算是一种定位。</p><p>像我这样的人几百万。想起一个朋友说：感觉你在IT方面很厉害。我说：你只是认识万千程序猿中的一个而已。</p><p><strong>学无止境，提升竞争力</strong></p><p>智联招聘网显示：web前端开发是竞争最激烈的职业。</p><p>上次听一次segmentfault的讲堂，其中有提到慕课网有很多用户，其中400万是前端开发。</p><p>有时候会想我这一年是不是学习方式不对，不够努力，或者说能否再努力一点，是不是能够进入更好的大公司，能够得到更好的成长。</p><p><strong>事实证明，自身能力不够，有机遇来了，会抓不住。</strong></p><p>比如：之前有面试过淘宝、大搜车等，然而技术一般，没能通过面试。</p><h3 id="现实生活"><a href="#现实生活" class="headerlink" title="现实生活"></a>现实生活</h3><p>我读大学买了电脑考了驾照，四年花了家里4万块左右（从大一暑假买电脑开始算到大四结束，用Excel统计家里打了25200元给我）。而在杭州待一年光吃住就得花近3万块（吃饭按一天40元算，一个月1200，租房1100+）。</p><p>最近看的电视剧《欢乐颂2》中，身为90后的程序猿应勤在大上海买了车买了房（好像还提到是全额付款）。现实中在大上海房价均价5.5万/平米，有人分析单靠程序猿那点工资（虽然IT行业相对其他行业薪资高些）是不太可能的。</p><h3 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h3><p>看到毕业几年的同事过着怎样的生活，可以推测出几年后的自己大概过着怎样的生活。当然未来的一切都是未知的。但基本能看出自己一年后是过着怎样的生活。</p><p>月薪两万的薪资算是很不错了，但是在大城市算刚起步，为什么算刚起步，主要因为房价太高，买个房好几百万。比较优秀的前端开发工程师，工作三年后月薪大概能达到15K—20K，当然各城市不一。再往后，能达到年薪50万左右已经是非常不错了。</p><p><strong>如何提高收入，是大家关心的永恒的话题。</strong>5月份我们从学校课题组出来的三个同学回学校时，在高铁上上讨论过，毕业一年有什么感觉，大家都一致认为：<strong>要想单靠开发这点薪资，在大城市立足，是非常艰难的。</strong>然后想着有哪些赚钱之道，都可以去试试，刚毕业一年，还算很早。</p><p>主要说到三条。<strong>第一条是：加入有潜力的团队初创公司（拿股份）。</strong>同学就说到他们老大的事迹，说刚靠程序猿这点工资在大城市过上小资生活是很艰难的，他之前加入阿里后来拿股份才开了现在的公司（大概意思是这样）。</p><p><strong>第二条是：拓展自己的人脉，找准风口，好创意，自己组建团队开发出有价值的产品。</strong>说到这条我就提到小密圈（付费圈子，我加入一个圈子收费200，有700+人加入，运营一年，就能得到14万的收入。）</p><p>我自己也建了一个<strong>前端视野</strong>的小密圈（免费），发发自己关于前端开发的所见所想，也好沉淀沉淀，没打算怎么推广，但这里还是贴一下二维码，<strong>万一有人想加入呢</strong>。</p><p><img src="/2017/06/02/20170602-After%20a%20year%27s%20work,%20I%20had%20some%20insights/zsxq.png" title="前端视野-小密圈-一个人走得快，一群人走得远">。</p><p>[前端视野-小密圈-一个人走得快，一群人走得远]</p><p>前端视野-小密圈-一个人走得快，一群人走得远<br>还建有一个<strong>PPT视野</strong>的圈子，这个目前还没发过动态。</p><p><strong>第三条则是：发展一项兴趣爱好，打造个人品牌，做到可以赚大钱的地步。</strong>（有人刚毕业4K，毕业三年，凭借PPT，开商务PPT训练营收费课程，年薪50万）。他们经常问我可以多接些PPT来做，就可以赚点钱了，我说目前没有时间，也没有渠道，而且我也是只是万千PPT设计师中很渣的一员。</p><p>想做到收入更高，除了做好本职工作和提升专业素养外，也需要跳出来看看外面的世界。</p><p>上次和同学几人一起玩的时候，有个妹纸说了这句，<strong>何以解忧，唯有暴富</strong>。让我记忆犹新。</p><p>事实上群体中确实有小概率事件发生，比如中个上千万的彩票，但是对于个体，这种事几乎不可能发生。而且有研究表明，中彩票的普通人，一般会在五年后用完这笔财富，最后还是普通人。</p><p><strong>所以说：提高自己在各方面的竞争力</strong>，比如：为人处事、沟通表达、团队协作等等，这也就是<strong>可迁移能力</strong>，以不变应对这个变化的世界，才是最重要的。</p><p><a href="http://www.jianshu.com/p/0b29cc65dc82" target="_blank" rel="noopener">这是我写在简书的文章：工作一年后，我有些感悟</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年6月1日，入职那天早上下着小雨。在公司取了一个花名：&lt;strong&gt;轩辕&lt;/strong&gt;，后来把网上昵称基本都改成了&lt;strong&gt;轩辕Rowboat&lt;/strong&gt;。还记得那天晚上朋友请我吃小龙虾。&lt;/p&gt;
&lt;p&gt;今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。
    
    </summary>
    
      <category term="随笔" scheme="https://lxchuan12.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lxchuan12.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感悟" scheme="https://lxchuan12.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何破解百度网盘下载限制及网盘搜索技巧</title>
    <link href="https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/"/>
    <id>https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/</id>
    <published>2017-03-17T14:52:23.000Z</published>
    <updated>2017-06-24T15:22:02.618Z</updated>
    
    <content type="html"><![CDATA[<p>今天两个朋友问我如何选电脑的问题，我说了一些大概流程，<strong>需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买</strong>。其实我好久没有关注这方面了，毕竟没钱买电脑。<br>晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。<a id="more"></a>大学里也会去图书馆看看纸质的。然后<strong>找到</strong> 2017年《电脑报》的看了一会。<br>看到一篇《如何破解百度网盘下载限制》的文章，我试过后有效，特来分享整理给大家。<br>在chrome浏览器中，新建一个书签，书签名字随意，书签的网址复制粘贴这段代码：<br><code>javascript:navigator.__defineGetter__ (&#39;platform&#39;,function(){return &#39;&#39;});</code></p><p><img src="http://upload-images.jianshu.io/upload_images/201107-eee7bebd91594895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建一个书签下载时点击下它.png"></p><p>它的作用是<strong>防止下载大文件时唤醒百度网盘客户端</strong>。</p><p><strong>所以在点击“下载”前，先点击它。</strong>待开始下载后，打开浏览器的<strong>“下载内容”</strong>（快捷键：Ctrl+J），看到正在进行的下载任务选择<strong>“复制链接地址”</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-6c69c444dff3c8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右击复制链接地址.png" title="">                </div>                <div class="image-caption">右击复制链接地址.png</div>            </figure><p>将地址粘贴到<strong>迅雷极速版</strong>下载，官方好像不提供下载链接了，这里推荐<a href="http://rj.baidu.com/soft/detail/26860.html" target="_blank" rel="noopener">百度软件中心下载地址</a><a href="http://rj.baidu.com/soft/detail/26860.html" target="_blank" rel="noopener">http://rj.baidu.com/soft/detail/26860.html</a> ,点击<strong>普通下载</strong>即可，这样就可以了。<br>    虽然速度不是非常稳定但至少比百度云盘PC客户端几十KB／s快。不建议大家再安装破解版，有钱还是买个会员吧，或者干脆上NAS。</p><p>可能有小伙伴好奇我是如何找到2017年的《电脑报》的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-9e63cc297f48f3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜百度盘.png" title="">                </div>                <div class="image-caption">搜百度盘.png</div>            </figure><p>这时分享几个网盘搜索网站：</p><p>（常用）搜百度盘：<a href="http://www.sobaidupan.com" target="_blank" rel="noopener">http://www.sobaidupan.com</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-6d70b392f3eb0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索“罗小川chuan”结果.png" title="">                </div>                <div class="image-caption">搜索“罗小川chuan”结果.png</div>            </figure><p>搜索“罗小川chuan”结果，可怕，我得赶紧取消一些个人信息的公开分享了。</p><p>盘搜网：<a href="http://www.pansou.com/" target="_blank" rel="noopener">http://www.pansou.com/</a><br>搜盘网：<a href="http://www.soupan.info/" target="_blank" rel="noopener">http://www.soupan.info/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-8700418458856aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="之前书签里保存的网盘搜索网站.png" title="">                </div>                <div class="image-caption">之前书签里保存的网盘搜索网站.png</div>            </figure><p>等等，其他就不附链接了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天两个朋友问我如何选电脑的问题，我说了一些大概流程，&lt;strong&gt;需求-&amp;gt;预算-&amp;gt;筛选-&amp;gt;对比-&amp;gt;购买&lt;/strong&gt;。其实我好久没有关注这方面了，毕竟没钱买电脑。&lt;br&gt;晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。
    
    </summary>
    
      <category term="网盘搜索" scheme="https://lxchuan12.github.io/categories/%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="window" scheme="https://lxchuan12.github.io/tags/window/"/>
    
      <category term="skyDrive" scheme="https://lxchuan12.github.io/tags/skyDrive/"/>
    
      <category term="Baidu" scheme="https://lxchuan12.github.io/tags/Baidu/"/>
    
  </entry>
  
  <entry>
    <title>简单实用免费的shadowsocks科学上网技巧</title>
    <link href="https://lxchuan12.github.io/2017/03/06/20170306-freess/"/>
    <id>https://lxchuan12.github.io/2017/03/06/20170306-freess/</id>
    <published>2017-03-06T15:02:23.000Z</published>
    <updated>2018-07-14T15:37:02.065Z</updated>
    
    <content type="html"><![CDATA[<p>开发时遇到问题，一般都是使用<strong>谷歌搜索</strong>，相对百度更加精准一些。比如搜索我的网名<strong>轩辕Rowboat</strong>，一大堆结果。<a id="more"></a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-0c966a706280b1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌搜索轩辕Rowboat结果.png" title="">                </div>                <div class="image-caption">谷歌搜索轩辕Rowboat结果.png</div>            </figure></p><p>谷歌书签同步，YouTube等等。总是需要<strong>科学上网</strong>的。<br>一次偶然的机会发现了这个网站，<a href="http://freess.cx/" target="_blank" rel="noopener">FreeSS-最好用的免费SS提供站点</a></p><blockquote><p>有时不是很稳定。链接地址有时会变更，现在可以访问(<a href="https://ss.freess.org/)，（2018-05-29" target="_blank" rel="noopener">https://ss.freess.org/)，（2018-05-29</a> 更新）<br>（提供免费的ss账号）（免费为它打广告~）<br>觉得好东西要分享给大家，于是写下这篇文章（当然我觉得很多人都会，但还是写了）。</p></blockquote><h3 id="下载shadowsocks（Mac，Android等可以下载相应版本）："><a href="#下载shadowsocks（Mac，Android等可以下载相应版本）：" class="headerlink" title="下载shadowsocks（Mac，Android等可以下载相应版本）："></a>下载shadowsocks（Mac，Android等可以下载相应版本）：</h3><p>windows各版本下载地址：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a>，这网址一般不会是失效。一般下载最新的Downloads-&gt;Shadowsocks-xxx.zip即可。</p><p>Mac，Android等可以在这个链接下载：<a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a><br>我下载的是:<a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.4.3/Shadowsocks-3.4.3.zip" target="_blank" rel="noopener">3.4.3.zip版本</a> ，软件一直在持续更新，链接可能会失效。解压到电脑任意位置，点击打开Shadowsocks.exe程序，程序图标会出现在右下角。</p><h3 id="打开这个网站http-freess-org-，配置"><a href="#打开这个网站http-freess-org-，配置" class="headerlink" title="打开这个网站http://freess.org/ ，配置"></a>打开这个网站<a href="http://ss.freess.org/" target="_blank" rel="noopener">http://freess.org/</a> ，配置</h3><p>打开任意一个二维码，鼠标移入你会发现有左右箭头，点击有多个二维码。右键程序图标，弹出菜单中选择“<strong>服务器</strong>”－“<strong>扫描屏幕上的二维码</strong>”，扫描成功后会<strong>自动配置</strong>，菜单中勾选“<strong>启用系统代理</strong>”即可。这时就可以使用任意浏览器科学上网了。不过这个免费的ss账号（目前2018-05-29可用），<strong>只限当天使用，次日得重新扫描</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-b74e7c9df6536f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑服务器" title="">                </div>                <div class="image-caption">编辑服务器</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-421cb8b9e8ec2aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置截图" title="">                </div>                <div class="image-caption">配置截图</div>            </figure><p>当然只想用谷歌搜索不一定要科学上网，可以使用谷歌镜像搜索。（网上有一些<strong>谷歌镜像站</strong>，不过有一定局限性，也有一些可用谷歌学术搜索镜像）。</p><h3 id="可能遇到问题："><a href="#可能遇到问题：" class="headerlink" title="可能遇到问题："></a>可能遇到问题：</h3><p>如果碰到打开时提示，版本过低。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-2a558d5cb7bf523e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="版本过低.png" title="">                </div>                <div class="image-caption">版本过低.png</div>            </figure><p>下载安装.netframework<a href="https://download.microsoft.com/download/D/5/C/D5C98AB0-35CC-45D9-9BA5-B18256BA2AE6/NDP462-KB3151802-Web.exe" target="_blank" rel="noopener">下载地址链接</a></p><p>更多<strong>使用说明</strong>可以查看：<a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方中文说明文档</a><br>比如：配合谷歌插件（<strong>SwitchyOmega</strong> ）共同使用，可以做到系统代理和直接连接，自动切换，就不容易导致开了代理，连接不需要代理的网站异常了。<br><a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">SwitchyOmega插件下载安装地址</a><br>更多SwitchyOmega插件使用方法，可以查看这篇文章，比较详细<a href="https://blog.csdn.net/shouldnotappearcalm/article/details/77900399" target="_blank" rel="noopener">shadowsocks配合chrome插件SwitchyOmega</a></p><p>更多安装谷歌浏览器插件的方法可以查看这篇<a href="https://www.jianshu.com/p/12ca04c61fc6" target="_blank" rel="noopener">如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？</a></p><p>更多原理相关可以查看这篇文章<a href="http://www.barretlee.com/blog/2016/08/03/shadowsocks/" target="_blank" rel="noopener">Shadowsocks 原理简介及安装指南</a></p><h3 id="最后推荐一个的chrome-的科学上网插件-skyZIP™-Proxy"><a href="#最后推荐一个的chrome-的科学上网插件-skyZIP™-Proxy" class="headerlink" title="最后推荐一个的chrome 的科学上网插件 skyZIP™-Proxy"></a>最后推荐一个的<code>chrome</code> 的科学上网插件 <code>skyZIP™-Proxy</code></h3><p>不知道过了多久，后来上面推荐的那个网址 <a href="http://ss.freess.org" target="_blank" rel="noopener">http://ss.freess.org</a> 本身有时候好像就是要科学上网访问的。<br><code>skyZIP™-Proxy</code> 百度云盘链接: <a href="https://pan.baidu.com/s/1LvUkTGhd1m2HT5QJ9dSbwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1LvUkTGhd1m2HT5QJ9dSbwg</a> 密码: 13x4<br>可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何安装可以参照上文推荐的<a href="https://www.jianshu.com/p/12ca04c61fc6" target="_blank" rel="noopener">如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发时遇到问题，一般都是使用&lt;strong&gt;谷歌搜索&lt;/strong&gt;，相对百度更加精准一些。比如搜索我的网名&lt;strong&gt;轩辕Rowboat&lt;/strong&gt;，一大堆结果。
    
    </summary>
    
      <category term="shadowsocks" scheme="https://lxchuan12.github.io/categories/shadowsocks/"/>
    
    
      <category term="shadowsocks" scheme="https://lxchuan12.github.io/tags/shadowsocks/"/>
    
      <category term="ss" scheme="https://lxchuan12.github.io/tags/ss/"/>
    
      <category term="科学上网" scheme="https://lxchuan12.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="freess" scheme="https://lxchuan12.github.io/tags/freess/"/>
    
  </entry>
  
  <entry>
    <title>vue1.0和2.0的区别</title>
    <link href="https://lxchuan12.github.io/2017/02/12/20170212-The%20difference%20between%20vue1.0%20and%202/"/>
    <id>https://lxchuan12.github.io/2017/02/12/20170212-The difference between vue1.0 and 2/</id>
    <published>2017-02-12T07:04:23.000Z</published>
    <updated>2017-06-24T15:23:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>重新仔细读了下文档，边看边写了一些。<br>1、v-once只渲染一次。<br>2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。<br>全局过滤器和单个过滤器。<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in mustaches --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line">&lt;!-- in v-bind --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure><p>3、watch允许异步操作。computed做不到。<br>4、新增：v-else-if<br>5、v-if中，使用 key 控制元素的可重用<br>6、v-for (value,index)，$index被废除。 item in items,item of items.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>7、track-by=”$index”被废用，用key替代。（就地复用）<br>7.1、template中不能使用this不是。data.a=1,template,直接写a即可。<br>8、2.1.4新增<a v-on:click.once="doThis"></a><br>9、2.1.0 新增<br>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure></p><p>10、修饰符lazy,number,trim<br>11、组件中data 必须是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;my-row&gt;...&lt;/my-row&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>12、自定义事件，废除了events、$dispatch、$broadcast。<br>使用 $on(eventName) 监听事件<br>使用 $emit(eventName) 触发事件<br>13、给组件绑定原生事件-修饰符.native<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>使用自定义事件的表单输入组件<br>14、非父子组件通信。<br>15、slot分发内容。<br>16、动态组件，<keep-alive><component :is=""></component></keep-alive><br>参考：<a href="http://www.tuicool.com/articles/QJZRVj6" target="_blank" rel="noopener">[译]Vue 动态组件</a><br>17、子组件索引ref<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</span><br><span class="line">// 访问子组件</span><br><span class="line">var child = parent.$refs.profile</span><br></pre></td></tr></table></figure></p></blockquote><p>18、使用 v-once 的低级静态组件<br>19、列表过渡<transition-group>,tag,v-move<br><a href="http://www.365mini.com/page/jquery-event-stopimmediatepropagation.htm" target="_blank" rel="noopener">jQuery Event.stopImmediatePropagation() 函数详解</a></transition-group></p><blockquote><p>stopImmediatePropagation()函数用于阻止剩余的事件处理函数的执<br>行，并防止当前事件在DOM树上冒泡。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新仔细读了下文档，边看边写了一些。&lt;br&gt;1、v-once只渲染一次。&lt;br&gt;2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。&lt;br&gt;全局过滤器和单个过滤器。
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vuejs" scheme="https://lxchuan12.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结，毕业，工作</title>
    <link href="https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/"/>
    <id>https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/</id>
    <published>2017-01-07T13:40:38.000Z</published>
    <updated>2017-06-24T15:25:20.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。<a id="more"></a></p></blockquote><p>时间总是那么的快。2014年开始，就有了写个人年度总结的习惯。如果把2015年定义成<strong>PPT年</strong>，那么2016年则可以说是<strong>开发年</strong>。这一年相对比较平凡，还算满意。</p><p>2015年的年底，准备好了提前答辩的相关事宜。2016年元旦放假三天，在学校的课题组办公室翻看着微博（微博有时间轴，可以看到每个月都发了什么，这也就是为什么我比较喜欢发微博的原因之一），做着PPT，用思维导图工具Xmind，写着年度总结——<a href="http://user.qzone.qq.com/1019963719/blog/1451822274" target="_blank" rel="noopener">《2015年总结，淡化旧标签，无惧未来 》</a>。</p><p>翻看2016年的微博，看到大年初三的一条这样写着：</p><blockquote><p>猴年初三（2月10日），去舅舅家拜年。舅舅极力要求我在他家住，说以后工作了，忙着赚钱，更是没什么时间住了。舅妈以为我还是21岁……然而过完年，虚岁就是24岁了，其实明明是22岁半。好吧，确实老了。到了尴尬的年纪。按这样算，还有6年就30岁了……这六年要赚好多钱。</p></blockquote><p>最近听喜马拉雅付费精品中关于年度计划的，提到人生的8个方面,分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。于是根据这个把自己的2016年总结整理了一张思维导图和仿支付宝年账单做了一份年度总结PPT。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./img/xmind.png" alt="2016年度总结思维导图" title="">                </div>                <div class="image-caption">2016年度总结思维导图</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./img/ppt.jpg" alt="2016年度总结PPT" title="">                </div>                <div class="image-caption">2016年度总结PPT</div>            </figure></p><h3 id="未来的路在哪"><a href="#未来的路在哪" class="headerlink" title="未来的路在哪"></a>未来的路在哪</h3><p>1、看周围同事，基本就能看到自己几年后是过着怎样的生活。试想这样的生活是不是自己想要的，如果不是又将做什么来改变呢。老板有时给我们开会也会问：一个员工加入一家公司终究会离开，你是否会认真考虑【我会在这里干多少年？想成为什么样的人】。<br>2、再看看自己的校友，在移动互联网领域比较出名的有杜瑶，CSS参考手册作者（css.doyoe.com），去哪儿网前端技术总监。猎豹移动副总裁陈勇。柴魁元,乐动卓越科技有限公司CTO等等。<br>3、如果仅从开发这条路来看，很容易看到自己的天花板。而且业界都一致认为，程序员是吃青春饭，看自己身边同事就知道年长的非常少。G20放假那次回家，跟老爸聊天，老爸聊到年轻的时候赚点钱容易，年纪大了就不容易了。何况你这工作吃的是青春饭，以后怎么办。我说：到时候再看，转行吧。比如这篇文章：<a href="http://blog.csdn.net/harderxin/article/details/39210779" target="_blank" rel="noopener">一位工作十年程序员给的忠告</a></p><h3 id="打造个人品牌（知识型IP）"><a href="#打造个人品牌（知识型IP）" class="headerlink" title="打造个人品牌（知识型IP）"></a>打造个人品牌（知识型IP）</h3><p>《程序员必读的职业规划书》有提到打造个人品牌；公司年中大会上，我司创始人（前阿里副总裁）也谈到IP；参加的网红经济论坛上更是对网红（IP）有一些深层次的解读；《和秋叶一起学职场技能》书中也有提到如何打造个人品牌。<br>虽然，以前的积累，微博粉丝超过了1千，微信好友快1000，两个QQ的好友基本不重复，超过1400，但这些都是最低层次的无门槛自媒体。</p><p>我这名字，在我关注的圈子中，知道比较有名的大咖有小川叔。<br>在公司叫花名（轩辕），于是把我在网络上的各种账号的昵称统一成<strong>轩辕Rowboat</strong>，也算是打造个人品牌的开始吧。</p><p>2016年，这一年出现了很多<strong>知识变现</strong>的产品，比如：微信公众号打赏，简书打赏，知乎live，分答，在行，微博的问答，喜马拉雅付费精品等。</p><p>原是程序员的彭小六就凭借着知识变现这一红利月入6位数。比如：<br><a href="http://www.jianshu.com/p/7d053c85c0bd" target="_blank" rel="noopener">《凭着这3个字，我上个月挣了6位数》</a><br>也有程序员靠之前人气等多方面的积累，开一次知乎live，分享知识，就能赚1万+。<br>之前在公众号看到的文章，<a href="http://mp.weixin.qq.com/s?__biz=MzAxNzEyODA2NQ==&amp;mid=2650183908&amp;idx=1&amp;sn=8a1225cdef6acb0cf17eab426b3e899b&amp;chksm=83e8770ab49ffe1cb25da7c55158f078e7ef2921ea46805bb82845fe88fec85e04232f6f6364&amp;scene=0#rd" target="_blank" rel="noopener">《月入10W真的很难吗？》</a><br>清华大学毕业阿何的一篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzIwODM3MzU1NA==&amp;mid=2247483996&amp;idx=1&amp;sn=e0cb929d9ae282f23c1147e81c81c3fc&amp;chksm=97055001a072d9179d1bb5e1573269c4c4393ee8e347c74f88de08596ce0c2ac5fceb8163c35&amp;scene=0#rd" target="_blank" rel="noopener">《年轻人，如何挣到自己第一个100万？》</a><br>文尾总结：</p><blockquote><p>总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤：<br>第一：找到自己的一个特长，把它培养得足够出色<br>第二：找到适合你的特长，又有足够用户注意的平台<br>第三：在这个平台上深耕细作，打造品牌，获得收入<br>每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。</p></blockquote><p>虽然这类文章有点夸大其词，鸡汤文的感觉，但也不无道理。总之这是赚钱思维的一种转变。</p><p>PPT圈内，布衣公子从2012年开始分享自己的PPT作品，他的作品影响着很多人。后来收费，一份作品就能卖到上万元。这是他分享他的故事时分享的五个故事。<br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjQyODY1NA==&amp;mid=2654123389&amp;idx=1&amp;sn=2ccfddafe2502ae5a63c1ce6059afa50&amp;chksm=bd60727c8a17fb6a9e57e94be91decf921dc1778e0a38b32dadc8c5e8007fe6333895cd631b2&amp;scene=0#rd" target="_blank" rel="noopener">改变我命运的五个故事-布衣公子</a><br>要在大城市生活，培养一种或几种可以「变现」的能力，并且这些能力不受地域的限制，似乎变得重要起来。</p><h3 id="时间也是资源"><a href="#时间也是资源" class="headerlink" title="时间也是资源"></a>时间也是资源</h3><p>时间管理是永恒的话题，这篇文章写的挺好：<a href="http://weibo.com/ttarticle/p/show?id=2309404011377055416316" target="_blank" rel="noopener">毕业三年，你如何与同龄人拉开差距？</a></p><h3 id="世界发展太快，需要不断学习"><a href="#世界发展太快，需要不断学习" class="headerlink" title="世界发展太快，需要不断学习"></a>世界发展太快，需要不断学习</h3><p>世界在发展，以前的很多岗位都不存在了。而且未来很多工作可以由机器人来完成，而且机器人比人类做得更优秀。另外年轻人的接触新鲜事物的学习能力相对比较强。那么持续学习，变得更加的重要了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。
    
    </summary>
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的webstorm技巧</title>
    <link href="https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/"/>
    <id>https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/</id>
    <published>2016-12-07T14:48:18.000Z</published>
    <updated>2017-06-24T15:25:56.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>webstrom有一些基本的操作</strong><br>1、快速查找<br>2、代码补全<br>3、版本控制<br>4、本地历史<br>5、即时模板<br>6、光标<br>7、代码格式化等<br><a id="more"></a></p></blockquote><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>双击shift搜索：快速查找。文件，函数名等。</p><p>template模板可以设置。</p><p>光标定位到相关位置。比如tilte,body<br>每次修改的历史：local  history。</p><p>多光标的功能。<br>1、查找替换，ctrl+R<br>2、alt+鼠标选择。</p><p> 3、alt+单击。</p><p>4、格式化代码：ctrl+alt+L</p><p> 菜单，code——reformat code。</p><p>5、快捷键可以自定义设置。 可以通过快捷键名称来查找。也可以通过怎么使用来查找快捷键，然后对其进行修改。<br>webstrom预设了许多快捷键，可以自己选择。与原来的IDE快捷键相同。</p><h4 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a><strong>Emmet</strong></h4><p>详情参见：<br><a href="http://www.iteye.com/news/27580" target="_blank" rel="noopener">Emmet：HTML/CSS代码快速编写神器</a></p><p>1、Tab键，缩写的补全<br>2、li中间写完，按enter键，光标直接定位到接下来的一个。<br>3、嵌套结构：<br>>  +  ^      <em>  ()<br>子元素，同级，往上一级，重复，（）<br>4、属性<br># （id）. （类）[]自定义属性<br>div#container.container<br> $<br>ul&gt;li.item-$</em>5<br>{}文本<br>p{click me}<br>lorem没有意义的文字。用于排版。<br>用法：lorem100<br>注意事项：光标定位在最后（最想展开的）。<br>不能有空格。<br>比如：<br>css中，bt:border-top<br>m10:margin:10px;<br>m10-20:margin:10px 20px;<br>bdrs10:border-radius:10px;<br>df：display：flex;</p><p> 设置前缀。<br>默认关闭这个开关。可以用其他工具来实现。、<br>html:5,sublime text等编辑器可以安装emmet插件。</p><h4 id="进阶操作一——常见快捷键"><a href="#进阶操作一——常见快捷键" class="headerlink" title="进阶操作一——常见快捷键"></a>进阶操作一——常见快捷键</h4><p>操作，快捷键。</p><p>光标放在相对应的标签上，按F1，可以显示相关的描述，关联的站点等。<br>js也是如此，参数列表等。<br>比如</p><p></p><p>hello world</p><br>要包裹在一个div中，选择这代码，ctrl+alt+T,选择第一个，输入div就变包裹在div中。<p></p><p>——7<br>1、注释与取消注释<br>ctrl+/<br>2、选择<br>选中子元素，alt+上/下<br>3、粘贴<br>ctrl+shift+V，最近粘贴板中的内容。<br>4、删除当前行，<br>ctrl+退格键。<br>5、当前行上、下面加入一行<br>上面加入一行。ctrl+alt+enter<br>下面加入一行。ctrl+shift+enter.<br>这样不需要刻意定位光标的位置。其实键盘上有（home,end)键。<br>6、折叠代码，ctrl++（展开），ctrl+-(折叠)<br>ctrl+shift++,ctrl+shift+-,所有可以折叠的地方全部折叠。在css中，js,html中都是如此。<br>7、相邻位置代码换位置。<br>alt+shift+上、下键。选中一段代码也可以让其上下移动。<br>8、闭合标签，定位在两个标签位置。ctrl+m键。引号，括号，{}等也适用。window下好像无效。<br>9、前进、后退到上一次编辑的地方。ctrl+alt+左右键。<br>10、转到上一次编辑的地方。ctrl+shift+backspace键。<br>11、最近使用的文件，ctrl+E<br>——8<br>1、img标签，知道图片宽和高。<img src="">方式1、输入路径，宽和高，按住Tab键可以自动补全。<br>方式2、放在图片上，按F1图片预览，固定预览框。或者悬浮在文字上方。<br>方式3、按住shift，鼠标浮在路径上，就可以看到图片的预览了。<br>2、color:#999;色块上点击即可选择修改颜色。亮度（竖向）和透明度（横向）可以调节。</p><h4 id="进阶操作二——重命名"><a href="#进阶操作二——重命名" class="headerlink" title="进阶操作二——重命名"></a>进阶操作二——重命名</h4><p>1、重命名，</p><p></p><p>hello world</p>，把光标放在标签上，<br>ctrl+T,第一个就是重命名。window下试用无效。shift+F6重命名。2、其实直接写即可呀。<br>对话框会显示有相同的地方，右击，排查或包含include，exclude.点击执行，do refactor。侧边有一些功能。<br>2、函数名称，参数重命名。<br>html,css,js中都可以重命名，类名，颜色，可以预览，避免把一些框架库里的相同东西修改了。、<br>文件或文件夹也可以重命名。所有引用的地方也被修改了。<p></p><h4 id="进阶操作三——代码检查"><a href="#进阶操作三——代码检查" class="headerlink" title="进阶操作三——代码检查"></a>进阶操作三——代码检查</h4><p>webstrom使用了静态代码分析。<br>不仅检查编译错误，<br>而且代码效率低下，未使用的代码，非本地化的字符串，无法解析的代码，内存泄露，甚至编写问题等等。<br>提示分为：错误，警告和正确。红色，橙黄色，或者绿色。<br>一般来说是对整个项目进行检查的。也可以自己配置检查的范围。<br>也可以自己运行检查。–&gt;code-&gt;Inspect code</p><p>webstrom检查出来的不代表真的有错，还需要人工自己检查。<br>一般在文件中，F2键可以在各个错误中切换。<br>alt+enter，可以看到提示。（右侧的提示）<br>规则自己设置，搜索inspec</p><p>js是静态的校验。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;webstrom有一些基本的操作&lt;/strong&gt;&lt;br&gt;1、快速查找&lt;br&gt;2、代码补全&lt;br&gt;3、版本控制&lt;br&gt;4、本地历史&lt;br&gt;5、即时模板&lt;br&gt;6、光标&lt;br&gt;7、代码格式化等&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="https://lxchuan12.github.io/categories/tool/"/>
    
    
      <category term="tool" scheme="https://lxchuan12.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="https://lxchuan12.github.io/2016/11/20/20161120-about%20me/"/>
    <id>https://lxchuan12.github.io/2016/11/20/20161120-about me/</id>
    <published>2016-11-20T14:36:52.000Z</published>
    <updated>2018-06-23T14:45:32.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚<code>PPT爱好者</code>。所知甚少，唯善学。常以<code>轩辕Rowboat</code>为名混迹于江湖。</p><h3 id="轩辕Rowboat由来"><a href="#轩辕Rowboat由来" class="headerlink" title="轩辕Rowboat由来"></a>轩辕Rowboat由来</h3><p><strong>轩辕Rowboat</strong>由来：轩辕(之前公司花名)。<code>Rowboat</code>，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），剑未佩妥，出门便是江湖。</p><h3 id="家乡"><a href="#家乡" class="headerlink" title="家乡"></a>家乡</h3><p>在很久很久以前，盘古开天辟地之时，后来…不知道经过了多少年。<strong>轩辕Rowboat</strong>，出生于<code>江西吉安</code>欧阳修故里的一个贫困的小山村，究竟有多贫困呢，各地贫困指数不一，就不得而知了。你们只需要知道小马云，就是来自我们的小县城上的一个镇上。百度百科词条：<a href="https://baike.baidu.com/item/%E8%8C%83%E5%B0%8F%E5%8B%A4/20198128?fr=aladdin&amp;fromid=20199280&amp;fromtitle=%E5%B0%8F%E9%A9%AC%E4%BA%91" target="_blank" rel="noopener">小马云</a></p><h3 id="怎么走上前端路的"><a href="#怎么走上前端路的" class="headerlink" title="怎么走上前端路的"></a>怎么走上前端路的</h3><p>再后来，我一不小心来到了某世界闻名的<code>陶瓷大学</code>拜师学艺，当然可想而知，没有学闻名于世界的陶瓷相关技艺。拜师学艺期间，遇见两位”师傅”，和其他两名弟子一同学习<code>PHP+MySql</code>，从此开始了我的<code>Web开发</code>学习之路，也有一些成果。机缘巧合，拉了两个山派（社团），再一不小心玩起了<code>PPT</code>，后来发现自己更加喜欢前端，期间又听说有个叫网易的招收<code>前端开发微专业</code>三期弟子，于是走向了这条漫漫前端路。<br>一眨眼，四年过去了。<code>2016年</code>，下山来到了杭州闯江湖。深知时代在迅速发展，需不断学习。<br>欲知更多详情请让鼠标走两步，看此文<a href="https://lxchuan12.github.io/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/">我是如何踏上前端这条路的</a>。</p><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lxchuan12.github.io/2017/06/02/20170602-After%20a%20year%27s%20work,%20I%20had%20some%20insights/zsxq.png" alt="知识星球【**前端视野**】二维码，欢迎扫码免费加入" title="">                </div>                <div class="image-caption">知识星球【**前端视野**】二维码，欢迎扫码免费加入</div>            </figure><p>同时也建了一个微信群【前端视野交流群】，欢迎加入（可以加我微信好友，拉您进群）。</p><p>主要发表一些前端所见所想，<code>Vue</code>、<code>React</code>、构建工具(比如：<code>gulp</code>、<code>webpack</code>)、设计模式等。一个人走得快，一群人走得远。</p><p>为啥要创建这个呢，可以查看这篇文章<a href="http://lxchuan12.github.io/2017/06/02/20170602-After%20a%20year&#39;s%20work,%20I%20had%20some%20insights/">工作一年后，我有些感悟</a>，同行大概都会有类似感慨。</p><p>同时建有一个微信交流群。(2019-06-20更新)<br>欢迎加入。</p><p><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault社区</a>，偶尔在<code>SF社区</code>答题，虽然目前只有少得可怜的<code>2.4K</code>声望(2018-05-27更新)。<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，没有star过百，特别有价值的项目，不过有些可能有点价值，你可以瞧瞧。<br><a href="http://www.jianshu.com/u/83129d433d72" target="_blank" rel="noopener">简书</a>，偶尔在简书上写写文章。<br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a>，偶尔逛逛知乎，看帖基本不回帖。<br><a href="https://weibo.com/lxchuan12" target="_blank" rel="noopener">微博</a>，偶尔在微博上更新日常。<br>微信嘛，很显然，一般人不会加我，但万一不是一般人呢，还是写下微信号<code>lxchuan12</code>和放下微信二维码，加友记得注明来源于博客。<br><img src="/2016/11/20/20161120-about%20me/wechat.png" title="扫一扫，加我微信，欢迎交流"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚&lt;code&gt;PPT爱好者&lt;/code&gt;。所知甚少，唯善学。常以&lt;c
      
    
    </summary>
    
      <category term="关于我" scheme="https://lxchuan12.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
    
      <category term="关于我" scheme="https://lxchuan12.github.io/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
</feed>
