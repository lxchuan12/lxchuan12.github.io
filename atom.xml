<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轩辕Rowboat的博客</title>
  <subtitle>前端路上 | PPT爱好者 | 所知甚少，唯善学。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxchuan12.github.io/"/>
  <updated>2017-09-21T15:44:17.403Z</updated>
  <id>https://lxchuan12.github.io/</id>
  
  <author>
    <name>轩辕Rowboat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github使用小技巧</title>
    <link href="https://lxchuan12.github.io/2017/09/21/20170921-github%20tips/"/>
    <id>https://lxchuan12.github.io/2017/09/21/20170921-github tips/</id>
    <published>2017-09-21T15:15:52.000Z</published>
    <updated>2017-09-21T15:44:17.403Z</updated>
    
    <content type="html"><![CDATA[<p>大多数开发者都有github账号，但github这些日常小技巧估计不知道。<br>1、<a href="https://github.com/explore/subscribe" target="_blank" rel="external">subscribe订阅github周报，每周会把你关注的开发语言和关注的人的动态等发邮件给你：</a><br><a href="https://github.com/trending" target="_blank" rel="external">每天github的热点</a><br>2、快捷键：在github某个项目面板（页面），按shift+?，可以看到所有支持的快捷键。<br>其中常用的主要有。</p>
<blockquote>
<p>T，搜索文件<br>S:定位到搜索输入框<br>GC:跳转到code面板<br>GI:跳转到issue面板<br>GP:跳转到 pull request面板<br>GW:跳转到 Wiki<br>搜索issue和pull request时可以使用过滤器。比如：is:open<br>回答输入时，可以用#号来匹配相应的issue.<br>3、Code Line<br>可以标注一些代码。按住shift,选择行号。对应的代码就高亮了。对应链接加上了hash#L1-L21<br>4、<a href="https://github.com/buunguyen/octotree" target="_blank" rel="external">octotree chrome插件github</a>可以像编辑器目录文件形式。<br><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="external">octotree chrome插件地址</a><br>如果翻墙苦难，可以直接下载dist目录下chrome.crx，拖拽到chrome浏览器插件即可安装。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数开发者都有github账号，但github这些日常小技巧估计不知道。&lt;br&gt;1、&lt;a href=&quot;https://github.com/explore/subscribe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;subscribe订阅githu
    
    </summary>
    
      <category term="github" scheme="https://lxchuan12.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://lxchuan12.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象所有API解析</title>
    <link href="https://lxchuan12.github.io/2017/08/17/20170817-Object%20API/"/>
    <id>https://lxchuan12.github.io/2017/08/17/20170817-Object API/</id>
    <published>2017-08-17T15:51:52.000Z</published>
    <updated>2017-08-31T13:47:58.430Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000010753942" target="_blank" rel="external">首发于segmentfault:JavaScript 对象所有API解析</a></p>
<blockquote>
<p>之前看到<a href="http://louiszhai.github.io/2017/04/28/array/" target="_blank" rel="external">【深度长文】JavaScript数组所有API全解密</a>和<a href="http://louiszhai.github.io/2016/01/12/js.String/" target="_blank" rel="external">JavaScript字符串所有API全解密</a>这两篇高质量的文章。发现没写对象API解析（估计是博主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。</p>
</blockquote>
<p>创建对象的两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">var o = &#123;&#125;; // 推荐</div></pre></td></tr></table></figure></p>
<p>该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = new Object(&apos;something&apos;);</div><div class="line">o.constructor; // ƒ String() &#123; [native code] &#125;</div><div class="line">var n = new Object(123);</div><div class="line">n.constructor; // ƒ Number() &#123; [native code] &#125;</div></pre></td></tr></table></figure></p>
<h2 id="一、Object构造器的成员"><a href="#一、Object构造器的成员" class="headerlink" title="一、Object构造器的成员"></a>一、Object构造器的成员</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>该属性是所有对象的原型（包括 <code>Object</code>对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s = new String(&apos;xuanyuan&apos;);</div><div class="line">Object.prototype.custom = 1;</div><div class="line">console.log(s.custom); // 1</div></pre></td></tr></table></figure></p>
<h2 id="二、Object-prototype-的成员"><a href="#二、Object-prototype-的成员" class="headerlink" title="二、Object.prototype 的成员"></a>二、Object.prototype 的成员</h2><h3 id="Object-prototype-constructor"><a href="#Object-prototype-constructor" class="headerlink" title="Object.prototype.constructor"></a>Object.prototype.constructor</h3><p>该属性指向用来构造该函数对象的构造器，在这里为<code>Object()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object.prototype.constructor === Object; // true</div><div class="line">var o = new Object();</div><div class="line">o.constructor === Object; // true</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-toString-radix"><a href="#Object-prototype-toString-radix" class="headerlink" title="Object.prototype.toString(radix)"></a>Object.prototype.toString(radix)</h3><p>该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数<code>radix</code>，该参数<code>radix</code>，该参数的默认值为10。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;prop:1&#125;;</div><div class="line">o.toString(); // &apos;[object object]&apos;</div><div class="line">var n = new Number(255);</div><div class="line">n.toString(); // &apos;255&apos;</div><div class="line">n.toString(16); // &apos;ff&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p>该方法的作用与<code>toString()</code>基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如<code>Date()</code>,<code>Number()</code>,<code>Array()</code>,它们的值都会以本地化的形式输出。当然，对于包括<code>Object()</code>在内的其他大多数对象来说，该方法与<code>toString()</code>是基本相同的。<br>在浏览器环境下，可以通过<code>BOM</code>对象<code>Navigator</code>的<code>language</code>属性（在<code>IE</code>中则是<code>userLanguage</code>）来了解当前所使用的语言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">navigator.language; //&apos;en-US&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p>该方法返回的是用基本类型所表示的<code>this</code>值，如果它可以用基本类型表示的话。如果<code>Number</code>对象返回的是它的基本数值，而<code>Date</code>对象返回的是一个时间戳（<code>timestamp</code>）。如果无法用基本数据类型表示，该方法会返回<code>this</code>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Object</div><div class="line">var o = &#123;&#125;;</div><div class="line">typeof o.valueOf(); // &apos;object&apos;</div><div class="line">o.valueOf() === o; // true</div><div class="line">// Number</div><div class="line">var n = new Number(101);</div><div class="line">typeof n; // &apos;object&apos;</div><div class="line">typeof n.vauleOf; // &apos;function&apos;</div><div class="line">typeof n.valueOf(); // &apos;number&apos;</div><div class="line">n.valueOf() === n; // false</div><div class="line">// Date</div><div class="line">var d = new Date();</div><div class="line">typeof d.valueOf(); // &apos;number&apos;</div><div class="line">d.valueOf(); // 1503146772355</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-hasOwnProperty-prop"><a href="#Object-prototype-hasOwnProperty-prop" class="headerlink" title="Object.prototype.hasOwnProperty(prop)"></a>Object.prototype.hasOwnProperty(prop)</h3><p>该方法仅在目标属性为对象自身属性时返回<code>true</code>,而当该属性是从原型链中继承而来或根本不存在时，返回<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123;prop:1&#125;;</div><div class="line">o.hasOwnProperty(&apos;prop&apos;); // true</div><div class="line">o.hasOwnProperty(&apos;toString&apos;); // false</div><div class="line">o.hasOwnProperty(&apos;formString&apos;); // false</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-isPrototypeOf-obj"><a href="#Object-prototype-isPrototypeOf-obj" class="headerlink" title="Object.prototype.isPrototypeOf(obj)"></a>Object.prototype.isPrototypeOf(obj)</h3><p>如果目标对象是当前对象的原型，该方法就会返回<code>true</code>，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = new String(&apos;&apos;);</div><div class="line">Object.prototype.isPrototypeOf(s); // true</div><div class="line">String.prototype.isPrototypeOf(s); // true</div><div class="line">Array.prototype.isPrototypeOf(s); // false</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-propertyIsEnumerable-prop"><a href="#Object-prototype-propertyIsEnumerable-prop" class="headerlink" title="Object.prototype.propertyIsEnumerable(prop)"></a>Object.prototype.propertyIsEnumerable(prop)</h3><p>如果目标属性能在<code>for in</code>循环中被显示出来，该方法就返回<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [1,2,3];</div><div class="line">a.propertyIsEnumerable(&apos;length&apos;); // false</div><div class="line">a.propertyIsEnumerable(0); // true</div></pre></td></tr></table></figure></p>
<h2 id="三、在ES5中附加的Object属性"><a href="#三、在ES5中附加的Object属性" class="headerlink" title="三、在ES5中附加的Object属性"></a>三、在<code>ES5</code>中附加的<code>Object</code>属性</h2><p>在<code>ES3</code>中，除了一些内置属性（如：<code>Math.PI</code>），对象的所有的属性在任何时候都可以被修改、插入、删除。在<code>ES5</code>中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。<code>ES5</code>中引入了<strong>属性描述符</strong>的概念，我们可以通过它对所定义的属性有更大的控制权。这些<strong>属性描述符</strong>（特性）包括：</p>
<blockquote>
<p><code>value</code>——当试图获取属性时所返回的值。<br><code>writable</code>——该属性是否可写。<br><code>enumerable</code>——该属性在<code>for in</code>循环中是否会被枚举<br><code>configurable</code>——该属性是否可被删除。<br><code>set()</code>——该属性的更新操作所调用的函数。<br><code>get()</code>——获取属性值时所调用的函数。<br>另外，<strong>数据描述符</strong>（其中属性为：<code>enumerable</code>，<code>configurable</code>，<code>value</code>，<code>writable</code>）与<strong>存取描述符</strong>（其中属性为<code>enumerable</code>，<code>configurable</code>，<code>set()</code>，<code>get()</code>）之间是有互斥关系的。在定义了<code>set()</code>和<code>get()</code>之后，描述符会认为存取操作已被 定义了，其中再定义<code>value</code>和<code>writable</code>会<strong>引起错误</strong>。<br>以下是<em>ES3</em>风格的属性定义方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">person.legs = 2;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>以下是等价的ES5通过<strong>数据描述符</strong>定义属性的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</div><div class="line">    value: 2,</div><div class="line">    writable: true,</div><div class="line">    configurable: true,</div><div class="line">    enumerable: true</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其中， 除了value的默认值为<code>undefined</code>以外，其他的默认值都为<code>false</code>。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为<code>true</code>。<br>或者，我们也可以通过<code>ES5</code>的存储描述符来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</div><div class="line">    set:function(v) &#123;</div><div class="line">        return this.value = v;</div><div class="line">    &#125;,</div><div class="line">    get: function(v) &#123;</div><div class="line">        return this.value;</div><div class="line">    &#125;,</div><div class="line">    configurable: true,</div><div class="line">    enumerable: true</div><div class="line">&#125;);</div><div class="line">person.legs = 2;</div></pre></td></tr></table></figure></p>
<p>这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容<code>ES3</code>方面所做的考虑。例如，跟添加<code>Array.prototype</code>属性不一样，我们不能再旧版的浏览器中使用<code>shim</code>这一特性。<br>另外，我们还可以（通过定义<code>nonmalleable</code>属性），在具体行为中运用这些描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &apos;heads&apos;, &#123;value: 1&#125;);</div><div class="line">person.heads = 0; // 0</div><div class="line">person.heads; // 1  (改不了)</div><div class="line">delete person.heads; // false</div><div class="line">person.heads // 1 (删不掉)</div></pre></td></tr></table></figure></p>
<h3 id="Object-defineProperty-obj-prop-descriptor-ES5"><a href="#Object-defineProperty-obj-prop-descriptor-ES5" class="headerlink" title="Object.defineProperty(obj, prop, descriptor) (ES5)"></a>Object.defineProperty(obj, prop, descriptor) (ES5)</h3><p>具体用法可参见上文，或者查看MDN。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">MDN Object.defineProperty(obj, descriptor)</a></p>
<blockquote>
<p>Vue.js文档：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external"><strong>如何追踪变化</strong></a> 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<h3 id="Object-defineProperties-obj-props-ES5"><a href="#Object-defineProperties-obj-props-ES5" class="headerlink" title="Object.defineProperties(obj, props) (ES5)"></a>Object.defineProperties(obj, props) (ES5)</h3><p>该方法的作用与<code>defineProperty()</code>基本相同，只不过它可以用来一次定义多个属性。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var glass = Object.defineProperties(&#123;&#125;, &#123;</div><div class="line">    &apos;color&apos;: &#123;</div><div class="line">        value: &apos;transparent&apos;,</div><div class="line">        writable: true</div><div class="line">    &#125;,</div><div class="line">    &apos;fullness&apos;: &#123;</div><div class="line">        value: &apos;half&apos;,</div><div class="line">        writable: false</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">glass.fullness; // &apos;half&apos;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Object-getPrototypeOf-obj-ES5"><a href="#Object-getPrototypeOf-obj-ES5" class="headerlink" title="Object.getPrototypeOf(obj) (ES5)"></a>Object.getPrototypeOf(obj) (ES5)</h3><p>之前在<code>ES3</code>中，我们往往需要通过<code>Object.prototype.isPrototypeOf()</code>去猜测某个给定的对象的原型是什么，如今在<code>ES5</code>中，我们可以直接询问改对象“你的原型是什么？”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf([]) === Array.prototype; // true</div><div class="line">Object.getPrototypeOf(Array.prototype) === Object.prototype; // true</div><div class="line">Object.getPrototypeOf(Object.prototype) === null; // true</div></pre></td></tr></table></figure></p>
<h3 id="Object-create-obj-descr-ES5"><a href="#Object-create-obj-descr-ES5" class="headerlink" title="Object.create(obj, descr) (ES5)"></a>Object.create(obj, descr) (ES5)</h3><p>该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var parent = &#123;hi: &apos;Hello&apos;&#125;;</div><div class="line">var o = Object.create(parent, &#123;</div><div class="line">    prop: &#123;</div><div class="line">        value: 1</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">o.hi; // &apos;Hello&apos;</div><div class="line">// 获得它的原型</div><div class="line">Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototype</div><div class="line">Object.getPrototypeOf(o); // &#123;hi: &quot;Hello&quot;&#125; // 说明o的原型是&#123;hi: &quot;Hello&quot;&#125;</div><div class="line">o.hasOwnProperty(&apos;hi&apos;); // false 说明hi是原型上的</div><div class="line">o.hasOwnProperty(&apos;prop&apos;); // true 说明prop是原型上的自身上的属性。</div></pre></td></tr></table></figure></p>
<p>现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在<code>ES3</code>中可是做不到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var o = Object.create(null);</div><div class="line">typeof o.toString(); // &apos;undefined&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertyDesciptor-obj-property-ES5"><a href="#Object-getOwnPropertyDesciptor-obj-property-ES5" class="headerlink" title="Object.getOwnPropertyDesciptor(obj, property) (ES5)"></a>Object.getOwnPropertyDesciptor(obj, property) (ES5)</h3><p>该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</div><div class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertyNames-obj-ES5"><a href="#Object-getOwnPropertyNames-obj-ES5" class="headerlink" title="Object.getOwnPropertyNames(obj) (ES5)"></a>Object.getOwnPropertyNames(obj) (ES5)</h3><p>该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用<code>Object.keys()</code>来单独返回可枚举的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(Object.prototype);</div><div class="line">// [&quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;]</div><div class="line">Object.keys(Object.prototype);</div><div class="line">// []</div><div class="line">Object.getOwnPropertyNames(Object);</div><div class="line">// [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;prototype&quot;, &quot;assign&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getOwnPropertyDescriptors&quot;, &quot;getOwnPropertyNames&quot;, &quot;getOwnPropertySymbols&quot;, &quot;is&quot;, &quot;preventExtensions&quot;, &quot;seal&quot;, &quot;create&quot;, &quot;defineProperties&quot;, &quot;defineProperty&quot;, &quot;freeze&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;isFrozen&quot;, &quot;isSealed&quot;, &quot;keys&quot;, &quot;entries&quot;, &quot;values&quot;]</div><div class="line">Object.keys(Object);</div><div class="line">// []</div></pre></td></tr></table></figure></p>
<h3 id="Object-preventExtensions-obj-ES5"><a href="#Object-preventExtensions-obj-ES5" class="headerlink" title="Object.preventExtensions(obj) (ES5)"></a>Object.preventExtensions(obj) (ES5)</h3><h3 id="Object-isExtensible-obj-ES5"><a href="#Object-isExtensible-obj-ES5" class="headerlink" title="Object.isExtensible(obj) (ES5)"></a>Object.isExtensible(obj) (ES5)</h3><p><code>preventExtensions()</code>方法用于禁止向某一对象添加更多属性，而<code>isExtensible()</code>方法则用于检查某对象是否还可以被添加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var deadline = &#123;&#125;;</div><div class="line">Object.isExtensible(deadline); // true</div><div class="line">deadline.date = &apos;yesterday&apos;; // &apos;yesterday&apos;</div><div class="line">Object.preventExtensions(deadline);</div><div class="line">Object.isExtensible(deadline); // false</div><div class="line">deadline.date = &apos;today&apos;;</div><div class="line">deadline.date; // &apos;today&apos;</div><div class="line">// 尽管向某个不可扩展的对象中添加属性不算是一个错误操作，但它没有任何作用。</div><div class="line">deadline.report = true;</div><div class="line">deadline.report; // undefined</div></pre></td></tr></table></figure></p>
<h3 id="Object-seal-obj-ES5"><a href="#Object-seal-obj-ES5" class="headerlink" title="Object.seal(obj) (ES5)"></a>Object.seal(obj) (ES5)</h3><h3 id="Object-isSeal-obj-ES5"><a href="#Object-isSeal-obj-ES5" class="headerlink" title="Object.isSeal(obj) (ES5)"></a>Object.isSeal(obj) (ES5)</h3><p><code>seal()</code>方法可以让一个对象密封，并返回被密封后的对象。<br><code>seal()</code>方法的作用与<code>preventExtensions()</code>基本相同，但除此之外，它还会将现有属性<br>设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用<code>defineProperty()</code>）重新配置这些属性，例如不能将一个可枚举的属性改成不可枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;legs:2&#125;;</div><div class="line">// person === Object.seal(person); // true</div><div class="line">Object.isSealed(person); // true</div><div class="line">Object.getOwnPropertyDescriptor(person, &apos;legs&apos;);</div><div class="line">// &#123;value: 2, writable: true, enumerable: true, configurable: false&#125;</div><div class="line">delete person.legs; // false (不可删除，不可配置)</div><div class="line">Object.defineProperty(person, &apos;legs&apos;,&#123;value:2&#125;);</div><div class="line">person.legs; // 2</div><div class="line">person.legs = 1;</div><div class="line">person.legs; // 1 (可写)</div><div class="line">Object.defineProperty(person, &quot;legs&quot;, &#123; get: function() &#123; return &quot;legs&quot;; &#125; &#125;);</div><div class="line">// 抛出TypeError异常</div></pre></td></tr></table></figure></p>
<h3 id="Object-freeze-obj-ES5"><a href="#Object-freeze-obj-ES5" class="headerlink" title="Object.freeze(obj) (ES5)"></a>Object.freeze(obj) (ES5)</h3><h3 id="Object-isFrozen-obj-ES5"><a href="#Object-isFrozen-obj-ES5" class="headerlink" title="Object.isFrozen(obj) (ES5)"></a>Object.isFrozen(obj) (ES5)</h3><p><code>freeze()</code>方法用于执行一切不受<code>seal()</code>方法限制的属性值变更。<code>Object.freeze()</code> 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var deadline = Object.freeze(&#123;date: &apos;yesterday&apos;&#125;);</div><div class="line">deadline.date = &apos;tomorrow&apos;;</div><div class="line">deadline.excuse = &apos;lame&apos;;</div><div class="line">deadline.date; // &apos;yesterday&apos;</div><div class="line">deadline.excuse; // undefined</div><div class="line">Object.isSealed(deadline); // true;</div><div class="line">Object.isFrozen(deadline); // true</div><div class="line">Object.getOwnPropertyDescriptor(deadline, &apos;date&apos;);</div><div class="line">// &#123;value: &quot;yesterday&quot;, writable: false, enumerable: true, configurable: false&#125; (不可配置，不可写)</div><div class="line">Object.keys(deadline); // [&apos;date&apos;] (可枚举)</div></pre></td></tr></table></figure></p>
<h3 id="Object-keys-obj-ES5"><a href="#Object-keys-obj-ES5" class="headerlink" title="Object.keys(obj) (ES5)"></a>Object.keys(obj) (ES5)</h3><p>该方法是一种特殊的<code>for-in</code>循环。它只返回当前对象的属性（不像<code>for-in</code>），而且这些属性也必须是可枚举的（这点和<code>Object.getOwnPropertyNames()</code>不同，不论是否可以枚举）。返回值是一个字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.prototype.customProto = 101;</div><div class="line">Object.getOwnPropertyNames(Object.prototype);</div><div class="line">// [..., &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;, &quot;customProto&quot;]</div><div class="line">Object.keys(Object.prototype); // [&apos;customProto&apos;]</div><div class="line">var o = &#123;own: 202&#125;;</div><div class="line">o.customProto; // 101</div><div class="line">Object.keys(o); // [&apos;own&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="四、在ES6中附加的Object属性"><a href="#四、在ES6中附加的Object属性" class="headerlink" title="四、在ES6中附加的Object属性"></a>四、在<code>ES6</code>中附加的<code>Object</code>属性</h3><h3 id="Object-is-value1-value2-ES6"><a href="#Object-is-value1-value2-ES6" class="headerlink" title="Object.is(value1, value2) (ES6)"></a>Object.is(value1, value2) (ES6)</h3><p>该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。<br>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，而是<code>NaN</code>等于自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.is(&apos;xuanyuan&apos;, &apos;xuanyuan&apos;); // true</div><div class="line">Object.is(&#123;&#125;,&#123;&#125;); // false</div><div class="line">Object.is(+0, -0); // false</div><div class="line">+0 === -0; // true</div><div class="line">Object.is(NaN, NaN); // true</div><div class="line">NaN === NaN; // false</div></pre></td></tr></table></figure></p>
<p><code>ES5</code>可以通过以下代码部署<code>Object.is</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</div><div class="line">    value: function() &#123;x, y&#125; &#123;</div><div class="line">        if (x === y) &#123;</div><div class="line">           // 针对+0不等于-0的情况</div><div class="line">           return x !== 0 || 1 / x === 1 / y;</div><div class="line">        &#125;</div><div class="line">        // 针对 NaN的情况</div><div class="line">        return x !== x &amp;&amp; y !== y;</div><div class="line">    &#125;,</div><div class="line">    configurable: true,</div><div class="line">    enumerable: false,</div><div class="line">    writable: true</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Object-assign-target-…sources-ES6"><a href="#Object-assign-target-…sources-ES6" class="headerlink" title="Object.assign(target, …sources) (ES6)"></a>Object.assign(target, …sources) (ES6)</h3><p>该方法用来源对象（<code>source</code>）的所有可枚举的属性复制到目标对象（<code>target</code>）。它至少需要两个对象作为参数，第一个参数是目标对象<code>target</code>，后面的参数都是源对象（<code>source</code>）。只有一个参数不是对象，就会抛出<code>TypeError</code>错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var target = &#123;a: 1&#125;;</div><div class="line">var source1 = &#123;b: 2&#125;;</div><div class="line">var source2 = &#123;c: 3&#125;;</div><div class="line">obj = Object.assign(target, source1, source2);</div><div class="line">target; // &#123;a:1,b:2,c:3&#125;</div><div class="line">obj; // &#123;a:1,b:2,c:3&#125;</div><div class="line">target === obj; // true</div><div class="line">// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</div><div class="line">var source3 = &#123;a:2,b:3,c:4&#125;;</div><div class="line">Object.assign(target, source3);</div><div class="line">target; // &#123;a:2,b:3,c:4&#125;</div></pre></td></tr></table></figure></p>
<p><code>Object.assign</code>只复制自身属性，不可枚举的属性（<code>enumerable</code>为<code>false</code>）和继承的属性不会被复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;b: &apos;c&apos;&#125;, </div><div class="line">    Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123;</div><div class="line">        enumerable: false,</div><div class="line">        value: &apos;hello&apos;</div><div class="line">    &#125;)</div><div class="line">);</div><div class="line">// &#123;b: &apos;c&apos;&#125;</div></pre></td></tr></table></figure></p>
<p>属性名为<code>Symbol</code>值的属性，也会被<code>Object.assign()</code>复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;a: &apos;b&apos;&#125;, &#123;[Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</div><div class="line">// &#123;a: &apos;b&apos;, Symbol(c): &apos;d&apos;&#125;</div></pre></td></tr></table></figure></p>
<p>对于嵌套的对象，<code>Object.assign()</code>的处理方法是替换，而不是添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;a: &#123;b:&apos;c&apos;,d:&apos;e&apos;&#125;&#125;, &#123;a:&#123;b:&apos;hello&apos;&#125;&#125;);</div><div class="line">// &#123;a: &#123;b:&apos;hello&apos;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>对于数组，<code>Object.assign()</code>把数组视为属性名为0、1、2的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.assign([1,2,3], [4,5]);</div><div class="line">// [4,5,3]</div></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertySymbols-obj-ES6"><a href="#Object-getOwnPropertySymbols-obj-ES6" class="headerlink" title="Object.getOwnPropertySymbols(obj) (ES6)"></a>Object.getOwnPropertySymbols(obj) (ES6)</h3><p>该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 <code>symbol</code> 属性键。<br>该方法和 <code>Object.getOwnPropertyNames()</code> 类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(&#123;a: &apos;b&apos;, [Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</div><div class="line">// [Symbol(c)]</div></pre></td></tr></table></figure></p>
<h3 id="Object-setPrototypeOf-obj-prototype-ES6"><a href="#Object-setPrototypeOf-obj-prototype-ES6" class="headerlink" title="Object.setPrototypeOf(obj, prototype) (ES6)"></a>Object.setPrototypeOf(obj, prototype) (ES6)</h3><p>该方法设置一个指定的对象的原型 ( 即, 内部<code>[[Prototype]]</code>属性）到另一个对象或  <code>null</code>。<br><code>__proto__</code>属性用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括<code>IE11</code>）都部署了这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// ES6写法</div><div class="line">var obj = &#123;</div><div class="line">    method: function()&#123;</div><div class="line">        // code ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// obj.__proto__ = someOtherObj;</div><div class="line">// ES5写法</div><div class="line">var obj = Object.create(someOtherObj);</div><div class="line">obj.method = function()&#123;</div><div class="line">    // code ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>该属性没有写入<code>ES6</code>的正文，而是写入了附录。<code>__proto__</code>前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。而是使用<code>Object.setPrototypeOf()</code>（写操作），<code>Object.getPrototypeOf()</code>（读操作），或<code>Object.create()</code>（生成操作）代替。<br>在实现上，<code>__proto__</code>调用的<code>Object.prototype.__proto__</code>。<br><code>Object.setPrototypeOf()</code>方法的作用与<code>__proto__</code>作用相同，用于设置一个对象的<code>prototype</code>对象。它是<code>ES6</code>正式推荐的设置原型对象的方法。</p>
<h2 id="五、在ES8中附加的Object属性"><a href="#五、在ES8中附加的Object属性" class="headerlink" title="五、在ES8中附加的Object属性"></a>五、在<code>ES8</code>中附加的<code>Object</code>属性</h2><h3 id="Object-getOwnPropertyDescriptors-obj-ES8"><a href="#Object-getOwnPropertyDescriptors-obj-ES8" class="headerlink" title="Object.getOwnPropertyDescriptors(obj) (ES8)"></a>Object.getOwnPropertyDescriptors(obj) (ES8)</h3><p>该方法基本与<code>Object.getOwnPropertyDescriptor(obj, property)</code>用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</div><div class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</div><div class="line">Object.getOwnPropertyDescriptors(Object.prototype); // 可以自行在浏览器控制台查看效果。</div></pre></td></tr></table></figure></p>
<h3 id="Object-values-obj-ES8"><a href="#Object-values-obj-ES8" class="headerlink" title="Object.values(obj) (ES8)"></a>Object.values(obj) (ES8)</h3><p><code>Object.values()</code> 方法与<code>Object.keys</code>类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用<code>for...in</code>循环的顺序相同 ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a:1,b:2,c:3&#125;;</div><div class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div><div class="line">Object.values(obj); // [1,2,3]</div></pre></td></tr></table></figure></p>
<h3 id="Object-entries-obj-ES8"><a href="#Object-entries-obj-ES8" class="headerlink" title="Object.entries(obj) (ES8)"></a>Object.entries(obj) (ES8)</h3><p><code>Object.entries()</code> 方法返回一个给定对象自己的可枚举属性<code>[key，value]</code>对的数组，数组中键值对的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致（区别在于一个<code>for-in</code>循环也枚举原型链中的属性）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a:1,b:2,c:3&#125;;</div><div class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div><div class="line">Object.values(obj); // [1,2,3]</div><div class="line">Object.entries(obj); // [[&apos;a&apos;,1],[&apos;b&apos;,2],[&apos;c&apos;,3]]</div></pre></td></tr></table></figure></p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>您可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有<code>Object.prototype.toString()</code>，<code>Object.prototype.hasOwnProperty()</code>， <code>Object.getPrototypeOf(obj)</code>，<code>Object.create()</code>，<code>Object.defineProperty</code>，<code>Object.keys(obj)</code>，<code>Object.assign()</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">MDN Object API</a><br><a href="https://book.douban.com/subject/26302623/" target="_blank" rel="external">JavaScript面向对象编程指南（第2版）（豆瓣读书链接）</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰 ES6标准入门2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010753942&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;首发于segmentfault:JavaScript 对象所有API解析&lt;/a&gt;&lt;/p&gt;
&lt;blockq
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 语言精粹 修订版》 读书笔记</title>
    <link href="https://lxchuan12.github.io/2017/07/23/20170723-JavaScript%20essence%20of%20reading%20notes/"/>
    <id>https://lxchuan12.github.io/2017/07/23/20170723-JavaScript essence of reading notes/</id>
    <published>2017-07-23T14:23:52.000Z</published>
    <updated>2017-08-12T16:04:49.535Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000010313101" target="_blank" rel="external">首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记</a></p>
<blockquote>
<p>之前看到这篇文章，<a href="https://zhuanlan.zhihu.com/p/23265155?refer=dreawer" target="_blank" rel="external">前端网老姚浅谈：怎么学JavaScript？</a>，说到怎么学习JavaScript，那就是<strong>看书、分析源码。</strong><br><strong>10本书读2遍的好处，应该大于一本书读20遍。</strong><br><strong>看书主动学习，看视频是被动学习。</strong><br><strong>看书和分析源码的时机</strong>。但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来学习，那&gt;肯定是必须的，工作本身就是一个学习的过程。<br><strong>怎么把一本书看完呢？</strong>很简单，敲。文字加代码都敲。<br>比较认同老姚的说法。去年毕业到现在，我也算是工作一年了，是时候看书查缺补漏了。</p>
</blockquote>
<p>于是我就先把这本薄的经典书《JavaScript语言精粹 修订版》<a href="https://book.douban.com/subject/11874748/" target="_blank" rel="external">豆瓣读书本书简介</a>（总共10章，除去附录，才100页），读完并记录了一些笔记。基本算是摘抄书本的，自己联想到了一些知识和资料也扩展了一下。总体写下来近一万字。读书笔记还可以分享给别人看。回顾时，书不在身边还可以看看自己的笔记。想想这类经典书记一遍动手敲一遍也是很值得的。不过这读书笔记中可能会有一些错别字，阅读时如果发现欢迎指正。</p>
<h3 id="第1章-精华"><a href="#第1章-精华" class="headerlink" title="第1章 精华"></a>第1章 精华</h3><p>大多数语言都有精华和糟粕。<code>JavaScript</code>令人诡异的事情是，在对这门语言没有的太多了解，甚至对编程都没有太多了解的情况下，你也能用它来完成工作。<br>看到这里不禁想起：</p>
<blockquote>
<p>张鑫旭大牛在<a href="http://www.zhangxinxu.com/wordpress/2017/06/ten-question-about-frontend-zhihu/" target="_blank" rel="external">《我对知乎前端相关问题的十问十答》</a><br>非计算机专业背景学习JS要点有这一条：<br>所有继承和原型相关内容跳过，注意，是跳过，不要看！没有这些JS一样可以活得很好，你的日常工作一样玩得飞起，当然，你没忍住看了相关知识也没关系，因为你会发现自己看不懂的；</p>
</blockquote>
<p><code>JavaScript</code>的函数是（主要）基于<strong>词法作用域</strong>的顶级对象。</p>
<blockquote>
<p>译注：<code>JavaScript</code>中的函数是根据词法来划分作用域的，而不是动态划分作用域的。具体内容参见《<code>JavaScript</code>权威指南》中译第5版相关章节“8.8.1 词法作用域”。<br>JavaScript有非常强大的对象字面量表示法。这种表示法是JSON的灵感来源。<br>原型继承是JavaScript中一个有争议的特性。</p>
</blockquote>
<p>《<code>ECMAScript</code>编程语言》第3版定义了<code>JavaScript</code>的标准。<br><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="external">ES3标准</a><br><strong>扩展：</strong><a href="http://yanhaijing.com/es5/ECMAScript%E8%A7%84%E8%8C%83-%E7%AC%AC%E4%B8%89%E7%89%88_%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="external">颜海镜大牛整理的ES3中文版</a><br><a href="http://yanhaijing.com/es5/#about" target="_blank" rel="external">颜海镜大牛整理的ES5中文版</a><br><a href="https://www.w3.org/html/ig/zh/wiki/ES5#.E7.A8.8B.E5.BA.8F" target="_blank" rel="external">W3c ES5中文版</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰大牛的书籍《ES6标准入门2》</a><br>更多内容可参见这篇文章：<a href="https://zhuanlan.zhihu.com/p/27537439" target="_blank" rel="external">ECMAScript 2018 标准导读</a></p>
<p>一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name, func) &#123;</div><div class="line">  this.prototype[name] = func;</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>书中贯彻始终都会用到这个<code>method</code>方案，作者将会在第4章解释它。</p>
<h3 id="第2章-语法"><a href="#第2章-语法" class="headerlink" title="第2章 语法"></a>第2章 语法</h3><p>本章主要用铁路图（语法图）表示语法。<br>主要有：空白、标识符、数字、字符串、语句、表达式、字面量、函数。<br><code>typeof</code> 运算符产生的值有<code>&#39;number&#39;</code>, <code>&#39;string&#39;</code>,<code>&#39;boolean&#39;</code>,<code>&#39;undefined&#39;</code>,<code>&#39;function&#39;</code>,<code>&#39;object&#39;</code>。如果运算数是一个数组或者是<code>null</code>,那么结果是<code>&#39;object&#39;</code>,这其实是不对的。</p>
<h3 id="第3章-对象"><a href="#第3章-对象" class="headerlink" title="第3章 对象"></a>第3章 对象</h3><p><code>JavaScript</code>简单数据类型包括数字、字符串、布尔值，<code>null</code>值和<code>undefined</code>值。其他所有值都是对象。<br>数组、字符串和布尔值“貌似”对象，因为它们拥有方法（包装对象），但它们是不可变的。<br>对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的所有字符串，属性值可以是除了<code>undefined</code>值之外的任何值。</p>
<p><code>JavaScript</code>包含一种原型链的特性，允许对象继承到另一个对象的属性。正确地使用它能减少对象初始化时的消耗的时间和内存。<br><strong>检索</strong><br><code>.</code>,<code>[]</code>两种检索方式，推荐点<code>.</code>表示法。<br>尝试重<code>undefined</code>的成员属性中取值将会导致<code>TypeError</code>异常，这时可以通过<code>&amp;&amp;</code>来避免错误。<br><strong>更新</strong><br>如果属性名已经存在对象里。那么属性的值会被替换。如果之前没有拥有那个属性名，那么该属性将被扩充到对象中。<br><strong>引用</strong><br>对象通过引用来传递。它们永远不会被复制。<br><strong>原型</strong><br>所有通过对象字面量创建的对象都链接到<code>Object.prototype</code>。<br>创建新对象时，可以选择某个对象作为它的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.create !== &apos;function&apos;) &#123;</div><div class="line">  Object.create = function(o) &#123;</div><div class="line">    var F = function () &#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原型连接只有在检索值的时候才被用到。如果尝试去获取对象的某个属性值，但对象没有此属性名，那么<code>JavaScript</code>会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到终点<code>Object.prototype</code>。如果想要的属性完全不存在原型链中，那么结果就是 <code>undefined</code>值。这个过程称为<strong>委托</strong>。<br>原型关系是一种动态的关系。<br><strong>反射</strong><br>原型链上的所有属性都会产生值。有两种方案可以处理掉对象上不需要的属性。<br>①程序检查时丢弃值为函数的属性。但有可能有些值确实是函数，所以该方法不可靠。<br>②使用<code>hasOwnProperty</code>方法，如果是对象拥有独有的属性，则返回<code>true</code>。该方法不会检查原型链。<br><strong>枚举</strong><br>① <code>for in</code>可以遍历一个对象中所有的属性名。但包含函数和一些不关心的原型中属性。而且顺序不确定，可以用 <code>hasOwnProperty</code>方法和<code>typeof</code>排除函数。<br>②<code>for</code> 循环不会出现<code>for in</code>那些情况。<br><strong>删除</strong><br>delete运算符可以用来删除对象的属性。<br><strong>减少全局变量的污染</strong><br>可以把全局性的资源纳入一个名称空间之下。这样做能减少冲突。</p>
<h3 id="第4章-函数"><a href="#第4章-函数" class="headerlink" title="第4章 函数"></a>第4章 函数</h3><p>函数用于①代码复用②信息隐藏③组合调用。一般来说，所谓编程，就是将一组需求分节成一组函数与数据结构的技能。<br><code>JavaScript</code>的函数就是对象。<br>函数对象连接到<code>Function.prototype</code>(该原型对象本身连接到<code>Object.prototype</code>)。<br>每个函数在创建时会附加两个隐藏属性，函数的上下文和实现函数行为的代码。<br>每个函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值为该函数的对象。<br><strong>函数字面量</strong><br>函数字面量包括4个部分。①保留字<code>function</code>②函数名，可以省略，③一组参数④一组语句。<br>函数字面量可以出现在任何允许表达式出现的地方。一个内部函数除了可以访问自己的参数和变量，同时也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个连接到外部上下文的连接。这被称为<strong>闭包</strong>。<br><strong>调用</strong><br>除了声明时定义的形式参数，每一个函数还接收两个附加的参数：<code>this</code>和<code>argument</code>。在<code>JavaScript</code>中一共有四种调用模式。①方法调用模式，②函数调用模式③构造器调用模式④<code>apply</code>调用模式。</p>
<p>（<code>this</code>指向问题一直困扰很多人。我一般是这样记的，谁调用<code>this</code>就指向谁。）</p>
<p><strong>方法调用模式</strong><br>对象的方法执行,<code>this</code>指向该对象。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObj = &#123;</div><div class="line">  value: 0,</div><div class="line">  showValue: function() &#123;</div><div class="line">    console.log(&apos;value:&apos;, this.value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">myObj.showValue();  // value: 0</div></pre></td></tr></table></figure></p>
<p><strong>函数调用模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var add = function(a,b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">add(3,4);  //7</div><div class="line">window.add(3,4);  //7</div><div class="line">// 这种this被绑定到全局对象（window）。</div><div class="line">// 可以理解是window.add(3,4);</div></pre></td></tr></table></figure></p>
<p>有种简单的办法就是<code>var that = this;</code>把<code>this</code>存储下。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var myObj = &#123;</div><div class="line">  value: 0,</div><div class="line">  age: 20,</div><div class="line">  showValue: function() &#123;</div><div class="line">    console.log(&apos;value:&apos;,this.value);</div><div class="line">    var  that = this;</div><div class="line">    var showAge = function() &#123;</div><div class="line">        // window上没有age，所以是undefined</div><div class="line">        console.log(&apos;这里的this是window ---age:&apos;, this.age);  // undefined</div><div class="line">        console.log(&apos;age:&apos;, that.age);  // 20</div><div class="line">     &#125;</div><div class="line">     showAge();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">myObj.showValue();  // 0， undefined，</div></pre></td></tr></table></figure></p>
<p><strong>构造器调用模式</strong><br><code>JavaScript</code>是一门基于原型继承的语言。<br>如果在一个函数前面带上<code>new</code> 来调用。那么背地利将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时this会被绑定到那个新对象上。<br><code>new</code> 前缀也会改变<code>return</code> 语句的行为。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var Quo = function (string) &#123;</div><div class="line">  this.status = string;</div><div class="line">&#125;</div><div class="line">Quo.prototype.get_status = function () &#123;</div><div class="line">  return this.status; </div><div class="line">&#125;</div><div class="line">var myQuo = new Quo(&apos;confused&apos;); // &apos;confused&apos;</div></pre></td></tr></table></figure></p>
<p>一个函数，如果创建的目的就是希望结合<code>new</code> 前缀来调用。那么它就被称为构造器函数。按照约定，它们保存在以大写函数命名的变量里。如果调用构造器函数时没有在前面加上<code>new</code>,可能会发生非常糟糕的事情，既没有编译时的警告，也没有运行时广告，所以大写约定非常重要。<br>作者不推荐这种形式的构造器函数。有更好的替代方式。<br><strong>Apply调用模式</strong><br><code>JavaScript</code>是一门函数式的面向对象编程语言，所以对象可以拥有方法。<br><code>apply</code>方法让我们构建一个参数数组传递给调用函数，它也允许我们选择<code>this</code>的值。<br><strong>参数</strong><br><code>arguments</code>，虽然拥有<code>length</code>属性，但不是真正的数组。而是类似数组（<code>array-like</code>）的对象。<br><strong>返回</strong><br><code>return</code> 可用来是函数提前返回。当<code>return</code> 被执行时，函数立即返回而不再执行余下的语句。<br>一个函数总会返回一个值，如果没指定，那就是返回<code>undefined</code>值。<br>如果函数调用时在前面加上了<code>new</code> 前缀，且返回值不是一个对象，则返回<code>this</code>（该新对象）。<br><strong>异常</strong><br><code>JavaScript</code>提供了一套异常处理机制。<br><code>throw</code>语句和<code>try catch</code>,<code>try catch</code>中<code>finally</code>是可选的。<br><strong>扩展类型的功能</strong><br><code>JavaScript</code>允许给语言的基本类型扩充功能。在第3章中我们已经看到，可以通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都可用。这样的方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function () &#123;</div><div class="line">  this.prototype[name]  = func;</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本类型的原型是公用结构，所以在类库混用时务必小心。一个保险的做法就是只在确认没有该方法时才添加它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Function.prototype.methods = function(name, func) &#123;</div><div class="line">  if (!this.prototype[name]) &#123;</div><div class="line">      this.prototype[name] = func;</div><div class="line">  &#125;</div><div class="line">  return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>递归</strong><br>递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，递归是用一般的方式去解决每一个子问题。书中举了一个<strong>汉诺塔</strong>的例子，是程序设计中经典递归问题。详细说明可以参见 <a href="http://baike.baidu.com/view/191666.htm" target="_blank" rel="external">百度百科“汉诺塔”词条</a>。<br>一些语言提供了尾递归优化。尾递归是一种在函数的最后执行调用语句的特殊形式的递归。参见<a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="external">Tail call</a>。 ES6版本扩展了尾递归。参见阮一峰老师的《ES6标准入门》中的<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化" target="_blank" rel="external">尾调用优化</a><br><strong>作用域</strong><br>在编程语言中，作用域控制着变量与参数的可见性和声明周期。<br>书中指出当前<code>JavaScript</code>没有块级作用域。因为没有块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。不过<code>ES6</code>扩展了有块级作用域。<br><strong>闭包</strong><br>作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ul class=&quot;list&quot;&gt;</div><div class="line">    &lt;li&gt;0&lt;/li&gt;</div><div class="line">    &lt;li&gt;1&lt;/li&gt;</div><div class="line">    &lt;li&gt;2&lt;/li&gt;</div><div class="line">    &lt;li&gt;3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 点击相应节点时，显示对应的序号。可以使用闭包来解决。</div><div class="line">var add_the_handlers = function() &#123;</div><div class="line">    var helper = function(i) &#123;</div><div class="line">        return function(e) &#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var i;</div><div class="line">    for (i = 0; i &lt; nodes.length; i += 1) &#123;</div><div class="line">        nodes[i].onclick = helper(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 扩展 另外可以用let i = 0，或者把nodes类数组转成数组等方案实现。</div><div class="line">// 闭包特性：1、函数内再嵌套函数，2、内部函数可以调用外层的参数和变量，3、参数和变量不会被垃圾回收机制回收。</div><div class="line">// 闭包优点 灵活和方便，便于封装。缺点：空间浪费、内存泄露、性能消耗。</div></pre></td></tr></table></figure>
<p><strong>回调</strong><br>发起异步请求，提供一个当服务器响应到达时随即出发的回调函数。异步函数立即返回，这样客户端就不会被阻塞。<br><strong>模块</strong><br>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。<br>举例：给<code>String</code>添加一个<code>deentityify</code>方法。它的任务是寻找字符串中的<code>HTML</code>字符实体并把它们替换成对应的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">String.method(&apos;deentityify&apos;, function () &#123;</div><div class="line">    // 字符实体表。它映射字符实体的名字到对应的字符。</div><div class="line">    var entity = &#123;</div><div class="line">        quot: &apos;&quot;&apos;,</div><div class="line">        lt: &apos;&lt;&apos;,</div><div class="line">        gt: &apos;&gt;&apos;</div><div class="line">    &#125;;</div><div class="line">    // 返回 deentityify方法</div><div class="line">    return function () &#123;</div><div class="line">        return this.replace(/&amp;([^&amp;;]+);)/g,</div><div class="line">        function (a,b) &#123;</div><div class="line">            var r = entity[b];</div><div class="line">            return typeof r === &apos;string&apos;? r : a;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>模块模式利用了函数作用域和闭包来创建被绑定对象与私有成员的关联，在上面例子中，只有<code>deentityify</code>方法有权访问字符实体表这个数据对象。<br>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。<br>使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。</p>
<blockquote>
<p>单例译注<br>模块模式通常结合单例模式使用。<code>JavaScript</code>的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化。更多内容参见：<a href="https://en.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">单例模式</a></p>
</blockquote>
<p><strong>级联</strong><br>有一些方法没有返回值。如果我们让这些方法返回<code>this</code>而不是<code>undefined</code>，就可以启用级联。<br>在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。比如<code>jQuery</code>获取元素、操作样式、添加事件、添加动画等。<br><strong>柯里化</strong><br>柯里化，是把多参数函数转换为一系列单参数函数并进行调用的技术。更多详情可参见：<a href="https://en.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">柯里化</a><br>函数也是值。柯里化允许我们把函数与传递给它的参数相结合，产生一个新的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var add1 = add.curry(1);</div><div class="line">document.writeln(add1(6));</div></pre></td></tr></table></figure></p>
<p>JavaScript并没有curry方法，但可以扩展该功能。<br>arguments不是真正的数组，所以使用了Array.prototype.slice方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Function.method(&apos;curry&apos;,function()&#123;</div><div class="line">    var slice = Array.prototype.slice,</div><div class="line">    args = slice.apply(arguments),</div><div class="line">    that = this;</div><div class="line">    return function() &#123;</div><div class="line">        return that.apply(null, args.concat(slice.apply(arguments)));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>记忆</strong><br>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化称作记忆。<br>比如说，我们想要一个递归函数来计算<code>Fibonacci</code>(斐波那契)数列，它的特点是，前面相邻两项之和等于后一项的值。更多参考：<a href="https://en.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91" target="_blank" rel="external">斐波那契</a>。最前面两个数字是0和1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var fibonacci = function() &#123;</div><div class="line">    return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样虽然能完成工作，但它做了很多无谓的工作。<br>构造一个带有记忆功能的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var memoizer = function(mome, formula) &#123;</div><div class="line">    var recur = function(n) &#123;</div><div class="line">        var result = meno[n];</div><div class="line">        if (typeof result !== &apos;number&apos;) &#123;</div><div class="line">            result = formula(recur, n);</div><div class="line">            meno[n] = result;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">    return recur;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再用这个<code>memoizer</code>函数来定义<code>fibonacci</code>函数，提供其初始的<code>memo</code>数组和<code>formula</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var fibonacci = memoizer([0,1],function(recur, n)&#123;</div><div class="line">    return recur(n-1) + recur (n-2);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>极大的减少了我们的工作量。例如要产生一个记忆的阶乘函数，只需要提供基本的阶乘公式即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var factorial = meoizer([1,1], function(recur, n)&#123;</div><div class="line">    return n * recur(n-1);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h3><p><strong>伪类</strong><br><code>JavaScript</code>的原型存在诸多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。<br><code>Function</code>构造器产生的函数对象会运行类似这样的一些代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.prototype =  &#123;constructor:this&#125;</div></pre></td></tr></table></figure></p>
<p>新函数对象被赋予一个<code>prototype</code>属性，这个<code>prototype</code>对象是存放继承特征的地方。</p>
<p>当采用构造器调用模式，即用<code>new</code>前缀去调用一个函数时，函数执行的方式会被修改。如果<code>new</code>运算符是一个方法而不是一个运算符，它可能像这样执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Function.method(&apos;new&apos;,function()&#123;</div><div class="line">    // 创建一个新对象，它继承自构造器函数的原型对象。</div><div class="line">    var that = Object.create(this.prototype);</div><div class="line">    // 调用构造器函数，绑定 -this- 到新对象上。</div><div class="line">    var other = this.apply(that,arguments);</div><div class="line">    // 如果它的返回值不是一个对象，就返回该新对象。</div><div class="line">    return (typeof other === &apos;object&apos; &amp;&amp; other) || that;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>所有构造器函数都约定命名成大写字母。一种更好的备选方案就是根本不使用<code>new</code>。<br><strong>对象说明符</strong><br>就是指传多个参数时，可以直接传递一个对象。<br><strong>原型</strong><br>可以用<code>Object.create</code>方法构造出更多实例来。<br><strong>函数化</strong><br>迄今为止，我们所看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。我们无法得到私有变量和私有函数。<br>幸运的是，我们有一个更好的选择，那就是<strong>应用模块模式</strong>。<br>我们从构造一个生成对象的函数开始。我们以小写字母开头来命名。<br>该函数包括以下四个步骤<br>1、创建一个新对象。<br>2、有选择地私有实例变量和方法。<br>3、给这个新对象扩充方法。<br>4、返回那个新对象。<br>以下是一个函数化构造器的伪代码模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var constructor = function (spec, my) &#123;</div><div class="line">    var that, 其他的私有实例变量；</div><div class="line">    my = my || &#123;&#125;;</div><div class="line">    把共享的变量和函数添加到my中</div><div class="line">    that = 一个新对象</div><div class="line">    添加给 that 的特权方法</div><div class="line">    return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们更好的封装和信息隐藏，以及访问父类方法的能力。<br><strong>部件</strong><br>我们可以从一套部件中把对象组装出来。</p>
<h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章 数组"></a>第6章 数组</h3><p>数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。<br>数组是一种性能出色的数据结构。不幸的是，<code>JavaScript</code>没有像此类数组一样的数据结构。<br><strong>数组字面量</strong><br>对象字面量<br>数组继承了<code>Array.prototype</code>大量有用的方法。而对象字面量是继承自<code>Object.prototype</code>。<br>数组有<code>length</code>属性，而对象没有。<br><strong>长度</strong><br>每个数组都有一个<code>length</code>属性。<br>可以直接设置<code>length</code>的值。设置更大的length不会给数组分配更多的空间，而设小导致所有下标大于等于新length的属性被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">arr.length = 1;</div><div class="line">console.log(arr) // [1]</div></pre></td></tr></table></figure></p>
<p>也可以通过<code>length</code>来通过添加值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">arr[arr.length] = 4;</div><div class="line">console.log(arr) // [1,2,3,4]</div></pre></td></tr></table></figure></p>
<p>有时用<code>push</code>方法更方便。<br><strong>删除</strong><br>由于<code>JavaScript</code>的数组也是对象，所以<code>delete</code>运算符可以用来从数组中移出元素。移除后，长度不变，原位置上变成了<code>undefined</code>。<br>可以使用<code>Array.prototype.splice</code>方法删除数组。<br><strong>枚举</strong><br>JS数组就是对象，所以<code>for in</code>语句可以用来遍历数据的所有属性。<br><strong>不过</strong>，<code>for in</code>无法保证属性顺序。并且可能从原型链中得到意外的属性。<br><code>for</code>循环可以避免以上问题。<br><strong>容易混淆的地方</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof [] === &quot;object&quot;; // true</div><div class="line">typeof &#123;&#125; === &quot;object&quot;; // true</div></pre></td></tr></table></figure></p>
<p>识别是否是数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 方法一、</div><div class="line">var is_array = function (value) &#123;</div><div class="line">  return value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Array;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但它在识别从不同窗口（window）或帧（frame）里的构造的数组时会失败。<br>有一个更好的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 方法二、</div><div class="line">var is_array = function (value) &#123;</div><div class="line">  return Object.prototype.toString.apply(value) === &apos;[object Array]&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>扩展</strong>：<br>ES5 提供了Array.isArray()的方法。不过兼容性是IE9+。<br>要做到兼容，可以用如下方法。MDN上提供的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="external">MDN Array.isArray</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 方法三、</div><div class="line">if (!Array.isArray)&#123;</div><div class="line">  Array.isArray = function(arg)&#123;</div><div class="line">    return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">// 方法四</div><div class="line">arr instanceof Array;</div><div class="line">// 方法五</div><div class="line">Array.prototype.isPrototypeOf(arr);</div><div class="line">// 方法六</div><div class="line">Object.getPrototypeOf(arr) === Array.prototype;</div></pre></td></tr></table></figure>
<p>方法四、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="external"><strong>instanceof</strong> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</a><br>方法五、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="external"><strong>isPrototypeOf()</strong> 方法用于测试一个对象是否存在于另一个对象的原型链上。</a><br>方法六、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external"><strong>Object.getPrototypeOf()</strong> 方法返回指定对象的原型（即, 内部[[Prototype]]属性的值）。</a><br>小结：除了方法二、三外，面对复杂的环境，其他的都不能准确的判断是否是数组。<br><strong>方法</strong><br><code>JavaScript</code>提供了一套数组可用的方法，这些方法是被存储在Array.prototype中的函数。<br><code>Object.prototype</code>是可以扩充的。<br><code>Array.prototype</code>也是可以扩充的。<br><code>ES5</code>中提供的<code>Object.create</code>方法。这方法用在数组是没有意义的，因为它产生的是一个对象，而不是一个数组，产生的对象将继承这个数组的值和方法，但它没有<code>length</code>特殊属性。<br><strong>指定初始值</strong><br><code>JavaScript</code>的数组通常不会预设值。书中写了一个循环来扩展，生成初始值。<br><strong>扩展：</strong><code>ES6</code>中提供了<code>fill</code>来填充。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(0);   // [0,0,0]</div><div class="line">new Array(3).fill(0);   // [0,0,0]</div><div class="line"></div><div class="line">// fill方法还可以接受第二、第三个参数，用于指定填充的起始位置和结束位置（不包含）。</div><div class="line">new Array(3).fill(0,1,2); // [ ,0, ,]  空位不是undefined。空位没有任何值。ES6则是明确将空位转为undefined。</div></pre></td></tr></table></figure></p>
<h3 id="第7章-正则表达式"><a href="#第7章-正则表达式" class="headerlink" title="第7章 正则表达式"></a>第7章 正则表达式</h3><p>正则表达式对字符串中的信息实现查找、替换和提取操作。<br>可处理正则表达式的方法有<code>regexp.exec</code>、<code>regexp.test</code>、<code>string.match</code>、<code>string.search</code>和<code>string.split</code>。通常来说，正则相较于等效的字符串处理有着显著的性能优势。</p>
<p><strong>一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 正则表达式必须写在一行中</div><div class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</div><div class="line">var url = &quot;http://www.ora.com:80/goodparts?q#fragment&quot;;</div><div class="line">var result = parse_url.exec(url);</div><div class="line">// ……</div></pre></td></tr></table></figure></p>
<p>依次匹配到的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">url: &apos;http://www.ora.com:80/goodparts?q#fragment&apos;,</div><div class="line">scheme: &apos;http&apos;,</div><div class="line">slash: &apos;//&apos;</div><div class="line">host: &apos;www.ora.com&apos;</div><div class="line">port:&apos;80&apos;</div><div class="line">path:&apos;goodparts&apos;</div><div class="line">query: &apos;q&apos;</div><div class="line">hash: &apos;fragment&apos;</div></pre></td></tr></table></figure></p>
<p>个人扩展：这里推荐 <a href="https://regex101.com/" target="_blank" rel="external">在线测试正则表达式的网站regex101</a>，默认是PHP语言，选择JavaScript语言。<br><a href="https://regexper.com/#%5Cd%2B" target="_blank" rel="external">在线图形化RegExp工具</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="external">MDN RegExp.prototype.exec()</a><br>大概解释下这个正则，<br>这里的<code>^</code> 起始位置，<code>$</code>结束位置<br><code>()</code> 分组捕获 <code>?:</code>不捕获<br><code>.</code>表示除换行以外的任意单个字符，对于码点大于<code>0xFFFF</code>的<code>Unicode</code>字符，点(<code>.</code>)不能识别（<code>ES6</code>中加<code>u</code>修饰符才可识别），<code>+</code>表示一个或多个，<code>*</code>表示零个或多个，<code>?</code>表示<code>0</code>个或一个。[]表示或者，里面符合一个即可。<br><code>\d</code>表示数字<code>0-9</code>。<br>不严谨的正则表达式是一个常见的安全漏洞的发源地。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。</p>
<p>再看一个 <strong>匹配数字</strong>的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;</div><div class="line">parse_number.test(&apos;1&apos;); // true</div><div class="line">parse_number.test(&apos;number&apos;); // false</div><div class="line">parse_number.test(&apos;98.6&apos;); // true</div><div class="line">parse_number.test(&apos;132.21.86.100&apos;); // false</div><div class="line">parse_number.test(&apos;123.45E-67&apos;); // true</div><div class="line">parse_number.test(&apos;123.45D-67&apos;); // false</div></pre></td></tr></table></figure></p>
<p><strong>结构</strong><br>有两个方法来创建一个<code>RegExp</code>对象。优先考虑的是正则表达式字面量，还有一种方式是<code>new RegExp(&#39;&#39;,&#39;g&#39;)</code>。<br>正则表达式标识：<code>g</code>全局(匹配多次，不同的方法对<code>g</code>标识的处理防范各不相同)，<code>i</code>忽略大小写。<code>m</code>多行<br><strong>元素</strong><br><strong>正则表达式分支</strong><br><code>|</code>表示或，也表示分支 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;info&apos;.match(/in|int/)  // 匹配成功，[&quot;in&quot;, index: 0, input: &quot;info&quot;]</div></pre></td></tr></table></figure></p>
<p><strong>正则表达式序列</strong><br>一个正则表达式序列饱和一个或多个正则表达式因子。每一个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，若没指定，这个因子则只匹配一次。<br><strong>正则表达式因子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\ / [ ] () &#123; &#125; ? + * | . ^ $</div></pre></td></tr></table></figure></p>
<p><strong>正则表达式转义</strong><br>\ 表转义 <code>\f</code> 分页 <code>\n</code> 换行 <code>\r</code>回车 <code>\t</code> 制表<br><code>\u</code> 允许制定一个 Unicode 字符来表示一个十六进制的常量。<br><code>\d</code> 等同于[0-9] \D 取反等同于 <code>[^0-9]</code><br><code>\s</code> <code>Unicode</code> 空白符一个不完全子集。 \S 与\s相反<br><code>\w</code> <code>[0-9A-Z_a-z]</code> \W 与其相反 <code>[^0-9A-Z_a-z]</code><br><code>\b</code> 表示 字边界<br><code>\1</code> 表示 分组1所捕获的文本的一个引用，所以它能被再次匹配。<br><code>\2</code> 表示 指向分组2的引用，<code>\3</code> 是表示分组3的引用，以此类推。<br><strong>正则表达式分组</strong><br>捕获型<code>()</code><br>非捕获型<code>?:</code><br>向前正向匹配<code>?=</code><br>有一个<code>(?=</code>前缀。它类似于非捕获类型分组，但在这个组匹配后，文本会倒回到它它开始的地方，实际上并不匹配任何东西。也可以理解为匹配位置。<br>向后负向匹配<br>有一个<code>(?!</code>前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。<br><strong>正则表达式字符集</strong><br>正则表达式字符集是一种指定一组字符的便利方式。例如，要匹配一个元音字母，<code>(?:a|e|i|o|u)</code>,可以方便的写成<code>[aeiou]</code>。<br>类提供另外两个便利：①指定字符范围<br>所以，一组由<code>32</code>个<code>ASCII</code>的特殊组合，可以写成<code>[!-\/:-@\[-</code>{-~]`<br>②类的取反<br>取反<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[^!-\/:-@\[-`&#123;-~]</div></pre></td></tr></table></figure></p>
<p><strong>正则表达式字符转义</strong><br>字符类内部的转义规则和正则表达式因子的相比稍有不同。下面是在字符类中需要被转义的特殊字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- / [ \ ]</div></pre></td></tr></table></figure></p>
<p><strong>正则表达式量词</strong><br>量词后缀决定正则表达式因子应该被匹配的次数。<br><code>{3}</code>三次<br><code>{3,6}</code> 3、4、5、6次<br><code>{3,}</code>3次或更多次<br><code>?</code>等同于<code>{0,1}</code>，<code>*</code>等同于<code>{0,}</code>，<code>+</code>等同于<code>{1,}</code>。</p>
<h3 id="第8章-方法"><a href="#第8章-方法" class="headerlink" title="第8章 方法"></a>第8章 方法</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><strong>array.concat(item…)</strong><br><code>concat</code> 方法产生一个新数组，它包含一份<code>array</code>的浅复制并把一个或多个参数<code>item</code>附加在其后。如果<code>item</code>是数组，那么每个元素分别被添加。后面有和它功能类似的<code>array.push(item...)</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</div><div class="line">var c = a.concat(b, true);</div><div class="line">// c =&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,true]</div></pre></td></tr></table></figure></p>
<p><strong>扩展：</strong> <code>ES6</code> 有更便捷的扩展运算符<code>...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var b = [&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</div><div class="line">var c = [...a,true,...b];   // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, true, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</div></pre></td></tr></table></figure></p>
<p><strong>array.join(separator)</strong><br><code>join</code>方法把一个<code>array</code>构造成一个字符串。<br><code>separator</code> 默认值就是逗号<code>&#39;,&#39;</code>。<br>如果你想把大量的字符串片段组装成一个字符串，把这些片段放在一个数组中，并用<code>join</code>方法连接起来通常比用<code>+</code>元素运算符连接起来要快。</p>
<blockquote>
<p>译注：对于<code>IE6/7</code>，使用join连接大量字符串效率确实优于加号运算符。但目前主流浏览器，包括<code>IE8</code>以后的版本，都对<code>+</code>元素运算符连接字符串做了优化，性能已经显著高于<code>Array.join()</code>。所以目前大多数情况下，建议首选使用+ 连接字符串。更多参看《高性能网站建设进阶指南》中字符串优化相关章节。</p>
</blockquote>
<p><strong>array.pop()</strong><br><code>pop</code>方法移除<code>array</code>中的最后一个元素，并返回这个元素。如果<code>array</code>为空，则返回<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var c = a.pop(); // a 是 [&apos;a&apos;,&apos;b&apos;]  c是 &apos;c&apos;</div><div class="line">// pop 可以像这样实现。</div><div class="line">// 这里的 Array.method()在第一章例子中已经定义了，并且贯穿全书。其实就是相当于Array.prototype</div><div class="line">Array.method(&apos;pop&apos;, function () &#123;</div><div class="line">    return this.splice(this.length-1,1)[0];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>array.push(item…)</strong><br>与<code>concat</code>不同的是，它会修改array，如果参数<code>item</code>是数组，它会把参数数组作为单个元素整个添加到数组中。并返回这个<code>array</code>的新长度值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1,2,3];</div><div class="line">var b = [4,5,6];</div><div class="line">var c = a.push(b,true);</div><div class="line">// a 是 [1,2,3,[4,5,6],true]</div><div class="line">// c 是 5</div></pre></td></tr></table></figure></p>
<p><code>push</code>可以像这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Array.method(&apos;push&apos;, function () &#123;</div><div class="line">  this.splice.apply(</div><div class="line">  this,</div><div class="line">  [this.length,0].</div><div class="line">  concat(Array.prototype.slice.apply(arguments)));</div><div class="line">  return this.length;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>array.reverse()</strong><br><code>reverse</code>反转<code>array</code>元素顺序，并返回<code>array</code>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [1,2,3];</div><div class="line">var b = a.reverse();</div><div class="line">// a 和 b都是 [3,2,1]</div></pre></td></tr></table></figure></p>
<p><strong>array.shift()</strong><br><code>shift</code>移除<code>array</code>的第一个元素并返回这个元素。如果<code>array</code>为空，则返回<code>undefined</code>。<code>shift</code>通常比<code>pop</code>慢的多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = [1,2,3];</div><div class="line">var c = a.shift(); // a 是[2,3] , c 是1</div></pre></td></tr></table></figure></p>
<p><code>shift</code>可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.method(&apos;shift&apos;, function()&#123;</div><div class="line">    return this.splice(0,1)[0];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>array.slice(start[, end])</strong><br><code>slice</code>是对<code>array</code>中的一段做浅复制。<code>end</code>是可选的。默认是<code>array.length</code>,如果两个参数任何一个是负数，<code>array.length</code>会和相加。如果<code>start</code>大于<code>array.length</code>,获得一个<code>[]</code>,字符串也有<code>Sting.slice</code>这个同名方法。<br><strong>array.sort</strong><br>默认不能给一组数字排序。默认把要被排序的元素都视为字符串。<br>幸运的是，可以使用自己的比较函数替换默认的比较函数。<br>比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。<br><code>sort</code>方法是不稳定的。<code>JavaScript</code>的<code>sort</code>方法的稳定性根据不同浏览器的实现而不一致。<br>可参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="external">MDN sort</a><br><strong>array.splice(start, deleteCount,item…)</strong><br><code>splice</code>方法从array中移除一个或多个元素，并用新的<code>item</code>替换它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// splice 可以像这样实现</div><div class="line">Array.method(&apos;splice&apos;,function (start, deleteCount) &#123;</div><div class="line">    var max = Math.max,</div><div class="line">        min = Math.min,</div><div class="line">        delta,</div><div class="line">        element,</div><div class="line">        insertCount = max(arguments.length - 2, 0),</div><div class="line">        k = 0,</div><div class="line">        len = this.length,</div><div class="line">        new_len,</div><div class="line">        result = [],</div><div class="line">        shift_count;</div><div class="line">    start = start || 0;</div><div class="line">    if (start &lt; 0) &#123;</div><div class="line">        start += len;</div><div class="line">    &#125;</div><div class="line">    start = max(min(start, len), 0);</div><div class="line">    deleteCount = max(min(typeof deleteCount === &apos;number&apos; ? deleteCount : len, len - start), 0);</div><div class="line">    delta = insertCount - deleteCount;</div><div class="line">    new_len = len + delta;</div><div class="line">    while (k &lt; deleteCount) &#123;</div><div class="line">        element = this[start + k];</div><div class="line">        if (element !== undefined) &#123;</div><div class="line">            result[k] = element;</div><div class="line">        &#125;</div><div class="line">        k += 1;</div><div class="line">    &#125;</div><div class="line">    shift_count = len - start - deleteCount;</div><div class="line">    if (delta &lt; 0) &#123;</div><div class="line">        k = start + insertCount;</div><div class="line">        while (shift_count) &#123;</div><div class="line">            this[k] = this[k - delta];</div><div class="line">            k += 1;</div><div class="line">            shift_count -= 1;</div><div class="line">        &#125;</div><div class="line">        this.length = new_len;</div><div class="line">    &#125; else if (delta &gt; 0) &#123;</div><div class="line">        k = 1;</div><div class="line">        while (shift_count) &#123;</div><div class="line">            this[new_len - k] = this[len - k];</div><div class="line">            k += 1;</div><div class="line">            shift_count -= 1;</div><div class="line">        &#125;</div><div class="line">        this.length = new_len;</div><div class="line">    &#125;</div><div class="line">    for (k = 0; k &lt; insertCount; k += 1) &#123;</div><div class="line">        this[start + k] = arguments[k + 2];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>array.unshift(item…)</strong><br><code>unshift</code> 方法像<code>push</code>方法一样，不过是用于把元素添加到数组的开始部分，返回新<code>array</code>的<code>length</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// unshift 可以像这样实现</div><div class="line">Array.method(&apos;unshift&apos;, function()&#123;</div><div class="line">    this.splice.apply(this,</div><div class="line">    [0,0].concat(Array.prototype.slice.apply(arguments)));</div><div class="line">    return this.length;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p><strong>function.apply(thisArg,argArray)</strong><br><code>apply</code>方法调用<code>function</code>,传递一个会被绑定到<code>this</code>上的对象和一个可选的数组作为参数。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p><strong>number.toExponential(fractionDigits)</strong><br><code>toExponential</code>方法 把这个<code>number</code>转换成一个指数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在<code>0~20</code>。</p>
<p><strong>number.toFixed(fractionDigits)</strong><br><code>toFixed</code>方法把这个number转换成一个十进制数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。</p>
<p><strong>number.toPrecision(precision)</strong><br><code>toPrecision</code>方法把这个<code>number</code>转换成一个十进制数形式的字符串。可选参数控制数字的精度。它的值必须在<code>0~21</code>。</p>
<p><strong>number.toString(radix)</strong><br>把<code>number</code>转换成字符串。可选参数控制基数。它的值必须是<code>2~36</code>。默认的<code>radix</code>是以<code>10</code>为基数的。<code>radix</code>参数最常用的是整数，但是它可以用任意的数字。</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p><strong>object.hasOwnProperty(name)</strong><br>如果这个<code>object</code>包含名为<code>name</code>的属性，那么返回<code>true</code>。原型链中的同名方法不会被检测。这个方法对<code>name</code>就是<code>“hasOwnProperty”</code>时不起作用。</p>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p><strong>regexp.exec(string)</strong><br><code>exec</code>是正则中最强大(和最慢）的方法。<br>如果成功匹配，它会返回一个数组。下标为0 的元素包含正则匹配的子字符串。下标为1的则是分组1捕获的文本。下标为2的则是分组2捕获的文本。以此类推。如果匹配失败则返回<code>null</code>。<br><strong>regexp.test(string)</strong><br><code>test</code>是最简单(和最快)的方法。匹配成功，返回<code>true</code>,否则返回<code>false</code>。不要对这个方法使用<code>g</code>标识。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var reg = /\w+/g;</div><div class="line">reg.test(&apos;ab&apos;); // true</div><div class="line">// 再执行一遍就是false了。</div><div class="line">reg.test(&apos;ab&apos;); // false</div><div class="line">// 再执行一遍就是true了。</div><div class="line">reg.test(&apos;ab&apos;); // true</div><div class="line">// 再执行一遍又是false了，如此反复，所以用g标识后，看起来很诡异。应该每次匹配开始位置变了。</div><div class="line">reg.test(&apos;ab&apos;); // false</div></pre></td></tr></table></figure></p>
<p><code>test</code>可以像这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RegExp.method(&apos;test&apos;, function(string)&#123;</div><div class="line">    return this.exec(string) !== null;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>string.charAt(pos)</strong><br>返回在<code>string</code>中的<code>pos</code>位置处的字符。</p>
<p><strong>string.charCodeAt(pos)</strong><br>与<code>charAt</code>一样，不过返回整数形式表示字符码位。</p>
<p><strong>string.concat(string)</strong><br>很少用，用<code>+</code>号运算符更方便。</p>
<p><strong>string.indexOf(searchString,position)</strong><br>在<code>string</code>中查找第一个参数，如果被找到返回该字符的位置，否则返回<code>-1</code>。<code>position</code>可设置指定位置开始查找。</p>
<p><strong>string.lastIndexOf(searchString,position)</strong><br><code>lastIndexOf</code> 方法和<code>indexOf</code>方法类似，不过它是从末尾开始查找，不是从头开始。</p>
<p><strong>string.localeCompare(that)</strong><br>比较两个字符串。类似于<code>array.sort</code>。</p>
<p><strong>string.match(regexp)</strong><br>如果没有<code>g</code>标识，那么调用<code>string.match(regexp)</code>和调用<code>regexp.exec(string)</code>结果相同。如果带有<code>g</code>标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组。</p>
<p><strong>string.replace(searchValue,replaceValue)</strong><br>对<code>string</code>进行查找和替换操作，并返回一个新的字符串。参数<code>searchvalue</code>可以是一个字符串也可以是一个正则表达式对象。参数<code>replaceValue</code>可以是一个字符串或一个函数。</p>
<p><strong>string.search(regexp)</strong><br>和<code>indexOf</code>类似，不过它接收正则为参数。</p>
<p><strong>string.slice(start, end)</strong><br><code>slice</code>方法复制<code>string</code>的一部分来构造一个新的字符串。如果<code>start</code>参数是负数，它将与<code>string.length</code>相加。<code>end</code>参数是可选的。</p>
<p><strong>string.split(separator,limit)</strong><br>把<code>string</code>分割成片段来创建一个字符串数组。可选参数<code>limit</code>可以限制分割的片段数量。<code>separator</code>参数可以是字符串或者正则。<br><strong>string.substring(start,end)</strong><br>与<code>slice</code>方法一样，不过它不能处理负数参数。<br><strong>string.toLocaleLowerCase()</strong><br>它使用本地化的规则把这个<code>string</code>中的字母转换成小写格式。这个方法主要用在土耳其语上。<br><strong>string.toLocaleUpperCase()</strong><br>它使用本地化的规则把这个<code>string</code>中的字母转换成大写格式。这个方法主要用在土耳其语上。<br><strong>string.toLowerCase()</strong><br>返回新字符串，所有字母转成小写格式。<br><strong>string.toUpperCase()</strong><br>返回新字符串，所有字母转成大写格式。<br><strong>String.fromCharCode(char…)</strong><br>根据一串数字编码返回一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = String.fromCharCode(67,97,116) // a是&apos;Cat&apos;</div></pre></td></tr></table></figure></p>
<h3 id="第9章-代码风格"><a href="#第9章-代码风格" class="headerlink" title="第9章 代码风格"></a>第9章 代码风格</h3><p>这一章中，简短的说了一些代码风格。事实证明代码风格在编程中是很重要的。</p>
<h3 id="第10章-优美的特性"><a href="#第10章-优美的特性" class="headerlink" title="第10章 优美的特性"></a>第10章 优美的特性</h3><p>精简的<code>JavaScript</code>里都是好东西。<br>包括：1、函数是顶级对象；2、基于原型继承的动态作用域；3、对象字面量和数组字面量。</p>
<p>到此，读书笔记已完结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010313101&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;首发于：segmentfault《JavaScript语言精粹 修订版》 读书笔记&lt;/a&gt;&lt;/p&gt;
&lt;b
    
    </summary>
    
      <category term="读书笔记" scheme="https://lxchuan12.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="https://lxchuan12.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>工作一年后，我有些感悟</title>
    <link href="https://lxchuan12.github.io/2017/06/02/20170602-After%20a%20year&#39;s%20work,%20I%20had%20some%20insights/"/>
    <id>https://lxchuan12.github.io/2017/06/02/20170602-After a year&#39;s work, I had some insights/</id>
    <published>2017-06-02T14:20:53.000Z</published>
    <updated>2017-06-24T15:24:29.479Z</updated>
    
    <content type="html"><![CDATA[<p>去年6月1日，入职那天早上下着小雨。在公司取了一个花名：<strong>轩辕</strong>，后来把网上昵称基本都改成了<strong>轩辕Rowboat</strong>。还记得那天晚上朋友请我吃小龙虾。</p>
<p>今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。<a id="more"></a></p>
<h3 id="学习工作"><a href="#学习工作" class="headerlink" title="学习工作"></a>学习工作</h3><p><strong>从校园到职场</strong></p>
<p>主动认识同事。</p>
<p>虽然不太可能与每一个同事都能相处的特别熟。但对于新人，都会被拉入一些群。这时候，可以加同事QQ或者微信等（同事一般不会拒绝），便于之后沟通交流工作。</p>
<p>这时候有的人能够主动快速得认识团队里的同事。有的人则是入职了很久都不认识对面的同事。</p>
<p>把离别看得平淡了许多。大学毕业后，很多人一晃一年没见，是再正常不过的事了。</p>
<p>同事离职后，即使还在同一个城市，但交集就变少了。</p>
<p>有江湖的地方就有规矩，职场也有。在职场只要用心去发现，能够学到公司的管理方式等。</p>
<p><strong>认清自己的定位</strong></p>
<p>常和别人开玩笑说，自己是来自贫困的小山村的一个大学生，职业是：说的高端一点是<strong>前端开发工程师</strong>，说的通俗易懂点则是<strong>做网站的程序猿</strong>。嗯，这就算是一种定位。</p>
<p>像我这样的人几百万。想起一个朋友说：感觉你在IT方面很厉害。我说：你只是认识万千程序猿中的一个而已。</p>
<p><strong>学无止境，提升竞争力</strong></p>
<p>智联招聘网显示：web前端开发是竞争最激烈的职业。</p>
<p>上次听一次segmentfault的讲堂，其中有提到慕课网有很多用户，其中400万是前端开发。</p>
<p>有时候会想我这一年是不是学习方式不对，不够努力，或者说能否再努力一点，是不是能够进入更好的大公司，能够得到更好的成长。</p>
<p><strong>事实证明，自身能力不够，有机遇来了，会抓不住。</strong></p>
<p>比如：之前有面试过淘宝、大搜车等，然而技术一般，没能通过面试。</p>
<h3 id="现实生活"><a href="#现实生活" class="headerlink" title="现实生活"></a>现实生活</h3><p>我读大学买了电脑考了驾照，四年花了家里4万块左右（从大一暑假买电脑开始算到大四结束，用Excel统计家里打了25200元给我）。而在杭州待一年光吃住就得花近3万块（吃饭按一天40元算，一个月1200，租房1100+）。</p>
<p>最近看的电视剧《欢乐颂2》中，身为90后的程序猿应勤在大上海买了车买了房（好像还提到是全额付款）。现实中在大上海房价均价5.5万/平米，有人分析单靠程序猿那点工资（虽然IT行业相对其他行业薪资高些）是不太可能的。</p>
<h3 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h3><p>看到毕业几年的同事过着怎样的生活，可以推测出几年后的自己大概过着怎样的生活。当然未来的一切都是未知的。但基本能看出自己一年后是过着怎样的生活。</p>
<p>月薪两万的薪资算是很不错了，但是在大城市算刚起步，为什么算刚起步，主要因为房价太高，买个房好几百万。比较优秀的前端开发工程师，工作三年后月薪大概能达到15K—20K，当然各城市不一。再往后，能达到年薪50万左右已经是非常不错了。</p>
<p><strong>如何提高收入，是大家关心的永恒的话题。</strong>5月份我们从学校课题组出来的三个同学回学校时，在高铁上上讨论过，毕业一年有什么感觉，大家都一致认为：<strong>要想单靠开发这点薪资，在大城市立足，是非常艰难的。</strong>然后想着有哪些赚钱之道，都可以去试试，刚毕业一年，还算很早。</p>
<p>主要说到三条。<strong>第一条是：加入有潜力的团队初创公司（拿股份）。</strong>同学就说到他们老大的事迹，说刚靠程序猿这点工资在大城市过上小资生活是很艰难的，他之前加入阿里后来拿股份才开了现在的公司（大概意思是这样）。</p>
<p><strong>第二条是：拓展自己的人脉，找准风口，好创意，自己组建团队开发出有价值的产品。</strong>说到这条我就提到小密圈（付费圈子，我加入一个圈子收费200，有700+人加入，运营一年，就能得到14万的收入。）</p>
<p>我自己也建了一个<strong>前端视野</strong>的小密圈（免费），发发自己关于前端开发的所见所想，也好沉淀沉淀，没打算怎么推广，但这里还是贴一下二维码，<strong>万一有人想加入呢</strong>。</p>
<p><img src="/2017/06/02/20170602-After%20a%20year%27s%20work,%20I%20had%20some%20insights/xiaomiquan.jpg" alt="前端视野-小密圈-一个人走得快，一群人走得远" title="前端视野-小密圈-一个人走得快，一群人走得远">。</p>
<p>[前端视野-小密圈-一个人走得快，一群人走得远]</p>
<p>前端视野-小密圈-一个人走得快，一群人走得远<br>还建有一个<strong>PPT视野</strong>的圈子，这个目前还没发过动态。</p>
<p><strong>第三条则是：发展一项兴趣爱好，打造个人品牌，做到可以赚大钱的地步。</strong>（有人刚毕业4K，毕业三年，凭借PPT，开商务PPT训练营收费课程，年薪50万）。他们经常问我可以多接些PPT来做，就可以赚点钱了，我说目前没有时间，也没有渠道，而且我也是只是万千PPT设计师中很渣的一员。</p>
<p>想做到收入更高，除了做好本职工作和提升专业素养外，也需要跳出来看看外面的世界。</p>
<p>上次和同学几人一起玩的时候，有个妹纸说了这句，<strong>何以解忧，唯有暴富</strong>。让我记忆犹新。</p>
<p>事实上群体中确实有小概率事件发生，比如中个上千万的彩票，但是对于个体，这种事几乎不可能发生。而且有研究表明，中彩票的普通人，一般会在五年后用完这笔财富，最后还是普通人。</p>
<p><strong>所以说：提高自己在各方面的竞争力</strong>，比如：为人处事、沟通表达、团队协作等等，这也就是<strong>可迁移能力</strong>，以不变应对这个变化的世界，才是最重要的。</p>
<p><a href="http://www.jianshu.com/p/0b29cc65dc82" target="_blank" rel="external">这是我写在简书的文章：工作一年后，我有些感悟</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年6月1日，入职那天早上下着小雨。在公司取了一个花名：&lt;strong&gt;轩辕&lt;/strong&gt;，后来把网上昵称基本都改成了&lt;strong&gt;轩辕Rowboat&lt;/strong&gt;。还记得那天晚上朋友请我吃小龙虾。&lt;/p&gt;
&lt;p&gt;今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。
    
    </summary>
    
      <category term="随笔" scheme="https://lxchuan12.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lxchuan12.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感悟" scheme="https://lxchuan12.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何破解百度网盘下载限制及网盘搜索技巧</title>
    <link href="https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/"/>
    <id>https://lxchuan12.github.io/2017/03/17/20170317-How-to-crack-Baidu-SkyDrive-download-restrictions-and-SkyDrive-search-tips/</id>
    <published>2017-03-17T14:52:23.000Z</published>
    <updated>2017-06-24T15:22:02.618Z</updated>
    
    <content type="html"><![CDATA[<p>今天两个朋友问我如何选电脑的问题，我说了一些大概流程，<strong>需求-&gt;预算-&gt;筛选-&gt;对比-&gt;购买</strong>。其实我好久没有关注这方面了，毕竟没钱买电脑。<br>晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。<a id="more"></a>大学里也会去图书馆看看纸质的。然后<strong>找到</strong> 2017年《电脑报》的看了一会。<br>看到一篇《如何破解百度网盘下载限制》的文章，我试过后有效，特来分享整理给大家。<br>在chrome浏览器中，新建一个书签，书签名字随意，书签的网址复制粘贴这段代码：<br><code>javascript:navigator.__defineGetter__ (&#39;platform&#39;,function(){return &#39;&#39;});</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/201107-eee7bebd91594895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建一个书签下载时点击下它.png"></p>
<p>它的作用是<strong>防止下载大文件时唤醒百度网盘客户端</strong>。</p>
<p><strong>所以在点击“下载”前，先点击它。</strong>待开始下载后，打开浏览器的<strong>“下载内容”</strong>（快捷键：Ctrl+J），看到正在进行的下载任务选择<strong>“复制链接地址”</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-6c69c444dff3c8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右击复制链接地址.png" title="">
                </div>
                <div class="image-caption">右击复制链接地址.png</div>
            </figure>
<p>将地址粘贴到<strong>迅雷极速版</strong>下载，官方好像不提供下载链接了，这里推荐<a href="http://rj.baidu.com/soft/detail/26860.html" target="_blank" rel="external">百度软件中心下载地址</a><a href="http://rj.baidu.com/soft/detail/26860.html" target="_blank" rel="external">http://rj.baidu.com/soft/detail/26860.html</a> ,点击<strong>普通下载</strong>即可，这样就可以了。<br>    虽然速度不是非常稳定但至少比百度云盘PC客户端几十KB／s快。不建议大家再安装破解版，有钱还是买个会员吧，或者干脆上NAS。</p>
<p>可能有小伙伴好奇我是如何找到2017年的《电脑报》的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-9e63cc297f48f3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜百度盘.png" title="">
                </div>
                <div class="image-caption">搜百度盘.png</div>
            </figure>
<p>这时分享几个网盘搜索网站：</p>
<p>（常用）搜百度盘：<a href="http://www.sobaidupan.com" target="_blank" rel="external">http://www.sobaidupan.com</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-6d70b392f3eb0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索“罗小川chuan”结果.png" title="">
                </div>
                <div class="image-caption">搜索“罗小川chuan”结果.png</div>
            </figure>
<p>搜索“罗小川chuan”结果，可怕，我得赶紧取消一些个人信息的公开分享了。</p>
<p>盘搜网：<a href="http://www.pansou.com/" target="_blank" rel="external">http://www.pansou.com/</a><br>搜盘网：<a href="http://www.soupan.info/" target="_blank" rel="external">http://www.soupan.info/</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-8700418458856aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="之前书签里保存的网盘搜索网站.png" title="">
                </div>
                <div class="image-caption">之前书签里保存的网盘搜索网站.png</div>
            </figure>
<p>等等，其他就不附链接了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天两个朋友问我如何选电脑的问题，我说了一些大概流程，&lt;strong&gt;需求-&amp;gt;预算-&amp;gt;筛选-&amp;gt;对比-&amp;gt;购买&lt;/strong&gt;。其实我好久没有关注这方面了，毕竟没钱买电脑。&lt;br&gt;晚上回来一想，好像好久没看《电脑报》（里面有购机指南）了，才发现百度网盘里存着的《电脑报》和《电脑爱好者》还是2014年的，原来两年没看了。
    
    </summary>
    
      <category term="网盘搜索" scheme="https://lxchuan12.github.io/categories/%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="window" scheme="https://lxchuan12.github.io/tags/window/"/>
    
      <category term="skyDrive" scheme="https://lxchuan12.github.io/tags/skyDrive/"/>
    
      <category term="Baidu" scheme="https://lxchuan12.github.io/tags/Baidu/"/>
    
  </entry>
  
  <entry>
    <title>简单实用免费的shadowsocks翻墙技巧</title>
    <link href="https://lxchuan12.github.io/2017/03/06/20170306-freess/"/>
    <id>https://lxchuan12.github.io/2017/03/06/20170306-freess/</id>
    <published>2017-03-06T15:02:23.000Z</published>
    <updated>2017-08-08T14:19:01.371Z</updated>
    
    <content type="html"><![CDATA[<p>开发时遇到问题，一般都是使用<strong>谷歌搜索</strong>，相对百度更加精准一些。比如搜索我的网名<strong>轩辕Rowboat</strong>，一大堆结果。<a id="more"></a><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-0c966a706280b1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌搜索轩辕Rowboat结果.png" title="">
                </div>
                <div class="image-caption">谷歌搜索轩辕Rowboat结果.png</div>
            </figure></p>
<p>谷歌书签同步，YouTube等等。总是需要<strong>翻墙</strong>的。<br>一次偶然的机会发现了这个网站，<a href="http://freess.cx/" target="_blank" rel="external">FreeSS-最好用的免费SS提供站点</a>（提供免费的ss账号）（免费为它打广告~）<br>觉得好东西要分享给大家，于是写下这篇文章（当然我觉得很多人都会，但还是写了）。</p>
<h3 id="1、下载shadowsocks（Mac，Android等可以下载相应版本）："><a href="#1、下载shadowsocks（Mac，Android等可以下载相应版本）：" class="headerlink" title="1、下载shadowsocks（Mac，Android等可以下载相应版本）："></a>1、下载shadowsocks（Mac，Android等可以下载相应版本）：</h3><p>windows各版本下载地址：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-windows/releases</a>，这网址一般不会是失效。一般下载最新的Downloads-&gt;Shadowsocks-xxx.zip即可。</p>
<p>Mac，Android等可以在这个链接下载：<a href="https://github.com/shadowsocks" target="_blank" rel="external">https://github.com/shadowsocks</a><br>我下载的是:<a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.4.3/Shadowsocks-3.4.3.zip" target="_blank" rel="external">3.4.3.zip版本</a> ，软件一直在持续更新，链接可能会失效。解压到电脑任意位置，点击打开Shadowsocks.exe程序，程序图标会出现在右下角。</p>
<h3 id="2、打开这个网站http-freess-org-，配置"><a href="#2、打开这个网站http-freess-org-，配置" class="headerlink" title="2、打开这个网站http://freess.org/ ，配置"></a>2、打开这个网站<a href="http://freess.org/" target="_blank" rel="external">http://freess.org/</a> ，配置</h3><p>打开任意一个二维码。右键程序图标，弹出菜单中选择“<strong>服务器</strong>”－“<strong>扫描屏幕上的二维码</strong>”，扫描成功后会<strong>自动配置</strong>，菜单中勾选“<strong>启用系统代理</strong>”即可。这时就可以使用任意浏览器翻墙了。不过这个免费的ss账号（目前可用），<strong>只限当天使用，次日得重新扫描</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-b74e7c9df6536f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑服务器" title="">
                </div>
                <div class="image-caption">编辑服务器</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-421cb8b9e8ec2aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置截图" title="">
                </div>
                <div class="image-caption">配置截图</div>
            </figure>
<p>当然只想用谷歌搜索不一定要翻墙，可以使用谷歌镜像搜索。（网上有一些<strong>谷歌镜像站</strong>，不过有一定局限性，也有一些可用谷歌学术搜索镜像）。</p>
<h3 id="可能遇到问题："><a href="#可能遇到问题：" class="headerlink" title="可能遇到问题："></a>可能遇到问题：</h3><p>如果碰到打开时提示，版本过低。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/201107-2a558d5cb7bf523e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="版本过低.png" title="">
                </div>
                <div class="image-caption">版本过低.png</div>
            </figure>
<p>下载安装.netframework<a href="https://download.microsoft.com/download/D/5/C/D5C98AB0-35CC-45D9-9BA5-B18256BA2AE6/NDP462-KB3151802-Web.exe" target="_blank" rel="external">下载地址链接</a></p>
<p>更多<strong>使用说明</strong>可以查看：<a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="external">官方中文说明文档</a><br>比如：配合谷歌插件（<strong>SwitchyOmega</strong> ）共同使用，可以做到系统代理和直接连接，自动切换，就不容易导致开了代理，连接不需要代理的网站异常了。<br><a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">SwitchyOmega插件下载安装地址</a></p>
<p>小胡子哥的文章：<a href="http://www.barretlee.com/blog/2016/08/03/shadowsocks/" target="_blank" rel="external">Shadowsocks 原理简介及安装指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发时遇到问题，一般都是使用&lt;strong&gt;谷歌搜索&lt;/strong&gt;，相对百度更加精准一些。比如搜索我的网名&lt;strong&gt;轩辕Rowboat&lt;/strong&gt;，一大堆结果。
    
    </summary>
    
      <category term="shadowsocks" scheme="https://lxchuan12.github.io/categories/shadowsocks/"/>
    
    
      <category term="window" scheme="https://lxchuan12.github.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>vue1.0和2.0的区别</title>
    <link href="https://lxchuan12.github.io/2017/02/12/20170212-The%20difference%20between%20vue1.0%20and%202/"/>
    <id>https://lxchuan12.github.io/2017/02/12/20170212-The difference between vue1.0 and 2/</id>
    <published>2017-02-12T07:04:23.000Z</published>
    <updated>2017-06-24T15:23:28.738Z</updated>
    
    <content type="html"><![CDATA[<p>重新仔细读了下文档，边看边写了一些。<br>1、v-once只渲染一次。<br>2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。<br>全局过滤器和单个过滤器。<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- in mustaches --&gt;</div><div class="line">&#123;&#123; message | capitalize &#125;&#125;</div><div class="line">&lt;!-- in v-bind --&gt;</div><div class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;</div></pre></td></tr></table></figure>
<p>3、watch允许异步操作。computed做不到。<br>4、新增：v-else-if<br>5、v-if中，使用 key 控制元素的可重用<br>6、v-for (value,index)，$index被废除。 item in items,item of items.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</div><div class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>7、track-by=”$index”被废用，用key替代。（就地复用）<br>7.1、template中不能使用this不是。data.a=1,template,直接写a即可。<br>8、2.1.4新增<a v-on:click.once="doThis"></a><br>9、2.1.0 新增<br>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.ctrl</div><div class="line">.alt</div><div class="line">.shift</div><div class="line">.meta</div></pre></td></tr></table></figure></p>
<p>10、修饰符lazy,number,trim<br>11、组件中data 必须是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;my-row&gt;...&lt;/my-row&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure>
<p>12、自定义事件，废除了events、$dispatch、$broadcast。<br>使用 $on(eventName) 监听事件<br>使用 $emit(eventName) 触发事件<br>13、给组件绑定原生事件-修饰符.native<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用自定义事件的表单输入组件<br>14、非父子组件通信。<br>15、slot分发内容。<br>16、动态组件，<keep-alive><component :is=""></component></keep-alive><br>参考：<a href="http://www.tuicool.com/articles/QJZRVj6" target="_blank" rel="external">[译]Vue 动态组件</a><br>17、子组件索引ref<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;parent&quot;&gt;</div><div class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</div><div class="line">// 访问子组件</div><div class="line">var child = parent.$refs.profile</div></pre></td></tr></table></figure></p>
</blockquote>
<p>18、使用 v-once 的低级静态组件<br>19、列表过渡<transition-group>,tag,v-move<br><a href="http://www.365mini.com/page/jquery-event-stopimmediatepropagation.htm" target="_blank" rel="external">jQuery Event.stopImmediatePropagation() 函数详解</a></transition-group></p>
<blockquote>
<p>stopImmediatePropagation()函数用于阻止剩余的事件处理函数的执<br>行，并防止当前事件在DOM树上冒泡。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新仔细读了下文档，边看边写了一些。&lt;br&gt;1、v-once只渲染一次。&lt;br&gt;2、过滤器 第二参数（）以函数传参的形式。过滤器可以串联。&lt;br&gt;全局过滤器和单个过滤器。
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vuejs" scheme="https://lxchuan12.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结，毕业，工作</title>
    <link href="https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/"/>
    <id>https://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary/</id>
    <published>2017-01-07T13:40:38.000Z</published>
    <updated>2017-06-24T15:25:20.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。<a id="more"></a></p>
</blockquote>
<p>时间总是那么的快。2014年开始，就有了写个人年度总结的习惯。如果把2015年定义成<strong>PPT年</strong>，那么2016年则可以说是<strong>开发年</strong>。这一年相对比较平凡，还算满意。</p>
<p>2015年的年底，准备好了提前答辩的相关事宜。2016年元旦放假三天，在学校的课题组办公室翻看着微博（微博有时间轴，可以看到每个月都发了什么，这也就是为什么我比较喜欢发微博的原因之一），做着PPT，用思维导图工具Xmind，写着年度总结——<a href="http://user.qzone.qq.com/1019963719/blog/1451822274" target="_blank" rel="external">《2015年总结，淡化旧标签，无惧未来 》</a>。</p>
<p>翻看2016年的微博，看到大年初三的一条这样写着：</p>
<blockquote>
<p>猴年初三（2月10日），去舅舅家拜年。舅舅极力要求我在他家住，说以后工作了，忙着赚钱，更是没什么时间住了。舅妈以为我还是21岁……然而过完年，虚岁就是24岁了，其实明明是22岁半。好吧，确实老了。到了尴尬的年纪。按这样算，还有6年就30岁了……这六年要赚好多钱。</p>
</blockquote>
<p>最近听喜马拉雅付费精品中关于年度计划的，提到人生的8个方面,分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。于是根据这个把自己的2016年总结整理了一张思维导图和仿支付宝年账单做了一份年度总结PPT。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="./img/xmind.png" alt="2016年度总结思维导图" title="">
                </div>
                <div class="image-caption">2016年度总结思维导图</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="./img/ppt.jpg" alt="2016年度总结PPT" title="">
                </div>
                <div class="image-caption">2016年度总结PPT</div>
            </figure></p>
<h3 id="未来的路在哪"><a href="#未来的路在哪" class="headerlink" title="未来的路在哪"></a>未来的路在哪</h3><p>1、看周围同事，基本就能看到自己几年后是过着怎样的生活。试想这样的生活是不是自己想要的，如果不是又将做什么来改变呢。老板有时给我们开会也会问：一个员工加入一家公司终究会离开，你是否会认真考虑【我会在这里干多少年？想成为什么样的人】。<br>2、再看看自己的校友，在移动互联网领域比较出名的有杜瑶，CSS参考手册作者（css.doyoe.com），去哪儿网前端技术总监。猎豹移动副总裁陈勇。柴魁元,乐动卓越科技有限公司CTO等等。<br>3、如果仅从开发这条路来看，很容易看到自己的天花板。而且业界都一致认为，程序员是吃青春饭，看自己身边同事就知道年长的非常少。G20放假那次回家，跟老爸聊天，老爸聊到年轻的时候赚点钱容易，年纪大了就不容易了。何况你这工作吃的是青春饭，以后怎么办。我说：到时候再看，转行吧。比如这篇文章：<a href="http://blog.csdn.net/harderxin/article/details/39210779" target="_blank" rel="external">一位工作十年程序员给的忠告</a></p>
<h3 id="打造个人品牌（知识型IP）"><a href="#打造个人品牌（知识型IP）" class="headerlink" title="打造个人品牌（知识型IP）"></a>打造个人品牌（知识型IP）</h3><p>《程序员必读的职业规划书》有提到打造个人品牌；公司年中大会上，我司创始人（前阿里副总裁）也谈到IP；参加的网红经济论坛上更是对网红（IP）有一些深层次的解读；《和秋叶一起学职场技能》书中也有提到如何打造个人品牌。<br>虽然，以前的积累，微博粉丝超过了1千，微信好友快1000，两个QQ的好友基本不重复，超过1400，但这些都是最低层次的无门槛自媒体。</p>
<p>我这名字，在我关注的圈子中，知道比较有名的大咖有小川叔。<br>在公司叫花名（轩辕），于是把我在网络上的各种账号的昵称统一成<strong>轩辕Rowboat</strong>，也算是打造个人品牌的开始吧。</p>
<p>2016年，这一年出现了很多<strong>知识变现</strong>的产品，比如：微信公众号打赏，简书打赏，知乎live，分答，在行，微博的问答，喜马拉雅付费精品等。</p>
<p>原是程序员的彭小六就凭借着知识变现这一红利月入6位数。比如：<br><a href="http://www.jianshu.com/p/7d053c85c0bd" target="_blank" rel="external">《凭着这3个字，我上个月挣了6位数》</a><br>也有程序员靠之前人气等多方面的积累，开一次知乎live，分享知识，就能赚1万+。<br>之前在公众号看到的文章，<a href="http://mp.weixin.qq.com/s?__biz=MzAxNzEyODA2NQ==&amp;mid=2650183908&amp;idx=1&amp;sn=8a1225cdef6acb0cf17eab426b3e899b&amp;chksm=83e8770ab49ffe1cb25da7c55158f078e7ef2921ea46805bb82845fe88fec85e04232f6f6364&amp;scene=0#rd" target="_blank" rel="external">《月入10W真的很难吗？》</a><br>清华大学毕业阿何的一篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzIwODM3MzU1NA==&amp;mid=2247483996&amp;idx=1&amp;sn=e0cb929d9ae282f23c1147e81c81c3fc&amp;chksm=97055001a072d9179d1bb5e1573269c4c4393ee8e347c74f88de08596ce0c2ac5fceb8163c35&amp;scene=0#rd" target="_blank" rel="external">《年轻人，如何挣到自己第一个100万？》</a><br>文尾总结：</p>
<blockquote>
<p>总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤：<br>第一：找到自己的一个特长，把它培养得足够出色<br>第二：找到适合你的特长，又有足够用户注意的平台<br>第三：在这个平台上深耕细作，打造品牌，获得收入<br>每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。</p>
</blockquote>
<p>虽然这类文章有点夸大其词，鸡汤文的感觉，但也不无道理。总之这是赚钱思维的一种转变。</p>
<p>PPT圈内，布衣公子从2012年开始分享自己的PPT作品，他的作品影响着很多人。后来收费，一份作品就能卖到上万元。这是他分享他的故事时分享的五个故事。<br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjQyODY1NA==&amp;mid=2654123389&amp;idx=1&amp;sn=2ccfddafe2502ae5a63c1ce6059afa50&amp;chksm=bd60727c8a17fb6a9e57e94be91decf921dc1778e0a38b32dadc8c5e8007fe6333895cd631b2&amp;scene=0#rd" target="_blank" rel="external">改变我命运的五个故事-布衣公子</a><br>要在大城市生活，培养一种或几种可以「变现」的能力，并且这些能力不受地域的限制，似乎变得重要起来。</p>
<h3 id="时间也是资源"><a href="#时间也是资源" class="headerlink" title="时间也是资源"></a>时间也是资源</h3><p>时间管理是永恒的话题，这篇文章写的挺好：<a href="http://weibo.com/ttarticle/p/show?id=2309404011377055416316" target="_blank" rel="external">毕业三年，你如何与同龄人拉开差距？</a></p>
<h3 id="世界发展太快，需要不断学习"><a href="#世界发展太快，需要不断学习" class="headerlink" title="世界发展太快，需要不断学习"></a>世界发展太快，需要不断学习</h3><p>世界在发展，以前的很多岗位都不存在了。而且未来很多工作可以由机器人来完成，而且机器人比人类做得更优秀。另外年轻人的接触新鲜事物的学习能力相对比较强。那么持续学习，变得更加的重要了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。
    
    </summary>
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的webstorm技巧</title>
    <link href="https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/"/>
    <id>https://lxchuan12.github.io/2016/12/07/20161207-webstrom-skill/</id>
    <published>2016-12-07T14:48:18.000Z</published>
    <updated>2017-06-24T15:25:56.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>webstrom有一些基本的操作</strong><br>1、快速查找<br>2、代码补全<br>3、版本控制<br>4、本地历史<br>5、即时模板<br>6、光标<br>7、代码格式化等<br><a id="more"></a></p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>双击shift搜索：快速查找。文件，函数名等。</p>
</blockquote>
<p>template模板可以设置。</p>
<p>光标定位到相关位置。比如tilte,body<br>每次修改的历史：local  history。</p>
<p>多光标的功能。<br>1、查找替换，ctrl+R<br>2、alt+鼠标选择。</p>
<p> 3、alt+单击。</p>
<p>4、格式化代码：ctrl+alt+L</p>
<p> 菜单，code——reformat code。</p>
<p>5、快捷键可以自定义设置。 可以通过快捷键名称来查找。也可以通过怎么使用来查找快捷键，然后对其进行修改。<br>webstrom预设了许多快捷键，可以自己选择。与原来的IDE快捷键相同。</p>
<h4 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a><strong>Emmet</strong></h4><p>详情参见：<br><a href="http://www.iteye.com/news/27580" target="_blank" rel="external">Emmet：HTML/CSS代码快速编写神器</a></p>
<p>1、Tab键，缩写的补全<br>2、li中间写完，按enter键，光标直接定位到接下来的一个。<br>3、嵌套结构：<br>>  +  ^      <em>  ()<br>子元素，同级，往上一级，重复，（）<br>4、属性<br># （id）. （类）[]自定义属性<br>div#container.container<br> $<br>ul&gt;li.item-$</em>5<br>{}文本<br>p{click me}<br>lorem没有意义的文字。用于排版。<br>用法：lorem100<br>注意事项：光标定位在最后（最想展开的）。<br>不能有空格。<br>比如：<br>css中，bt:border-top<br>m10:margin:10px;<br>m10-20:margin:10px 20px;<br>bdrs10:border-radius:10px;<br>df：display：flex;</p>
<p> 设置前缀。<br>默认关闭这个开关。可以用其他工具来实现。、<br>html:5,sublime text等编辑器可以安装emmet插件。</p>
<h4 id="进阶操作一——常见快捷键"><a href="#进阶操作一——常见快捷键" class="headerlink" title="进阶操作一——常见快捷键"></a>进阶操作一——常见快捷键</h4><p>操作，快捷键。</p>
<p>光标放在相对应的标签上，按F1，可以显示相关的描述，关联的站点等。<br>js也是如此，参数列表等。<br>比如</p>
<p></p><p>hello world</p><br>要包裹在一个div中，选择这代码，ctrl+alt+T,选择第一个，输入div就变包裹在div中。<p></p>
<p>——7<br>1、注释与取消注释<br>ctrl+/<br>2、选择<br>选中子元素，alt+上/下<br>3、粘贴<br>ctrl+shift+V，最近粘贴板中的内容。<br>4、删除当前行，<br>ctrl+退格键。<br>5、当前行上、下面加入一行<br>上面加入一行。ctrl+alt+enter<br>下面加入一行。ctrl+shift+enter.<br>这样不需要刻意定位光标的位置。其实键盘上有（home,end)键。<br>6、折叠代码，ctrl++（展开），ctrl+-(折叠)<br>ctrl+shift++,ctrl+shift+-,所有可以折叠的地方全部折叠。在css中，js,html中都是如此。<br>7、相邻位置代码换位置。<br>alt+shift+上、下键。选中一段代码也可以让其上下移动。<br>8、闭合标签，定位在两个标签位置。ctrl+m键。引号，括号，{}等也适用。window下好像无效。<br>9、前进、后退到上一次编辑的地方。ctrl+alt+左右键。<br>10、转到上一次编辑的地方。ctrl+shift+backspace键。<br>11、最近使用的文件，ctrl+E<br>——8<br>1、img标签，知道图片宽和高。<img src="">方式1、输入路径，宽和高，按住Tab键可以自动补全。<br>方式2、放在图片上，按F1图片预览，固定预览框。或者悬浮在文字上方。<br>方式3、按住shift，鼠标浮在路径上，就可以看到图片的预览了。<br>2、color:#999;色块上点击即可选择修改颜色。亮度（竖向）和透明度（横向）可以调节。</p>
<h4 id="进阶操作二——重命名"><a href="#进阶操作二——重命名" class="headerlink" title="进阶操作二——重命名"></a>进阶操作二——重命名</h4><p>1、重命名，</p>
<p></p><p>hello world</p>，把光标放在标签上，<br>ctrl+T,第一个就是重命名。window下试用无效。shift+F6重命名。2、其实直接写即可呀。<br>对话框会显示有相同的地方，右击，排查或包含include，exclude.点击执行，do refactor。侧边有一些功能。<br>2、函数名称，参数重命名。<br>html,css,js中都可以重命名，类名，颜色，可以预览，避免把一些框架库里的相同东西修改了。、<br>文件或文件夹也可以重命名。所有引用的地方也被修改了。<p></p>
<h4 id="进阶操作三——代码检查"><a href="#进阶操作三——代码检查" class="headerlink" title="进阶操作三——代码检查"></a>进阶操作三——代码检查</h4><p>webstrom使用了静态代码分析。<br>不仅检查编译错误，<br>而且代码效率低下，未使用的代码，非本地化的字符串，无法解析的代码，内存泄露，甚至编写问题等等。<br>提示分为：错误，警告和正确。红色，橙黄色，或者绿色。<br>一般来说是对整个项目进行检查的。也可以自己配置检查的范围。<br>也可以自己运行检查。–&gt;code-&gt;Inspect code</p>
<p>webstrom检查出来的不代表真的有错，还需要人工自己检查。<br>一般在文件中，F2键可以在各个错误中切换。<br>alt+enter，可以看到提示。（右侧的提示）<br>规则自己设置，搜索inspec</p>
<p>js是静态的校验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;webstrom有一些基本的操作&lt;/strong&gt;&lt;br&gt;1、快速查找&lt;br&gt;2、代码补全&lt;br&gt;3、版本控制&lt;br&gt;4、本地历史&lt;br&gt;5、即时模板&lt;br&gt;6、光标&lt;br&gt;7、代码格式化等&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="https://lxchuan12.github.io/categories/tool/"/>
    
    
      <category term="tool" scheme="https://lxchuan12.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>数组方法splice和数组去重</title>
    <link href="https://lxchuan12.github.io/2016/10/29/20161029-array-splice-uniq/"/>
    <id>https://lxchuan12.github.io/2016/10/29/20161029-array-splice-uniq/</id>
    <published>2016-10-29T14:08:18.000Z</published>
    <updated>2016-10-29T15:47:36.020Z</updated>
    
    <content type="html"><![CDATA[<p>splice方法有删除、替换、添加的功能。修改原数组……<a id="more"></a></p>
<blockquote>
<p>语法：<br>array.splice(start, deleteCount[, item1[, item2[, …]]])</p>
</blockquote>
<p><strong>start</strong><br>整数，如果大于数组长度，itemN有值则为添加否则不添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3];</div><div class="line">//arr.splice(4,2);</div><div class="line">//console.log(arr);//[1,2,3]</div><div class="line">arr.splice(4,2,2);</div><div class="line">console.log(arr);//[1,2,3,2]</div></pre></td></tr></table></figure></p>
<p>如果为负数，则从数组末尾倒数第一位。<br><strong>detecount</strong><br>整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。<br><strong>itemN</strong><br>要添加进数组的元素。如果不指定，则 splice() 只删除数组元素。<br><strong>返回值</strong><br>由被删除的元素组成的一个数组。未删除就是返回空数组。</p>
<hr>
<p><strong>删除</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3];</div><div class="line">arr.splice(1,2);</div><div class="line">console.log(arr);//[1]</div></pre></td></tr></table></figure></p>
<p><strong>替换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">arr.splice(1,2,&apos;2&apos;,&apos;3&apos;);</div><div class="line">console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;]</div></pre></td></tr></table></figure></p>
<p><strong>添加</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">arr.splice(1,0,&apos;2&apos;,&apos;3&apos;);</div><div class="line">console.log(arr);//[&apos;a&apos;,&apos;2&apos;,&apos;3&apos;，&apos;b&apos;,&apos;c&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p><a href="http://www.nowcoder.com/practice/0b5ae9c4a8c546f79e2547c0179bfdc2?tpId=2&amp;tqId=10855&amp;rp=1&amp;ru=/ta/front-end&amp;qru=/ta/front-end/question-ranking" target="_blank" rel="external">题目：牛客网数组去重试题</a><br>为 Array 对象添加一个去除重复项的方法</p>
<blockquote>
<p><strong>输入例子</strong>：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’, ‘a’, NaN].uniq()<br><strong>输出例子</strong>：[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’]</p>
</blockquote>
<p><strong>解答</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Array.prototype.uniq = function () &#123;</div><div class="line">    var hasNaN = false;</div><div class="line">    for(var i=0;i&lt;this.length;i++)&#123;</div><div class="line">        if(this[i]!==this[i])hasNaN=true;</div><div class="line">        for(var j=i+1;j&lt;this.length;j++)&#123;</div><div class="line">            if(this[i]===this[j]||(hasNaN&amp;&amp;this[j]!==this[j]))&#123;</div><div class="line">                this.splice(j,1);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>较复杂的数组，一般思路是先判断类型再做去重。<br>参考资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="external">MDN:Array.prototype.splice()</a><br><a href="http://caibaojian.com/js-splice-element.html" target="_blank" rel="external">js删除数组里的某个元素</a><br><a href="http://blog.jobbole.com/33099/" target="_blank" rel="external">从 JavaScript 数组去重谈性能优化(玉伯)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;splice方法有删除、替换、添加的功能。修改原数组……
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>(转)背景图片固定不随内容滚动而滚动</title>
    <link href="https://lxchuan12.github.io/2016/10/16/20161016-background-attachment/"/>
    <id>https://lxchuan12.github.io/2016/10/16/20161016-background-attachment/</id>
    <published>2016-10-16T14:48:38.000Z</published>
    <updated>2016-10-17T12:48:14.594Z</updated>
    
    <content type="html"><![CDATA[<p>有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法……<a id="more"></a></p>
<h3 id="第一种：背景附着属性-background-attachment-，代码如下："><a href="#第一种：背景附着属性-background-attachment-，代码如下：" class="headerlink" title="第一种：背景附着属性(background-attachment)，代码如下："></a>第一种：背景附着属性(background-attachment)，代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;背景附着属性 background-attachment&lt;/title&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">body &#123;background-image:url(../images/css_tutorials/background.jpg); background-repeat:no-repeat; background-attachment:fixed&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;这个HTML使用了CSS的background-attachment属性，将背景图片固定，不随内容滚动而滚动。&lt;p&gt;</div><div class="line">&lt;p&gt;背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。&lt;/p&gt;</div><div class="line">&lt;p&gt;background-attachment要和background-image一起用。&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="第二种：背景位置属性-background-position-，代码如下："><a href="#第二种：背景位置属性-background-position-，代码如下：" class="headerlink" title="第二种：背景位置属性(background-position)，代码如下："></a>第二种：背景位置属性(background-position)，代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;背景位置属性 background-position&lt;/title&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">body &#123;background-image:url(../images/css_tutorials/background.jpg);background-repeat:no-repeat; background-position:20px 60px&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;这个HTML使用了CSS的background-position属性。这个属性和background-image属性连在一起使用，决定了背景图片的最初位置。&lt;/p&gt;</div><div class="line">&lt;p&gt;上面的代码表示背景图片的初始位置距离网页最左面20px，距离网页最上面60px。&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="第三种：背景属性-background-，代码如下："><a href="#第三种：背景属性-background-，代码如下：" class="headerlink" title="第三种：背景属性(background)，代码如下："></a>第三种：背景属性(background)，代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;背景属性 background&lt;/title&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">body &#123;background:#99FF00 url(../images/css_tutorials/background.jpg) no-repeat fixed 40px 100px&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;这个属性是设置背景相关属性的一种快捷的综合写法， 包括background-color, background-image, background-repeat, backgroundattachment, background-position。&lt;/p&gt;</div><div class="line">&lt;p&gt;这个HTML所用的背景属性表示，网页的背景颜色是翠绿色，背景图片是background.jpg图片，背景图片不重复显示，背景图片不随内容滚动而动，背景图片距离网页最左面40px，距离网页最上面100px。&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.1280.cc/article/1806.html" target="_blank" rel="external">原文：背景图片固定不随内容滚动而滚动</a><br>源自<a href="http://www.nowcoder.com/test/question/done?tid=5696897&amp;qid=44708" target="_blank" rel="external">今日头条2017前端工程师实习生笔试题</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">5、下面哪条声明能固定背景图片（）</div><div class="line">正确答案: A   你的答案: A (正确)</div><div class="line"></div><div class="line">background-attachment:fixed;</div><div class="line">background-attachment:scroll;</div><div class="line">background-origin: initial;</div><div class="line">background-clip: initial;</div></pre></td></tr></table></figure></p>
<p>——————————————————————————<br><a href="http://blog.csdn.net/lai_xu/article/details/46954249" target="_blank" rel="external">置换元素与非置换元素</a><br>a) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。<br>b) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">4、请选出所有的置换元素（）</div><div class="line">正确答案: A B C D   你的答案: A B C D (正确)</div><div class="line"></div><div class="line">A、img</div><div class="line">B、input</div><div class="line">C、textarea</div><div class="line">D、select</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些网站希望将背景图片固定不随内容滚动而滚动，用CSS代码写主要有以下三种写法……
    
    </summary>
    
      <category term="CSS" scheme="https://lxchuan12.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://lxchuan12.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>函数的length属性</title>
    <link href="https://lxchuan12.github.io/2016/10/09/20161009-function-length/"/>
    <id>https://lxchuan12.github.io/2016/10/09/20161009-function-length/</id>
    <published>2016-10-09T13:30:12.000Z</published>
    <updated>2016-10-17T12:50:41.889Z</updated>
    
    <content type="html"><![CDATA[<p>看<a href="http://es6.ruanyifeng.com/#docs/function#函数的length属性" target="_blank" rel="external">《ES6标准入门》中提到函数的length属性</a>，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……<a id="more"></a>查阅了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="external">MDN Function.length</a>是这样描述的：</p>
<blockquote>
<p>length 是函数对象的一个属性值，指明该函数期望多少个参数，意即形参的个数。数量不包括剩余参数。相比之下，arguments.length 是函数被调用时实际传参的个数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test(a,b,c) &#123;&#125;</div><div class="line">test.length // 3</div><div class="line"></div><div class="line">function test(a,b,c,d) &#123;&#125;</div><div class="line">test.length // 4</div></pre></td></tr></table></figure>
<p>看起来很简单，但是也有特殊的，如果函数内部是通过arguments 调用参数，而没有实际定义参数的话，length只会的得到0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function test() &#123; console.log( arguments );&#125;</div><div class="line">test.length // 0</div></pre></td></tr></table></figure></p>
<p>这个函数确实可以传入参数，而且内部也调用了参数，但是length却无法得知传入的参数的个数。<br>只能在函数执行的时候通过arguments.length得到实参个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test() &#123; console.log( arguments.length );&#125;</div><div class="line">test(1,2,3); // 输出 3</div><div class="line">test(1,2,3,4); // 输出 4</div></pre></td></tr></table></figure></p>
<p>所以函数的length属性只能得到他的形参个数，而无法得知实参个数。</p>
<p>参考链接：<a href="http://www.cnblogs.com/52cik/p/js-function-length.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">js小记 function 的 length 属性</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function#函数的length属性&quot;&gt;《ES6标准入门》中提到函数的length属性&lt;/a&gt;，看到有函数的length属性这一说法，其实之前一直都不知道有。并且不知道这个length有何应用……
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://lxchuan12.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式知识点</title>
    <link href="https://lxchuan12.github.io/2016/09/22/20160922-RegExp/"/>
    <id>https://lxchuan12.github.io/2016/09/22/20160922-RegExp/</id>
    <published>2016-09-22T15:48:12.000Z</published>
    <updated>2016-10-23T15:11:22.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式(RegExp)"></a>正则表达式(RegExp)</h2><h3 id="1、什么是正则表达式"><a href="#1、什么是正则表达式" class="headerlink" title="1、什么是正则表达式"></a>1、什么是正则表达式</h3><p>1.1 什么叫“正则”<br>—规则、模式<br>—强大的字符串匹配工具……<a id="more"></a><br>1.2 正则的写法<br>–new RegExp(“a”,”ig”),需要传参只能用这种方案。<br>–/a/</p>
<h3 id="2、正则表达式常用方法"><a href="#2、正则表达式常用方法" class="headerlink" title="2、正则表达式常用方法"></a>2、正则表达式常用方法</h3><p>2.1 test<br>—字符串判断<br>—返回真假<br>—正则.test(字符串)<br>—例子：是否有不是数字的字符<br>2.2 search<br>字符串搜索<br>–返回出现的位置<br>–字符串.search(正则)<br>–忽略大小写：i——ignore<br>2.3 match<br>获取匹配的项目,<br>–返回数组<br>–量词：+<br>–全局匹配：g——global<br>–例子：找出所有数字<br>2.4 replace<br>替换所有匹配<br>–返回替换后的字符串<br>–字符串.replace(正则,想替换的)<br>–例子：敏感词过滤<br>-例子：统计字符串中每个字符的出现频率<br>/**<br>统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率</p>
<ol>
<li>不限制 key 的顺序</li>
<li>输入的字符串参数不会为空</li>
<li>忽略空白字符<br>输入例子:<br>count(‘hello world’)<br>输出例子:<br>{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function count_2(str) &#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    // \S:非空白符</div><div class="line">    str.replace(/\S/g,function(s)&#123;</div><div class="line">        !obj[s]?obj[s]=1:obj[s]++;</div><div class="line">    &#125;)</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">console.log(count_2(&apos;hello world&apos;));</div></pre></td></tr></table></figure>
</li>
</ol>
<p>–匹配子项<br>–例子：日期格式化</p>
<h3 id="3、正则表达式字符类"><a href="#3、正则表达式字符类" class="headerlink" title="3、正则表达式字符类"></a>3、正则表达式字符类</h3><p>3.1 任意字符<br>-[abc]<br>–例子：o[usb]t——obt、ost、out<br>3.2 范围<br>-[a-z]、[0-9]<br>–例子：id[0-9]——id0、id5<br>3.3 排除<br>-[^a]<br>–例子：o[^0-9]t——oat、o?t、o t<br>3.4 组合<br>-[a-z0-9A-Z]<br>实例：偷小说<br>过滤HTML标签<br>–自定义innerText方法</p>
<h3 id="4、转义字符"><a href="#4、转义字符" class="headerlink" title="4、转义字符"></a>4、转义字符</h3><p>转义字符<br>.（点）——任意字符<br>\d（[0-9]）、\w（[a-zA-Z0-9_]）、\s（空白符） 、\b（单词边界）<br>\D（[^\d]）、\W（[^\w]）、\S（[^\s]） 、\B（[^\b]）<br>\1    重复子项<br>例子<br>–获取class元素<br>–找重复项最多的字符和个数</p>
<h3 id="5、量词"><a href="#5、量词" class="headerlink" title="5、量词"></a>5、量词</h3><p>5.1 什么是量词<br>出现的次数<br>{n,m}，至少出现n次，最多m次<br>例子：查找QQ号<br>5.2 常用量词<br>{m,n}:m到n次<br>{n,}:至少n次<br>{n}:正好n次<br>*:任意次  {0,}<br>？:零次或一次  {0,1}<br>+:一次或任意次{1,}</p>
<p>正则收尾<br>^ 开始<br>$ 结束<br>例子<br>–是不是QQ号<br>–去掉前后空格</p>
<h3 id="6、常用正则例子"><a href="#6、常用正则例子" class="headerlink" title="6、常用正则例子"></a>6、常用正则例子</h3><p>高级表单校验<br>匹配中文：[\u4e00-\u9fa5]<br>行首行尾空格：^\s<em>|\s</em>$<br>Email：^\w+@[a-z0-9]+(.[a-z]+){1,3}$</p>
<p>网址：[a-zA-z]+://[^\s]*<br>QQ号：[1-9][0-9]{4,9}<br>邮政编码：[1-9]\d{5}<br>身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x</p>
<h3 id="7、正则与面向对象"><a href="#7、正则与面向对象" class="headerlink" title="7、正则与面向对象"></a>7、正则与面向对象</h3><p>把方法包在一个空间里<br>有人管他叫——命名空间<br>在公司里，把同一类方法，包在一起<br>JSON的使用<br>把之前的方法，包在一起</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">MDN RegExp</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正则表达式-RegExp&quot;&gt;&lt;a href=&quot;#正则表达式-RegExp&quot; class=&quot;headerlink&quot; title=&quot;正则表达式(RegExp)&quot;&gt;&lt;/a&gt;正则表达式(RegExp)&lt;/h2&gt;&lt;h3 id=&quot;1、什么是正则表达式&quot;&gt;&lt;a href=&quot;#1、什么是正则表达式&quot; class=&quot;headerlink&quot; title=&quot;1、什么是正则表达式&quot;&gt;&lt;/a&gt;1、什么是正则表达式&lt;/h3&gt;&lt;p&gt;1.1 什么叫“正则”&lt;br&gt;—规则、模式&lt;br&gt;—强大的字符串匹配工具……
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="RegExp" scheme="https://lxchuan12.github.io/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>gitflow工作流</title>
    <link href="https://lxchuan12.github.io/2016/09/20/20160920-gitflow%20workflow/"/>
    <id>https://lxchuan12.github.io/2016/09/20/20160920-gitflow workflow/</id>
    <published>2016-09-20T09:30:32.000Z</published>
    <updated>2016-09-27T15:06:56.001Z</updated>
    
    <content type="html"><![CDATA[<p>记得今年6月份参加了一次<code>coding</code>技术小馆杭州站的活动，讲的就是<code>git</code>和<code>gitflow</code>相关的。讲师当场也写代码。那是第一次<code>gitflow</code>工作流。那时在想我什么时候也能在舞台上讲开发技术……<a id="more"></a><br>今天就碰到一个关于<code>gitflow</code>工作流的问题。<br>使用<code>sourceTree</code>软件时，建立工作流。一般来说，是切换到<code>master</code>上。再建立工作流。我不小心，直接在<code>develop</code>分支上建了工作流。切换到<code>master</code>分支上。再打<code>hotfix</code>(修复补丁)时，发现无法成功。</p>
<p>谷歌搜索发现解决方案：</p>
<blockquote>
<p>1、找到项目当前文件夹中的<code>.git/config</code>，把配置文件中的<code>gitflow</code>*相关的全部删除。<br>2、关闭再重新打开<code>SourceTree</code>。<br>3、重新在<code>master</code>上建立工作流，再打<code>hotfix</code>。<br>发现成功了。</p>
</blockquote>
<p>参考链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">Git 工作流程</a><br><a href="http://blog.csdn.net/wyc_cs/article/details/51458990" target="_blank" rel="external">Git Flow 在团队中的最佳实践 – SourceTree的使用</a><br><a href="https://blog.sourcetreeapp.com/2012/08/01/smart-branching-with-sourcetree-and-git-flow/" target="_blank" rel="external">Smart branching with SourceTree and Git-flow</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得今年6月份参加了一次&lt;code&gt;coding&lt;/code&gt;技术小馆杭州站的活动，讲的就是&lt;code&gt;git&lt;/code&gt;和&lt;code&gt;gitflow&lt;/code&gt;相关的。讲师当场也写代码。那是第一次&lt;code&gt;gitflow&lt;/code&gt;工作流。那时在想我什么时候也能在舞台上讲开发技术……
    
    </summary>
    
      <category term="git" scheme="https://lxchuan12.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://lxchuan12.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>camelCase()转驼峰方法实现</title>
    <link href="https://lxchuan12.github.io/2016/09/15/20160915-camelCase/"/>
    <id>https://lxchuan12.github.io/2016/09/15/20160915-camelCase/</id>
    <published>2016-09-15T09:30:32.000Z</published>
    <updated>2017-06-04T11:42:10.400Z</updated>
    
    <content type="html"><![CDATA[<p>今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 字符串操作方式</div><div class="line">function camelCase_1(str)&#123;</div><div class="line">    var i=1,</div><div class="line">        arr = str.split(&apos;-&apos;),</div><div class="line">        len = str.split(&apos;-&apos;).length;</div><div class="line">    var result = arr[0];</div><div class="line">    for(;i&lt;len;i++)&#123;</div><div class="line">        result += arr[i].substring(0,1).toUpperCase()+arr[i].substring(1);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">function camelCase_2(str)&#123;</div><div class="line">    var arr = str.split(&apos;-&apos;);</div><div class="line">    for (var i=1;i&lt;arr.length;i++) &#123;</div><div class="line">        arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substring(1);</div><div class="line">    &#125;</div><div class="line">    return  arr.join(&apos;&apos;);</div><div class="line">&#125;</div><div class="line">// 正则方式</div><div class="line">// 分组概念 $0 代表整体，$1 第一个匹配子项</div><div class="line">function camelCase_3(str)&#123; </div><div class="line">    return str.replace(/-(\w)/g,function($0,$1)&#123;</div><div class="line">        return $1.toUpperCase();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看下jquery实现方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//str.replace(/^-ms-/,&apos;ms-&apos;)是有IE下有，-ms-前缀的，比如转换成msTransform，而其他转换成首字母大写，如：WebkitTransform</div><div class="line">function camelCase_2(str)&#123;</div><div class="line">    return str.replace(/^-ms-/,&apos;ms-&apos;).replace(/-([\da-z])/gi,function(all,letter)&#123;</div><div class="line">        return letter.toUpperCase();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看zeptojs实现方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//zepto.js实现方式：没处理-ms-，兼容性IE10+，但依旧有很多IE10依旧要加-ms-前缀的css3属性。为啥zeptojs没实现呢，难道还没碰到这个bug？</div><div class="line">//并且，空字符串写toUpperCase()依旧是空字符串。所以不需要写三目运算。</div><div class="line">function camelCase_3(str)&#123; </div><div class="line">    return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : &apos;&apos; &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var webkitstr = &apos;-webkit-transfrom&apos;;</div><div class="line">var msstr = &apos;-ms-transfrom&apos;;</div><div class="line">console.log(camelCase_1(webkitstr));//WebkitTransfrom</div><div class="line">console.log(camelCase_1(msstr));    //MsTransfrom</div><div class="line">console.log(camelCase_2(webkitstr));//WebkitTransfrom</div><div class="line">console.log(camelCase_2(msstr));    //MsTransfrom</div><div class="line">console.log(camelCase_3(webkitstr));//WebkitTransfrom</div><div class="line">console.log(camelCase_3(msstr));    //MsTransfrom</div><div class="line">console.log(camelCase_4(webkitstr));  //WebkitTransfrom</div><div class="line">console.log(camelCase_4(msstr));    //msTransfrom</div><div class="line">console.log(camelCase_5(webkitstr));//WebkitTransfrom</div><div class="line">console.log(camelCase_5(msstr));    //MsTransfrom</div></pre></td></tr></table></figure></p>
<p>看到这里，其实很想给zepto提pull request的。但还是没有提。</p>
<p>小结：分析jquery/zeptojs源码，发现能学到很多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天中秋节，放假三天。看zeptojs文档时，看到camelCase()转驼峰的方法，就想着也不难，就自己实现了一遍……
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
      <category term="jquery" scheme="https://lxchuan12.github.io/tags/jquery/"/>
    
      <category term="zepto" scheme="https://lxchuan12.github.io/tags/zepto/"/>
    
  </entry>
  
  <entry>
    <title>window.location-浏览器定位和导航</title>
    <link href="https://lxchuan12.github.io/2016/09/12/20160912-window.location/"/>
    <id>https://lxchuan12.github.io/2016/09/12/20160912-window.location/</id>
    <published>2016-09-12T14:55:32.000Z</published>
    <updated>2017-06-19T14:16:43.206Z</updated>
    
    <content type="html"><![CDATA[<p>平时用window.location.href比较多。<br>但却经常会忽略window.location下的其他属性……<a id="more"></a><br>并且很多时候需要对链接问号后面字符串做处理，一般使用split()分割，再取。而实际上，有window.location.search可以获取。<br>一图胜千言<br>![图解url]<br><img src="/2016/09/12/20160912-window.location/url.png" alt="图解url" title="图解url"></p>
<p><strong>url</strong>: 统一资源定位符 (Uniform Resource Locator, URL)<br><strong>href</strong>: 当前页面的url<br><strong>protocol</strong>: 协议<br><strong>hostname</strong>: 主机名<br><strong>port</strong>: 端口号<br><strong>host</strong>: 主机名+端口号<br><strong>pathname</strong>: 当前页面的路径和文件名<br><strong>origin</strong>:协议+主机名加端口号（新API）<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location" target="_blank" rel="external">MDN location</a></p>
<p>![图解location]<br><img src="/2016/09/12/20160912-window.location/location.png" alt="图解location" title="图解location"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时用window.location.href比较多。&lt;br&gt;但却经常会忽略window.location下的其他属性……
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/tags/JavaScript/"/>
    
      <category term="BOM" scheme="https://lxchuan12.github.io/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>jQuery的几种写法探析</title>
    <link href="https://lxchuan12.github.io/2016/09/11/20160911-Several-writing-of-jquery/"/>
    <id>https://lxchuan12.github.io/2016/09/11/20160911-Several-writing-of-jquery/</id>
    <published>2016-09-11T13:41:23.000Z</published>
    <updated>2016-09-11T13:55:03.057Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写法一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">	//code here</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>写法二：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;</div><div class="line">	//code here</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>写法三：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$().ready(function()&#123;</div><div class="line">	//code here</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>默认参数就是document，所以可以省略不写。<br><strong>写法四：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function($)&#123;</div><div class="line">	//code here</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>
<p>这种写法的最大好处是形成闭包。在内部定义的函数和变量只能在此范围内有效。形成是否函数函数、私有变量的概念。不会与其他类库，框架产生冲突。<br>以上四种方法都是同一个意思，一般来说使用<strong>写法一</strong>比较多。<br><strong>此外，</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(window).load = function()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//等价于：</div><div class="line">window.onload = function()&#123;</div><div class="line">	//code here</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(JS中的事件，不加on，比如单击事件：click,双击事件：dblclick)</p>
<p><strong>window.onload = function(){}</strong>与<strong>$(funtion(){})</strong>两者的区别是：<br><strong>$(funtion(){})</strong>：<br>1、在DOM加载完成后就可以可以对DOM进行操作。<br>一般情况一个页面响应加载的顺序是：域名解析-加载html-加载js和css-加载图片和视频等其他信息。<br>那么Dom Ready应该在“加载js和css”和“加载图片等其他信息”之间，就可以操作Dom了。<br>2、能多次使用，按序执行。<br><strong>window.onload = function(){}</strong>：<br>1、在网页中所有元素(包括元素的所有关联文件)完全加载到浏览器后才执行，即JavaScript 此时可以访问网页中的所有元素。<br>2、不能多次使用，后者会覆盖前者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;写法一：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$(function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//code here&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="jQuery" scheme="https://lxchuan12.github.io/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="https://lxchuan12.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 媒体查询media</title>
    <link href="https://lxchuan12.github.io/2016/09/09/20160909-CSS3-@media/"/>
    <id>https://lxchuan12.github.io/2016/09/09/20160909-CSS3-@media/</id>
    <published>2016-09-09T12:50:42.000Z</published>
    <updated>2016-09-09T13:20:44.079Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3 媒体查询media，其实CSS2也有media，只是基本不用……<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@media only screen and (max-width:375px)&#123;</div><div class="line">    .box&#123;</div><div class="line">        background:#f00!important;</div><div class="line">        /*加上！important才有效。*/</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">.box&#123;</div><div class="line">	width:100px;</div><div class="line">	height:100px;</div><div class="line">	background:#000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>媒体查询@media需要配合meta标签使用才有效。<br>简版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>完整版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>其中minimal-ui表示<br>参考链接：<br><a href="http://36kr.com/p/210516.html" target="_blank" rel="external">iOS 7.1的Safari为meta标签新增minimal-ui属性，在网页加载时隐藏地址栏与导航栏</a><br><a href="http://stackoverflow.com/questions/24889100/ios-8-removed-minimal-ui-viewport-property-are-there-other-soft-fullscreen" target="_blank" rel="external">iOS 8 removed “minimal-ui” viewport property, are there other “soft fullscreen” solutions?</a><br>取值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@media screen and (max-width:320px)&#123;</div><div class="line">	/*视窗宽度&lt;=320px*/</div><div class="line">&#125;</div><div class="line">@media screen and (min-width:769px)&#123;</div><div class="line">	/*视窗宽度&gt;=769px*/</div><div class="line">&#125;</div><div class="line">@media screen and (min-width:769px) and (max-width:1000px)&#123;</div><div class="line">	/*769px&lt;=视窗宽度&lt;=1000px*/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>几道判断题：<br>1、媒体查询条件中，（max-width:320px）表示的是：<br>A. 当视窗宽度小于等于320px时。<br>2、要做响应式网站，就必须设置viewport<br>A. √<br>3、device-width是viewport的默认宽度<br>B、×<br>4、viewport的默认宽度就是屏幕的水平分辨率<br>B、×</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS3 媒体查询media，其实CSS2也有media，只是基本不用……
    
    </summary>
    
      <category term="css3" scheme="https://lxchuan12.github.io/categories/css3/"/>
    
    
      <category term="css3" scheme="https://lxchuan12.github.io/tags/css3/"/>
    
      <category term="media" scheme="https://lxchuan12.github.io/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>我是如何踏上前端这条路的</title>
    <link href="https://lxchuan12.github.io/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/"/>
    <id>https://lxchuan12.github.io/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/</id>
    <published>2016-09-07T13:48:12.000Z</published>
    <updated>2017-06-24T15:13:21.115Z</updated>
    
    <content type="html"><![CDATA[<p>感觉最近<strong>我是如何XXX的</strong>这类标题挺火的。<br>杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。<a id="more"></a><br><strong>1、刚好可以对现在大四迷茫的学弟学妹们，有些指引</strong>。<br><strong>2、还可以借此回忆下大学生活</strong>。<br><strong>3、锻炼自己写长文的逻辑能力</strong>。<br><strong>当然，学习是座大山，人们沿着不同的路登山，分享着自己看到的风景，别人不一定看得到你看到的风景，体会得了你的心情。</strong></p>
<h3 id="接触前端"><a href="#接触前端" class="headerlink" title="接触前端"></a>接触前端</h3><p>2012年，那年大一，只记得上学期参加了四个社团，参加社团的各种活动，比较忙，另外自己收集一些电子书放到我那一点都不智能的手机上看。下学期，我所在的社团计算机协会（后文简称计协），当时教网页制作（嗯，那时不叫前端开发），当然我报名去参加了。比我们大一级的学长用着Dreamweaver软件 给我们教学，超链接，图片，音乐，视频，FLASH等。总之感觉很有趣。也要我们做出一些作品，交作业。但那时我并没有电脑。所以就没做。</p>
<h3 id="江西省网页制作与设计技能大赛"><a href="#江西省网页制作与设计技能大赛" class="headerlink" title="江西省网页制作与设计技能大赛"></a>江西省网页制作与设计技能大赛</h3><p>大二任职计协会长，举办各类活动。也没怎么学习前端开发之类的知识。学习方面好像也就是平时上上课而已，再就是学习电脑方面的技巧，帮助别人解决电脑问题，为此也写了挺多这类技术文章。比如：<a href="http://user.qzone.qq.com/1019963719/blog/1437915015" target="_blank" rel="external">【教程】Ｕ盘、硬盘安装原版win7、8.1、10系统</a>,<a href="http://user.qzone.qq.com/1019963719/blog/1414836306" target="_blank" rel="external">近期上网拨号客户端出现拨号异常、711错误解决方案</a>。<strong>在大学，懂点电脑，会装几个软件，重装个系统，在别人眼中就会被看做是大神，并且很受欢迎</strong>。后来实在忙，就写了篇文章：<a href="http://user.qzone.qq.com/1019963719/blog/1413177913" target="_blank" rel="external">对不起，我不能帮你修电脑了</a><br>转眼间，就到了2014年4月（大二下学期），我所在的信息学院，组织参加省级网页大赛，同时派老师给予培训指导。这时，老师N每周四（或五）给我们上了几周课，主要讲HTML和CSS，还给我们他录制的视频，当时觉得老师好厉害。后来让我们出作品，我们就找设计（陶美）学院的学生给我们设计网页视觉稿。虽然她们学的是设计，但也不是很懂网页设计这块。于是我就自己参照一个视觉比较好的网站，自己仿照着写了一个。当时还是比较忙，只有晚上有时间，所以总共八个页面，好像写了将近10天。主要用了HTML，CSS，js，jquery。现在放在github上，点击可以访问，<a href="http://lxchuan12.github.io/Fashion-Studio/">时尚影楼</a>,那时并不是很懂js和jquery。后来比赛结果出来了，竟然是省级一等奖。其实一等奖有挺多的。这次网页赛，我们学校获得了很多奖项。大二末，图书馆一老师找到我们，想让我们暑假回去学点PHP，开学好让我们上手，帮他做项目。<br>我们信息学院邀请了10级计科的H学长，给我们这些迷茫的学弟学妹开了一次经验分享会，说到腾讯招人的标准。因为他就是课题组研发部的一员。说到课题组研发部的各种好处，跟着里面的老师L学习PHP，学到60％就够找好工作了。总之意思就是要进课题组学习。<br>大二暑假，家里没网，我就在学校，下载好各种PHP学习资源，暑假就在家看着PHP相关的视频等，一套PHP视频也是100多集，基本看完了，也写了些代码。当时也学了javascript，一套JS视频100多集没有看完。其实到后来基本都忘了。另外，大二暑假，线上面试了乔布简历，通过成为了乔布简历校园大使。</p>
<h3 id="加入课题组研发部"><a href="#加入课题组研发部" class="headerlink" title="加入课题组研发部"></a>加入课题组研发部</h3><p>大三上学期，卸任了计协会长，本以为这是大学最后一个职务，谁知这只是第一个。同学A，同学B跟着图书馆老师做PHP的项目。而我此时看着没啥事，就玩起了PPT，新媒体运营，又相继任职了<strong>校园网络中心团队的队长</strong>（关于这个我也写了篇文章<a href="http://user.qzone.qq.com/1019963719/blog/1439715599" target="_blank" rel="external">谈一谈校园网管这一工作</a>，一直任职到大四上学期）。<strong>校友总会志愿团常务团长</strong>（后来由于组织性质缘故，2014年11月，不到两个月就默认退出了），<strong>乔布简历江西省副主管</strong>，那时班上竞选班干，班主任说我们计协会长卸任了怎么不竞选一个职务。我说不用了，我并没有说还有这么多职务。上学期刚开始不久，我们专业老师也邀请了11级的学长学姐分享他们的一些经验。后来我们成立了信管学习小组，规定时间来主教自习。主要是为了学习网站开发。但后来效果不佳，我也较忙，就散了。<br>PPT水平在涨进，主要体现在我做的优秀班集体评选PPT上，传说就是凭借这次展示，让学校领导记住了做PPT还有这么好的人，后来（2015年5月13日）就被找去做更名大学工作汇报PPT，再后来就有了这张图 PPT制作主要经历:<br><img src="/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/ppt.png" alt="PPT制作主要经历" title="PPT制作主要经历">，也写了一些关于PPT制作的文章，比如：<a href="http://www.jianshu.com/p/065989d7783a" target="_blank" rel="external">要做PPT，一直找不到资源？</a>。开发水平并没有多少涨进。<br>大三下学期，我和同学A，B一起加入了课题组学习，做任务。5月19日，成立了<a href="http://mia.pasp.cn/" target="_blank" rel="external">移动互联协会</a>，又任职<strong>移动互联协会首届会长</strong>，一直任职到大四上学期。成立这社团，主要目的就是为了培养开发，后来给学弟学妹们培训HTML，CSS,和PPT，PS等，感觉他们真幸福。现在回想起来，在课题组，老师好像真的没给我什么实质性的开发任务。好像就让我做些与开发不那么相关的事情。可能是我个人原因。<br>4月，九家培训机构到我们信息学院做宣讲，他们的目的很明显，就是招人去培训。下午跟千锋教育的老师聊了挺久，主要是了解了他们机构是如何授课等。当然，他们极力希望我能去他们的好程序员班，但我肯定不会考虑培训。当时听完，晚上总结了一张图![从校园宣讲会我学到了什么]<br><img src="/2016/09/07/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/peixun.png" alt="从校园宣讲会我学到了什么" title="从校园宣讲会我学到了什么">。</p>
<p>到学期末（6月），让我和同学A一起做<a href="http://sjysxy.jci.edu.cn/" target="_blank" rel="external">设计学院网站</a>（给了设计稿），用迅时CMS搭建网站后台（Asp.net）。主要是我做。那时相当于隔了一年多，要重新捡起HTML，CSS，JS。连引入的jquery和自己写的JS顺序都能弄反，连Jquery的选项卡都写不来。熬了几次夜，在同学A和老师的指导下。终于完成了。这时，我开始感受到，就业压力，我究竟要往哪条路走。是<strong>新媒体运营（PPT）</strong>，或者是<strong>PHP开发</strong>，还是<strong>前端开发</strong>？<br>如果走新媒体运营（PPT），那么要开个微信公众号，写PPT相关文章，PPT演界网卖模板，等等。</p>
<h3 id="真正意义上开始学前端开发"><a href="#真正意义上开始学前端开发" class="headerlink" title="真正意义上开始学前端开发"></a>真正意义上开始学前端开发</h3><p>大三暑假，课题组业务需求，我和同学A，B，都留在课题组做任务学习。前期我还在学PHP，后来室友L，在杭州暑假实习，他说前端也比较火。刚好又在网易云课堂，看到网易推出前端微专业第二期。价格一千多。虽然对于在更名大学办公室做PPT和做网络中心团队队长赚了少许钱的我来说，不是很贵，但上学期报名了驾照（3K+），所以就买不起了。但那时我就确定了方向，前端开发，因为入门相对容易，并且所见即所得，喜欢视觉交互，和之前玩PPT是同样注重视觉交互和逻辑。另外在PHP方面根本没做什么项目。要走前端，原生JavaScript必学！于是在知乎上看到说智能社的JS视频<a href="http://study.163.com/course/courseMain.htm?courseId=224014" target="_blank" rel="external">《精通JavaScript开发》</a>，这套课程不错。那时就没多想，先看完这套课程再学其他的。<strong>很多时候，你想学的太多，都在同时学，往往效果不好，而是先学什么再学什么</strong>。记得那时，晚上9点断网，他们在打牌，我回去后在看下载好的视频。学完这条课程后，感觉有些提升，至少熟练了下写代码。<br>学完这套后，就在慕课网学习其他前端相关知识。<br>8月，课题组组建了一支团队，参加互联网+大赛，当时学校比较重视这次比赛，召集参赛者在学校机房培训，解决吃住问题（在教工食堂吃了10多天），我一不小心又成了<strong>临时班长</strong>，协助就业处的老师处理相关事务。我还负责团队赛项目计划书的撰写和PPT制作。<br>后来我们团队（指尖上的陶艺项目）依次进入校赛，省赛，国赛，最后10月份到吉林大学（吉林长春）参赛国赛，获得国赛金奖（前30）和最佳创意奖，载誉归来之时，学校领导在校门口接我们，学校党委书记说奖励我们团队10万元。刚开始以为不会分到没多少钱。后来就有钱买课程了。双十一期间，就买了网易云课堂的前端开发微专业第三期，系统的学习前端开发。另外还买了妙味课堂的视频课程学习。<strong>有人说，你要学知识，把市面上这类书都买下来，看懂并消化。那你肯定就有提升了。</strong><br>11月，老师N让我做<a href="http://xgc.jci.edu.cn/" target="_blank" rel="external">学工处</a>的网站，同样是Asp.net的后台。这次就没做多久，也没做设计学院网站那么痛苦。<br>12月，开始做毕业设计，是用php+mySql做第二课堂管理系统。1月5日，提前答辩通过。</p>
<h3 id="大四寒假"><a href="#大四寒假" class="headerlink" title="大四寒假"></a>大四寒假</h3><p>开发水平那么差的我，当然是不忘抓住这段时间，提升自己的。看妙味课堂的视频。学着前端微专业，看课程，查资料，讨论区讨论，做作业，改作业。提交作业有截止日期。感觉这段时间挺充实的。<br>也在考虑大四下学期是否去学校，校内实习，还是去公司实习。老师L是推荐我去公司实习，能学挺多。<br>虽然11月份参加了学校的招聘会，有公司问我用过Bootstrap吗，我说没有。后来有几家公司，叫我去实习，我没去。主要是以下考虑：<br><strong>1、公司前端团队好，实习则好。不好，不如自学</strong>。<br><strong>2、自己不足还有很多，希望能继续学完前端开发微专业，获得优秀学员，也许能进好一点的公司</strong>。<br><strong>3、毕竟不考研，以后有的是工作时间，还不如继续享受下最后一学期的校园生活</strong>。</p>
<h3 id="大四最后一个学期"><a href="#大四最后一个学期" class="headerlink" title="大四最后一个学期"></a>大四最后一个学期</h3><p>开学伊始，我和同学A，B都没去公司实习，重新来到了课题组。刚去不久，老师N就推荐我去南昌，算是实习，说有搞PHP的愿意带一个人一起做项目。后来委婉的拒绝了。因为已经不想走PHP开发路线，想走前端开发路线。但本学期，老师交给我的任务依旧是PHP开发的。第二课堂管理系统（PHP+MySql，CI框架）。因为不是很赶，我就前端微专业，百度前端技术学院任务，（妙味课堂的vip视频）三线并行。4月初，完成了<a href="http://lxchuan12.github.io/Netease-Web/">前端微专业大作业</a>，获得优秀学员证书。在学校，上班是996（早上9点上班，晚上9点下班，中午休息1-2小时）。周日老师不在办公室，而我一般在（同学A，B不在）。因为我太Low了，所以只好多花点时间学习。有段时间，都是24点前提交完代码，才去刷牙洗脸睡觉。晚上躺着睡前还在<strong>牛客网</strong>刷题，或者看视频，或者看前端开发类电子书。</p>
<h3 id="面试，入职杭州一家移动互联网公司"><a href="#面试，入职杭州一家移动互联网公司" class="headerlink" title="面试，入职杭州一家移动互联网公司"></a>面试，入职杭州一家移动互联网公司</h3><p>4月底投简历，5月劳动节一过，我和同学A就来杭州面试。我求职还算顺利，面试了3天，共9家。有的给了offer，就选了一家我认为比较合适的。6月1日入职杭州一家移动互联网公司，公司使用花名，我自己挑选了一个，叫<strong>轩辕</strong>。于是把网上各种昵称，改成了<strong>轩辕Rowboat</strong>。</p>
<blockquote>
<p><strong>轩辕Rowboat</strong>由来：轩辕(公司花名)。Rowboat，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），剑未佩妥，出门便是江湖。</p>
</blockquote>
<p>公司使用的技术主要有：HTML5，模板语言（velocity，thymeleaf,handlebarsjs，underscorejs，lodash工具库等），CSS3，Less，Sass，JS，JQuery，zeptojs，bootstrap，angularjs，vuejs，git，gulp，webpack，ES6等（React，nodejs暂时没用到）。<br>不知不觉就写了挺多字，感觉一路走来，<strong>在网易云课堂购买了付费课程（office，前端微专业等）两千左右（已赚回），当没有时间，有钱时，可以选择付费学习，投资学习，回报很大</strong>。<strong>技术提升需要一定的过程，脚踏实地走好每一步，先定好一个个小目标，然后去一一实现</strong>。<strong>看过很多前端大神成长路线，也是从刚开始啥都不会，一步一步变成前端大神的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉最近&lt;strong&gt;我是如何XXX的&lt;/strong&gt;这类标题挺火的。&lt;br&gt;杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6 标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。
    
    </summary>
    
      <category term="自我成长" scheme="https://lxchuan12.github.io/categories/%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF/"/>
    
    
      <category term="self-growth" scheme="https://lxchuan12.github.io/tags/self-growth/"/>
    
      <category term="前端" scheme="https://lxchuan12.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>由JavaScript一道面向对象题引发的思考</title>
    <link href="https://lxchuan12.github.io/2016/08/30/20160830-js-oop-prototype-constructor/"/>
    <id>https://lxchuan12.github.io/2016/08/30/20160830-js-oop-prototype-constructor/</id>
    <published>2016-08-30T15:09:00.000Z</published>
    <updated>2016-08-31T05:13:33.817Z</updated>
    
    <content type="html"><![CDATA[<p>一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">  this.name = &quot;lxchuan12&quot;;</div><div class="line">&#125;</div><div class="line">var rowboat = new Person();</div><div class="line">Person.prototype.age=20;</div><div class="line">Person.prototype=&#123;a:1,b:2&#125;;</div><div class="line">//Person.prototype.constructor = Person;</div><div class="line">console.log(rowboat.name);//&quot;lxchuan12&quot;</div><div class="line">console.log(rowboat.age);//20</div><div class="line">console.log(rowboat.a);//undefined</div><div class="line">console.log(rowboat.b);//undefined</div><div class="line">console.log(rowboat);</div><div class="line">console.log(Person.prototype.name);//undefined</div><div class="line">console.log(Person.prototype.age);//undefined</div><div class="line">console.log(Person.prototype.a);//1</div><div class="line">console.log(Person.prototype.b);//2</div><div class="line">console.log(Person.prototype.constructor);//function Object() &#123; [native code] &#125;</div><div class="line">console.log(Person.prototype);//Object &#123;a: 1, b: 2&#125;</div></pre></td></tr></table></figure></p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>他不明白，为什么rowboat.age为20。但Person.prototype.age却为undefined。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>我把代码在<a href="http://jsbin.com/muzofix/19/edit?html,js,console" target="_blank" rel="external">jsbin</a>运行后，为之解答。<br>Person.prototype={a:1,b:2};这种写法是赋值，<br>与Person.prototype.age=20;写法不同，不经意间把constructor指向原本为Person的，改为了Object（一般来说，需要修正指向。Person.prototype.constructor = Person）。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="./img/console-output.jpg" alt="控制台输出对象" title="">
                </div>
                <div class="image-caption">控制台输出对象</div>
            </figure><br>相当于prototype下只有a,b两个值了。所以Person.prototype.age则是undefined。<br>但rowboat.age是原型上的，可以找到，所以是20。<br>所谓原型查找：查找的是构造器查找的原型，构造器是指向一个function(){},里面没有a和b.</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://segmentfault.com/a/1190000006009690" target="_blank" rel="external">《JavaScript高级程序设计》——对象学习笔记</a></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>学习js面对对象编程相关知识,对了解js语言很有帮助。另外，有人说，能写组件，做组件开发说明达到了中级水平。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个前端QQ群里，有人提问，关于面向对象的……我看完后解答了
    
    </summary>
    
      <category term="JavaScript" scheme="https://lxchuan12.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://lxchuan12.github.io/tags/js/"/>
    
      <category term="oop" scheme="https://lxchuan12.github.io/tags/oop/"/>
    
  </entry>
  
</feed>
