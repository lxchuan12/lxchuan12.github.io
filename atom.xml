<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若川的博客</title>
  
  <subtitle>前端路上 | PPT爱好者 | 所知甚少，唯善学。常以若川为名混迹于江湖。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxchuan12.github.io/"/>
  <updated>2019-06-13T15:22:17.613Z</updated>
  <id>https://lxchuan12.github.io/</id>
  
  <author>
    <name>若川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高考七年后、工作三年后的感悟</title>
    <link href="https://lxchuan12.github.io/posts/a2fcdd39.html"/>
    <id>https://lxchuan12.github.io/posts/a2fcdd39.html</id>
    <published>2019-06-12T15:44:27.000Z</published>
    <updated>2019-06-13T15:22:17.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本打算端午假期发表这文章，后来因为文章还需要有些调整，工作日又比较忙，就到今天周三才发。随便写了近3000字，文章最后有免费送书活动，欢迎留言参与。</p></blockquote><p>又一年高考结束了。<strong>转眼高考过去七年了，工作了三年。很多认识的同届的朋友同学研究生也毕业了，在大学认识的最后一批学弟学妹也毕业了。算是一个阶段结束了。</strong></p><h3 id="高考很大程度决定人生轨迹"><a href="#高考很大程度决定人生轨迹" class="headerlink" title="高考很大程度决定人生轨迹"></a>高考很大程度决定人生轨迹</h3><p>七年前（2012年）坐在自己家乡的小县城考场里，写着语文试卷。前面花的时间比较多，留下写作文的时间不太多，有些紧张。后来考数学时，也时不时有想着语文可能没考好。现在想想那时有着40多分钟就能写出不少于800字的作文，放在现在这能力有所退化。</p><p>高考出分数后，自己研究和分析买的报考指南书籍。选择了一些专业和学校，凭着对这些专业和学校的简单认知，最后在网吧里报考了几所学校和专业。最后录取到了<strong>信息管理与信息系统</strong>这个专业。</p><p>那个暑假，想想自己好像从来都没有离开过所在的小县城，对大学是怎么样的，是不清楚的。所以对即将到来的大学生活特别憧憬。<br>就好比在大三即将毕业时，对社会和职场也可以说是所知甚少。</p><p>2015年6月3日，课题组老师请我们同学三人和一位当时在深圳实习回校的同专业的大四学长，去他家吃饭。就跟学长闲聊了一些工作类的话题，大概意思就是压力还是挺大的，深圳租房也要一千多，房间还不大等等。<br>（因为2013年大一参加过学校的招聘会，看到开发类应届生薪资5、6K，当时觉得还不错。）当听到租房就要一千多，顿时感觉对社会和职场知道的太少了。但在那个暑假确定了未来工作的方向。之前写过一篇文章：<a href="https://www.jianshu.com/p/e5a0f3673ecc" target="_blank" rel="noopener">我是如何踏上前端这条路的</a></p><p>那时我们几个人觉得，可能大学班上没有几个人会从事本专业相关的工作。但事实上毕业后还是有一大部分人选择了IT互联网行业。因为毕竟真的没有太多选择。我知道的很多名校毕业生也从其他行业转入互联网行业。</p><p><strong>回过头来看，高考其实挺重要的。至少决定了未来四年在哪个城市跟哪些人一起学习，很大程度决定工作的方向。虽然很多人毕业多年后，不一定会从事自己所学专业相关的工作。</strong> </p><p>小时候也或多或少听到过一些读书无用论的话语。但工作三年后，发现行业知名大佬、公司领导等多数出自一流大学。一流大学毕业生大概率进入一线公司。那么一般大学的毕业生有没有机会进入一线公司，也是有的，毕竟有一部分人虽然在一般大学，但努力程度和能力会超越大部分人。<br><strong>放在没有互联网的时代，可能获取知识真的很难。而现在互联网时代不缺好课程好资料，可以很大程度上帮助到一部分人学习和成长。</strong><br>有张图可能可以很好的表达这一情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-44debee715bc6d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学校与能力关系图" title="">                </div>                <div class="image-caption">学校与能力关系图</div>            </figure></p><h3 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h3><p>现在再看考研，考研是提升眼界和视野比较好的方式之一，研究生还有一定的留在高校工作的机会，而本科生没有。双非院校，即使是计算机类专业，能考研尽量考研。2017年时和来杭州出差的大学老师聊天。作为复旦大学的博士老师建议，如果觉得写代码遇到了成长瓶颈，不妨再考个研，读个好学校，比如复旦交大等。这样毕业出来平台就不一样了。(当时想着，果然是复旦大学，随口说出来就是复旦交大之类的院校，毕竟是很难考上的。)</p><h3 id="归零"><a href="#归零" class="headerlink" title="归零"></a>归零</h3><p>从小学到大学，大学到工作。<br>每一次都是一次归零，一次重新开始。<br>有人说：毕业前觉得自己有无限可能，毕业后回到了现实社会。<br>投身IT技术岗，要早做打算。常言道：机会总是留给有准备的人。<br>问过一些学习成绩比较好的学弟学妹，他们都感慨没有学好专业课。主要还是实践不多。导致跟企业要求相差比较多。<strong>但以往各方面就表现不错的人，往往能够快速适应新环境，同样做到表现不错。</strong></p><h3 id="看着微信朋友圈，往往容易陷入羡慕别人的怪圈"><a href="#看着微信朋友圈，往往容易陷入羡慕别人的怪圈" class="headerlink" title="看着微信朋友圈，往往容易陷入羡慕别人的怪圈"></a>看着微信朋友圈，往往容易陷入羡慕别人的怪圈</h3><p>这时候想起一个词语叫做<strong>幸存偏误</strong>。<br>这时参看百度百科：指的是只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。<br>朋友圈动态也是大家筛选过才发出来的，一般来说朋友圈都是发好的一面，正能量的。<br>以致于很多人都羡慕别人，就可能会觉得自己混的最差。我也会羡慕我的一些985、211高中同学和关系比较好读研究生的同学。<br>正所谓：城外的人想进城，城里的人想出去。<strong>但有些事情只有自己亲身体会，才会更加深刻。</strong>纸上得来终觉浅，绝知此事要躬行。<br>有段时间，各种文章分析拼多多号称的三亿用户从何而来。有人就说大学本科生仅有中国人口的4%。虽然大城市的人虽然很少用拼多多，但我们并不全面的了解中国。</p><blockquote><p><strong>我们都知道中国有960平方公里的土地，但我们对她有多少城市，县，镇，村并没有完整的概念。<br>有统计表明，中国约有300个“城市”，2856个“县”，41658个“乡镇”，662238个“村”。</strong></p></blockquote><p>而我就是来自60多万“村”的一员。</p><h3 id="人脉圈子"><a href="#人脉圈子" class="headerlink" title="人脉圈子"></a>人脉圈子</h3><p><strong>工作后，人脉圈变窄。这估计是很多职场人共识之一。</strong><br>工作所在城市即使有同学朋友，一年聚的次数最多也就1、2次。有距离的原因也有时间的原因。<br>从小学到大学毕业，听别人说一旦毕业班上同学再也聚不齐了。像是危言耸听。但到现在为止，好像真是这样，全班人没聚齐过。大学算是认识挺多人，但各奔东西，相忘于江湖，是我们共同的结局。<br>圈子窄主要原因大多数职场人，打交道的人只是所在公司团队的人，认识的都是圈内的人。<br>人脉圈子有时候很有作用，这就需要平时有些积累。</p><h3 id="职场的困惑"><a href="#职场的困惑" class="headerlink" title="职场的困惑"></a>职场的困惑</h3><p>职场的困惑往往是因为自身能力不足。想着改变，又无力改变。<br>想起一次一群人聊天，问到大家的理想是什么，基本都回答没什么理想，我也是如此。很多人对自己未来规划和职业规划都是不明确的，或者说根本不是很了解自己。导致当下想改变，又不知道怎么改变，陷入恶性循环之中。<br><strong>求变之前需要认识自己，问清自己想要什么，想做成什么样的人。</strong>为了目标，自己能做到哪一步，有了一个大目标，制定确实可行的方案，根据自己执行情况，不断修正方案，不断得到正反馈，这种感觉很好。有那么一句话叫做不逼下自己，都不知道自己可以有多优秀。<br>培养自己良好的习惯，不断的了解自己，定目标，刻意练习，得到正反馈，良性循环，提升自身的各方面的能力。</p><h3 id="未来还面临着很多选择"><a href="#未来还面临着很多选择" class="headerlink" title="未来还面临着很多选择"></a>未来还面临着很多选择</h3><p>过去的20多年，有很多选择，选择大学和专业，选择考研与否，选择城市和行业，选择公司。未来还有很多选择。有时想到未来就会很焦虑，有种需要和时间赛跑的感觉。<br>经常被朋友和同事问到，会一直在杭州待下去吗？此类问题我一般是这么回答，只能说最近几年会一直在杭州。随着大学毕业时间越长，越来越多可能影响一生的问题需要考虑。</p><h3 id="最后福利时间"><a href="#最后福利时间" class="headerlink" title="最后福利时间"></a>最后福利时间</h3><p>只要您在<strong>若川视野</strong>微信公众号下留言，说出定目标最后怎么达成的故事或者为什么想看《刻意练习》这本书。截止到6月16日21点（本周日），我在留言区挑选5位觉得不错的留言，联系这5位同学，免费包邮送出《刻意练习》这本书，无需转发，无需集赞。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-9effcf3d1ddce36f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刻意练习书籍" title="">                </div>                <div class="image-caption">刻意练习书籍</div>            </figure></p><p>最后附上毕业三年每年的年度总结文章和工作一年的感悟文章。<br><a href="https://www.jianshu.com/p/cea7ecd71f14" target="_blank" rel="noopener">2016年度总结，毕业，工作</a><br><a href="https://www.jianshu.com/p/0b29cc65dc82" target="_blank" rel="noopener">工作一年后，我有些感悟</a><br><a href="https://www.jianshu.com/p/71b5730dc606" target="_blank" rel="noopener">2017年度总结，一如既往</a><br><a href="https://www.jianshu.com/p/a9c7aae40e64" target="_blank" rel="noopener">2018年度总结，平淡无奇</a></p><p>文章同时发布在简书（方便后续修改），<a href="https://www.jianshu.com/p/edf9d76596d2" target="_blank" rel="noopener">高考七年后、工作三年后的感悟</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本打算端午假期发表这文章，后来因为文章还需要有些调整，工作日又比较忙，就到今天周三才发。随便写了近3000字，文章最后有免费送书活动，欢迎留言参与。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又一年高考结束了。&lt;strong&gt;转眼高考过去七年了，工
      
    
    </summary>
    
      <category term="随笔" scheme="https://lxchuan12.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lxchuan12.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感悟" scheme="https://lxchuan12.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>面试官问：JS的继承</title>
    <link href="https://lxchuan12.github.io/posts/a6f0170e.html"/>
    <id>https://lxchuan12.github.io/posts/a6f0170e.html</id>
    <published>2019-02-20T14:48:34.000Z</published>
    <updated>2019-02-20T14:54:31.590Z</updated>
    
    <content type="html"><![CDATA[<p>用过<code>React</code>的读者知道，经常用<code>extends</code>继承<code>React.Component</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 部分源码</span><br><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">Component.prototype.setState = function(partialState, callback)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">const React = &#123;</span><br><span class="line">    Component,</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">class index extends React.Component&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/facebook/react/blob/master/packages/react/src/ReactBaseClasses.js" target="_blank" rel="noopener">点击这里查看 React github源码</a></p><p>面试官可以顺着这个问<code>JS</code>继承的相关问题，比如：<strong><code>ES6</code>的<code>class</code>继承用ES5如何实现</strong>。据说很多人答得不好。<br></p><h2 id="构造函数、原型对象和实例之间的关系"><a href="#构造函数、原型对象和实例之间的关系" class="headerlink" title="构造函数、原型对象和实例之间的关系"></a>构造函数、原型对象和实例之间的关系</h2><p>要弄懂extends继承之前，先来复习一下构造函数、原型对象和实例之间的关系。<br>代码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;&#125;</span><br><span class="line">var f = new F();</span><br><span class="line">// 构造器</span><br><span class="line">F.prototype.constructor === F; // true</span><br><span class="line">F.__proto__ === Function.prototype; // true</span><br><span class="line">Function.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">Object.prototype.__proto__ === null; // true</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">f.__proto__ === F.prototype; // true</span><br><span class="line">F.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">Object.prototype.__proto__ === null; // true</span><br></pre></td></tr></table></figure></p><p>笔者画了一张图表示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/2/18/169014cf74620047?w=1060&h=596&f=png&s=60144" alt="构造函数-原型对象-实例关系图By@若川" title="">                </div>                <div class="image-caption">构造函数-原型对象-实例关系图By@若川</div>            </figure></p><h2 id="ES6-extends-继承做了什么操作"><a href="#ES6-extends-继承做了什么操作" class="headerlink" title="ES6 extends 继承做了什么操作"></a><code>ES6 extends</code> 继承做了什么操作</h2><p>我们先看看这段包含静态方法的<code>ES6</code>继承代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">class Parent&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static sayHello()&#123;</span><br><span class="line">        console.log(&apos;hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    sayAge()&#123;</span><br><span class="line">        console.log(&apos;my age is &apos; + this.age);</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let parent = new Parent(&apos;Parent&apos;);</span><br><span class="line">let child = new Child(&apos;Child&apos;, 18);</span><br><span class="line">console.log(&apos;parent: &apos;, parent); // parent:  Parent &#123;name: &quot;Parent&quot;&#125;</span><br><span class="line">Parent.sayHello(); // hello</span><br><span class="line">parent.sayName(); // my name is Parent</span><br><span class="line">console.log(&apos;child: &apos;, child); // child:  Child &#123;name: &quot;Child&quot;, age: 18&#125;</span><br><span class="line">Child.sayHello(); // hello</span><br><span class="line">child.sayName(); // my name is Child</span><br><span class="line">child.sayAge(); // my age is 18</span><br></pre></td></tr></table></figure></p><p>其中这段代码里有两条原型链，不信看具体代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1、构造器原型链</span><br><span class="line">Child.__proto__ === Parent; // true</span><br><span class="line">Parent.__proto__ === Function.prototype; // true</span><br><span class="line">Function.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">Object.prototype.__proto__ === null; // true</span><br><span class="line">// 2、实例原型链</span><br><span class="line">child.__proto__ === Child.prototype; // true</span><br><span class="line">Child.prototype.__proto__ === Parent.prototype; // true</span><br><span class="line">Parent.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">Object.prototype.__proto__ === null; // true</span><br></pre></td></tr></table></figure></p><p>一图胜千言，笔者也画了一张图表示，如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/2/17/168fb9a3828f9cb4?w=1188&h=1007&f=png&s=107996" alt="ES6继承(extends)关系图By@若川" title="">                </div>                <div class="image-caption">ES6继承(extends)关系图By@若川</div>            </figure><p>结合代码和图可以知道。<br><code>ES6 extends</code> 继承，主要就是：</p><ul><li><ol><li>把子类构造函数(<code>Child</code>)的原型(<code>__proto__</code>)指向了父类构造函数(<code>Parent</code>)，</li></ol></li><li><ol start="2"><li>把子类实例<code>child</code>的原型对象(<code>Child.prototype</code>) 的原型(<code>__proto__</code>)指向了父类<code>parent</code>的原型对象(<code>Parent.prototype</code>)。<br>这两点也就是图中用不同颜色标记的两条线。</li></ol></li><li><ol start="3"><li>子类构造函数<code>Child</code>继承了父类构造函数<code>Preant</code>的里的属性。使用<code>super</code>调用的(<code>ES5</code>则用<code>call</code>或者<code>apply</code>调用传参)。<br>也就是图中用不同颜色标记的两条线。<br>看过《JavaScript高级程序设计-第3版》 章节<code>6.3继承</code>的读者应该知道，这<code>2和3小点</code>，正是<strong>寄生组合式继承</strong>，书中例子没有<code>第1小点</code>。<br><code>1和2小点</code>都是相对于设置了<code>__proto__</code>链接。那问题来了，什么可以设置了<code>__proto__</code>链接呢。</li></ol></li></ul><h2 id="new、Object-create和Object-setPrototypeOf可以设置-proto"><a href="#new、Object-create和Object-setPrototypeOf可以设置-proto" class="headerlink" title="new、Object.create和Object.setPrototypeOf可以设置__proto__"></a><code>new</code>、<code>Object.create</code>和<code>Object.setPrototypeOf</code>可以设置<code>__proto__</code></h2><p>说明一下，<code>__proto__</code>这种写法是浏览器厂商自己的实现。<br>再结合一下图和代码看一下的<code>new</code>，<code>new</code>出来的实例的<strong>proto</strong>指向构造函数的<code>prototype</code>，这就是<code>new</code>做的事情。<br>摘抄一下之前写过文章的一段。<a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">面试官问：能否模拟实现JS的new操作符</a>，有兴趣的读者可以点击查看。</p><h3 id="new做了什么："><a href="#new做了什么：" class="headerlink" title="new做了什么："></a><strong><code>new</code>做了什么：</strong></h3><blockquote><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol></blockquote><h3 id="Object-create-ES5提供的"><a href="#Object-create-ES5提供的" class="headerlink" title="Object.create ES5提供的"></a><code>Object.create</code> <code>ES5提供的</code></h3><p><code>Object.create(proto, [propertiesObject])</code><br>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是<code>undefined</code>）。对于不支持<code>ES5</code>的浏览器，<code>MDN</code>上提供了<code>ployfill</code>方案。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN Object.create()</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 简版：也正是应用了new会设置__proto__链接的原理。</span><br><span class="line">if(typeof Object.create !== &apos;function&apos;)&#123;</span><br><span class="line">    Object.create = function(proto)&#123;</span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf-ES6提供的"><a href="#Object-setPrototypeOf-ES6提供的" class="headerlink" title="Object.setPrototypeOf ES6提供的"></a><code>Object.setPrototypeOf</code> <code>ES6提供的</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf</code> <code>MDN</code></a></p><p><code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部<code>[[Prototype]]</code>属性）到另一个对象或  <code>null</code>。<br><code>Object.setPrototypeOf(obj, prototype)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`ployfill`</span><br><span class="line">// 仅适用于Chrome和FireFox，在IE中不工作：</span><br><span class="line">Object.setPrototypeOf = Object.setPrototypeOf || function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  return obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nodejs</code>源码就是利用这个实现继承的工具函数的。<br><a href="https://github.com/nodejs/node/blob/master/lib/util.js#L295-L313" target="_blank" rel="noopener">nodejs utils inherits</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function inherits(ctor, superCtor) &#123;</span><br><span class="line">  if (ctor === undefined || ctor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;ctor&apos;, &apos;Function&apos;, ctor);</span><br><span class="line"></span><br><span class="line">  if (superCtor === undefined || superCtor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor&apos;, &apos;Function&apos;, superCtor);</span><br><span class="line"></span><br><span class="line">  if (superCtor.prototype === undefined) &#123;</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor.prototype&apos;,</span><br><span class="line">                                   &apos;Object&apos;, superCtor.prototype);</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(ctor, &apos;super_&apos;, &#123;</span><br><span class="line">    value: superCtor,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ES6的extends的ES5版本实现"><a href="#ES6的extends的ES5版本实现" class="headerlink" title="ES6的extends的ES5版本实现"></a><code>ES6</code>的<code>extends</code>的<code>ES5</code>版本实现</h2><p>知道了<code>ES6 extends</code>继承做了什么操作和设置<code>__proto__</code>的知识点后，把上面<code>ES6</code>例子的用<code>ES5</code>就比较容易实现了，也就是说<strong>实现寄生组合式继承</strong>，简版代码就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// ES5 实现ES6 extends的例子</span><br><span class="line">function Parent(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.sayHello = function()&#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name, age)&#123;</span><br><span class="line">    // 相当于super</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">// new</span><br><span class="line">function object()&#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line">function _inherits(Child, Parent)&#123;</span><br><span class="line">    // Object.create</span><br><span class="line">    Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">    // __proto__</span><br><span class="line">    // Child.prototype.__proto__ = Parent.prototype;</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">    // ES6</span><br><span class="line">    // Object.setPrototypeOf(Child, Parent);</span><br><span class="line">    // __proto__</span><br><span class="line">    Child.__proto__ = Parent;</span><br><span class="line">&#125;</span><br><span class="line">_inherits(Child,  Parent);</span><br><span class="line">Child.prototype.sayAge = function()&#123;</span><br><span class="line">    console.log(&apos;my age is &apos; + this.age);</span><br><span class="line">    return this.age;</span><br><span class="line">&#125;</span><br><span class="line">var parent = new Parent(&apos;Parent&apos;);</span><br><span class="line">var child = new Child(&apos;Child&apos;, 18);</span><br><span class="line">console.log(&apos;parent: &apos;, parent); // parent:  Parent &#123;name: &quot;Parent&quot;&#125;</span><br><span class="line">Parent.sayHello(); // hello</span><br><span class="line">parent.sayName(); // my name is Parent</span><br><span class="line">console.log(&apos;child: &apos;, child); // child:  Child &#123;name: &quot;Child&quot;, age: 18&#125;</span><br><span class="line">Child.sayHello(); // hello</span><br><span class="line">child.sayName(); // my name is Child</span><br><span class="line">child.sayAge(); // my age is 18</span><br></pre></td></tr></table></figure></p><p>我们完全可以把上述<code>ES6的例子</code>通过<a href="https://babeljs.io/repl" target="_blank" rel="noopener"><code>babeljs</code></a>转码成<code>ES5</code>来查看，更严谨的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">// 对转换后的代码进行了简要的注释</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">// 主要是对当前环境支持Symbol和不支持Symbol的typeof处理</span><br><span class="line">function _typeof(obj) &#123;</span><br><span class="line">    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) &#123;</span><br><span class="line">        _typeof = function _typeof(obj) &#123;</span><br><span class="line">            return typeof obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _typeof = function _typeof(obj) &#123;</span><br><span class="line">            return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line">// _possibleConstructorReturn 判断Parent。call(this, name)函数返回值 是否为null或者函数或者对象。</span><br><span class="line">function _possibleConstructorReturn(self, call) &#123;</span><br><span class="line">    if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) &#123;</span><br><span class="line">        return call;</span><br><span class="line">    &#125;</span><br><span class="line">    return _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line">// 如何 self 是void 0 （undefined） 则报错</span><br><span class="line">function _assertThisInitialized(self) &#123;</span><br><span class="line">    if (self === void 0) &#123;</span><br><span class="line">        throw new ReferenceError(&quot;this hasn&apos;t been initialised - super() hasn&apos;t been called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">// 获取__proto__</span><br><span class="line">function _getPrototypeOf(o) &#123;</span><br><span class="line">    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123;</span><br><span class="line">        return o.__proto__ || Object.getPrototypeOf(o);</span><br><span class="line">    &#125;;</span><br><span class="line">    return _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line">// 寄生组合式继承的核心</span><br><span class="line">function _inherits(subClass, superClass) &#123;</span><br><span class="line">    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;</span><br><span class="line">        throw new TypeError(&quot;Super expression must either be null or a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </span><br><span class="line">    // 也就是说执行后 subClass.prototype.__proto__ === superClass.prototype; 这条语句为true</span><br><span class="line">    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        constructor: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line">// 设置__proto__</span><br><span class="line">function _setPrototypeOf(o, p) &#123;</span><br><span class="line">    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123;</span><br><span class="line">        o.__proto__ = p;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;;</span><br><span class="line">    return _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line">// instanceof操作符包含对Symbol的处理</span><br><span class="line">function _instanceof(left, right) &#123;</span><br><span class="line">    if (right != null &amp;&amp; typeof Symbol !== &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) &#123;</span><br><span class="line">        return right[Symbol.hasInstance](left);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return left instanceof right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123;</span><br><span class="line">    if (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot call a class as a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 按照它们的属性描述符 把方法和静态属性赋值到构造函数的prototype和构造器函数上</span><br><span class="line">function _defineProperties(target, props) &#123;</span><br><span class="line">    for (var i = 0; i &lt; props.length; i++) &#123;</span><br><span class="line">        var descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || false;</span><br><span class="line">        descriptor.configurable = true;</span><br><span class="line">        if (&quot;value&quot; in descriptor) descriptor.writable = true;</span><br><span class="line">        Object.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 把方法和静态属性赋值到构造函数的prototype和构造器函数上</span><br><span class="line">function _createClass(Constructor, protoProps, staticProps) &#123;</span><br><span class="line">    if (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    if (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">    return Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">var Parent = function () &#123;</span><br><span class="line">    function Parent(name) &#123;</span><br><span class="line">        _classCallCheck(this, Parent);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: &quot;sayName&quot;,</span><br><span class="line">        value: function sayName() &#123;</span><br><span class="line">            console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;], [&#123;</span><br><span class="line">        key: &quot;sayHello&quot;,</span><br><span class="line">        value: function sayHello() &#123;</span><br><span class="line">            console.log(&apos;hello&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line">    return Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var Child = function (_Parent) &#123;</span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line">    function Child(name, age) &#123;</span><br><span class="line">        var _this;</span><br><span class="line">        _classCallCheck(this, Child);</span><br><span class="line">        // Child.__proto__ =&gt; Parent</span><br><span class="line">        // 所以也就是相当于Parent.call(this, name); 是super(name)的一种转换</span><br><span class="line">        // _possibleConstructorReturn 判断Parent.call(this, name)函数返回值 是否为null或者函数或者对象。</span><br><span class="line">        _this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, name));</span><br><span class="line">        _this.age = age;</span><br><span class="line">        return _this;</span><br><span class="line">    &#125;</span><br><span class="line">    _createClass(Child, [&#123;</span><br><span class="line">        key: &quot;sayAge&quot;,</span><br><span class="line">        value: function sayAge() &#123;</span><br><span class="line">            console.log(&apos;my age is &apos; + this.age);</span><br><span class="line">            return this.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line">    return Child;</span><br><span class="line">&#125;(Parent);</span><br><span class="line"></span><br><span class="line">var parent = new Parent(&apos;Parent&apos;);</span><br><span class="line">var child = new Child(&apos;Child&apos;, 18);</span><br><span class="line">console.log(&apos;parent: &apos;, parent); // parent:  Parent &#123;name: &quot;Parent&quot;&#125;</span><br><span class="line">Parent.sayHello(); // hello</span><br><span class="line">parent.sayName(); // my name is Parent</span><br><span class="line">console.log(&apos;child: &apos;, child); // child:  Child &#123;name: &quot;Child&quot;, age: 18&#125;</span><br><span class="line">Child.sayHello(); // hello</span><br><span class="line">child.sayName(); // my name is Child</span><br><span class="line">child.sayAge(); // my age is 18</span><br></pre></td></tr></table></figure><p>如果对JS继承相关还是不太明白的读者，推荐阅读以下书籍的相关章节，可以自行找到相应的<code>pdf</code>版本。</p><h2 id="推荐阅读JS继承相关的书籍章节"><a href="#推荐阅读JS继承相关的书籍章节" class="headerlink" title="推荐阅读JS继承相关的书籍章节"></a>推荐阅读JS继承相关的书籍章节</h2><p>《JavaScript高级程序设计第3版》-第6章 面向对象的程序设计，6种继承的方案，分别是原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。<a href="http://www.ituring.com.cn/book/946" target="_blank" rel="noopener">图灵社区本书地址</a>，后文放出<code>github</code>链接，里面包含这几种继承的代码<code>demo</code>。</p><p>《JavaScript面向对象编程第2版》-第6章 继承，12种继承的方案。1.原型链法（仿传统）、2.仅从原型继承法、3.临时构造器法、4.原型属性拷贝法、5.全属性拷贝法（即浅拷贝法）、6.深拷贝法、7.原型继承法、8.扩展与增强模式、9.多重继承法、10.寄生继承法、11.构造器借用法、12、构造器借用与属性拷贝法。</p><p><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">ES6标准入门-第21章class的继承</a></p><p><a href="https://oshotokill.gitbooks.io/understandinges6-simplified-chinese/content/chapter_9.html" target="_blank" rel="noopener">《深入理解<code>ES6</code>》-第9章</a> <code>JavaScript</code>中的类</p><p>《你不知道的<code>JavaScript</code>-上卷》第6章 行为委托和附录A <code>ES6中的class</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>继承对于JS来说就是父类拥有的方法和属性、静态方法等，子类也要拥有。子类中可以利用原型链查找，也可以在子类调用父类，或者从父类拷贝一份到子类等方案。<br>继承方法可以有很多，重点在于必须理解并熟<br>悉这些对象、原型以及构造器的工作方式，剩下的就简单了。<strong>寄生组合式继承</strong>是开发者使用比较多的。<br>回顾寄生组合式继承。主要就是三点：</p><ul><li><ol><li>子类构造函数的<code>__proto__</code>指向父类构造器，继承父类的静态方法</li></ol></li><li><ol start="2"><li>子类构造函数的<code>prototype</code>的<code>__proto__</code>指向父类构造器的<code>prototype</code>，继承父类的方法。</li></ol></li><li><ol start="3"><li>子类构造器里调用父类构造器，继承父类的属性。<br>行文到此，文章就基本写完了。文章代码和图片等资源放在这里<a href="https://github.com/lxchuan12/html5/tree/gh-pages/JS%E7%9B%B8%E5%85%B3/oop/inherit" target="_blank" rel="noopener">github inhert</a>和<a href="http://lxchuan12.github.io/html5/JS%E7%9B%B8%E5%85%B3/oop/inherit/7.es6-extends.html"><code>demo</code>展示<code>es6-extends</code></a>，结合<code>console、source</code>面板查看更佳。</li></ol></li></ul><p>读者发现有不妥或可改善之处，欢迎评论指出。另外觉得写得不错，可以点赞、评论、转发，也是对笔者的一种支持。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用过&lt;code&gt;React&lt;/code&gt;的读者知道，经常用&lt;code&gt;extends&lt;/code&gt;继承&lt;code&gt;React.Component&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
      <category term="面试" scheme="https://lxchuan12.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2018年度总结，平淡无奇</title>
    <link href="https://lxchuan12.github.io/posts/66be4245.html"/>
    <id>https://lxchuan12.github.io/posts/66be4245.html</id>
    <published>2019-01-14T15:11:09.000Z</published>
    <updated>2019-02-10T14:29:24.538Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-9005ded4fd1cd995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2018年度总结-平淡无奇.png" title="">                </div>                <div class="image-caption">2018年度总结-平淡无奇.png</div>            </figure><p>从2014年开始写年度总结至今已经五个年头了。正如孔子所说：逝者如斯夫，不舍昼夜。<br>这一年，与2017年基本一样，平淡无奇，只是觉得时间过得更快了。<br>人们往往容易高估自己一年能完成的事情，低估自己五年能完成的事情。记录下来，发现一年做不了很多事。<br>使用<code>teambition</code>网站记录了不少任务，还有很多没有完成，不过我一般是记录任务。<br>2016年学习了一门年度计划的课程，提到人生的8个方面，分别是<strong>身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松</strong>。觉得这8方面还是挺合理的，于是2016年度总结开始，都是按这8个方面用<code>xmind</code>画思维导图总结自己的一年。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-c39b464263088122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2018年-平淡无奇.png" title="">                </div>                <div class="image-caption">2018年-平淡无奇.png</div>            </figure></p><h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><p>有人可能会想，一年这么多事情，竟然记得那么清楚，是哪天发生的，都记得。<br>这时候就要说一说，这一年，主要使用的工具。<br>其实很多事，我都会发微博记录。整理总结一年的开始会先先用<code>xmind</code>整理【2018年微博时间轴】<br><strong>GTD任务管理，目标管理之类的软件</strong>，很早之前（大学期间）用的是<a href="http://doit.im/cn/" target="_blank" rel="noopener">doit.im</a>。后来用的是<a href="https://www.dida365.com/" target="_blank" rel="noopener">滴答清单</a>，现在主要用的是<a href="https://teambition.com/projects" target="_blank" rel="noopener">teambition</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-95ee6a887fc1258a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12月 teambition日历" title="">                </div>                <div class="image-caption">12月 teambition日历</div>            </figure></p><p>以前用<code>24PI</code>，后来不支持现在的手机，就弃用了。<a href="https://www.rescuetime.com" target="_blank" rel="noopener">rescuetime 记录时间的软件</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-0db459cde9764e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rescueTime-2018年.png" title="">                </div>                <div class="image-caption">rescueTime-2018年.png</div>            </figure></p><p>发了年度总结的思维导图的朋友圈后，有人评价，一个极度自律的人。其实觉得自己自律和目标管理（之前写过一篇文章：<a href="https://www.jianshu.com/p/8284f7778e6e" target="_blank" rel="noopener">如何制定有价值的目标</a>）方面，还是做得挺不好的。没有达到良性循环。只是相比于一般人，写年度总结罢了。</p><h2 id="身体-·-健康"><a href="#身体-·-健康" class="headerlink" title="身体 · 健康"></a>身体 · 健康</h2><p>全年基本没有锻炼，虽然特意买了一个手环记录运动数据。骑车（20分钟左右）上下班都算是一种锻炼了，下雨或者天冷就坐公交。</p><p>2月20日，大年初五换了第三副眼镜，据眼镜店记载上一副还是高三（2012年）配的，第一副是高一（2009年）配的。配完新眼镜感觉很清晰，现如今，已经又加深了，模糊了。（主要还是天天面对手机电脑且不注意休息的缘故）。<br>正印证了那句话：<strong>真的要少玩手机电脑了，眼睛越来越不好了，打开支付宝都看不到钱了。</strong></p><p>有时问自己：按时好好吃饭，难吗？按时好好睡觉，难吗？确实难。<br>这一年，工作日点外卖明显多了（往年基本不点外卖），下班后有时容易饿了先吃零食填肚子。年轻人容易得胃病，往往就是不按时好好吃饭的缘故。<br>9月1日生日那天，把杭州的大学同学聚在一起聊天时，好几个同学提到累但睡不着，容易醒。醒来就睡不着了。感慨不年轻了，大学期间没课还可以睡到自然醒。那时心想看来不只是我一人如此。<br>到了12点，身体就开始就感觉累了，要去休息了，很难熬夜了。有时又容易睡不着，就失眠到一两点，第二天照样去上班。周末一般都1点才入睡，想着第二天不用早起，再睡个懒觉，一上午就浪费了。</p><p>但试想一下，好像没必要非得拖到那么晚才睡。听一朋友说TA 10点半前基本就会关闭电子设备，看书，11点准备入睡，容易睡着。我也试着照这样做，确实容易睡着。<br><strong>总之，2019年得管理好自己，按时吃饭、早睡早起。</strong>试着调整成11:30前睡，8:00前起。不区分工作日还是周末。</p><h2 id="财务-·-理财"><a href="#财务-·-理财" class="headerlink" title="财务 · 理财"></a>财务 · 理财</h2><p>所谓理财就是理清自己的财务，开源节流，基本没有乱花钱。<br>虽然在网易云课堂上了花了几百元买了《简七理财》相关课程，但就看了几小节。<br>有些人，买几千块钱的耳机，上万块的手机，几万块的电脑。不得不说这些人确实有钱。如果追求这些，把自己变成月光族，那我觉得没什么必要。毕竟跟理财理念是相违背的。</p><h2 id="人脉-·-社群"><a href="#人脉-·-社群" class="headerlink" title="人脉 · 社群"></a>人脉 · 社群</h2><p>2016年工作后，那时就发现人脉圈子窄了。不像大学，因为社团和活动可以接触到很多同学和老师。原来大学认识的学弟学妹都来到杭州工作了，自己毕业快三年了。这一年，工作之外，算新认识的朋友少得可怜，好像不超过30个，女生就更少了。<br>老朋友联系少了，但联系起来感情还在。<br>而且即使同在杭州的朋友同学，一年都头，可能就聚过一两次，或者几年一次都没见过。再聚就不知道是什么时候了。所以每次和朋友同学若是去风景区玩，觉得都应该合个影留作纪念，毕竟真的是见一次少一次啊。<br>2月12日，年前放假回家时，几个高中同学聚了一下，都发现是好几年没见了。<br>6月1日，和前端群里群主（在广州来杭州玩）召集了十来个在杭州的小伙伴一起欢度了六一。<br>后续这些小伙伴，其中一人离开杭州，再去海底捞吃火锅聚了一次。这算是一次性认识的人最多的一次。</p><h2 id="家庭生活"><a href="#家庭生活" class="headerlink" title="家庭生活"></a>家庭生活</h2><p><strong>这一年，开始关注楼市消息，但也没有非常认真的关注。</strong>春节期间，亲戚坐在一起聊天时，提到房子要早点买，不然一年的钱就白赚了，那个谁在哪里买了房，诸如此类。2月春节期间，去看了县城周边的房子，连那么远都是<code>5K</code>起，太贵了，县城均价都<code>6~7K</code>了。要知道所在城市吉安都比自己小县城便宜。</p><p>6月23日，我弟高考成绩出来，帮忙报考，<strong>后来还是录取到了计算机类专业，不知是喜是忧，毕竟自己从事计算机行业，时常感到焦虑</strong>。后续给我弟买了手机和电脑。</p><p>10月1日-6日，国庆放假在家6天，国庆时给老妈买了一部新手机<code>华为荣耀8X</code>。给爸妈买个手机充个话费，他们都记得很清楚。其实相比他们对自己的爱来说，真的是微不足道。<br>基本平均每两周会和我妈视频通话。很多次都会催着找女朋友，每次我也只好默不作声。他们也着急，也会找亲戚朋友帮忙看看哪里有合适的姑娘。<br>自己比较佛系（随缘），新认识的人少，女生就更少了。<br><strong>从历史长河来看，好的伴侣真的很重要，应该努力去追寻，毕竟是陪伴一生的人。</strong><br><a href="https://zhuanlan.zhihu.com/p/51403975" target="_blank" rel="noopener">宁南山：多赚了一两千–深圳年龄30+中产状态</a>，有兴趣的读者可以看看这篇文章。</p><blockquote><p>所以对于“学校出身”“学历出身”相似的人来说，<br>虽然毕业后大家努力程度不同，行业的不同，公司的不同会导致收入有差距，但其实大多数人的收入区间是逐渐趋同的，少数人除外。<br>年龄30岁+的我们，决定我们现在个人之间差距的，<br>是两个选择，一个是房子，一个是婚姻。</p></blockquote><p>简单说也就是单科（事业）再怎么好，一般都敌不过三科（包含房子、婚姻）好的同学。<br>作者宁南山还在这篇文章提到婚姻这个问题。<a href="https://zhuanlan.zhihu.com/p/37902458" target="_blank" rel="noopener">宁南山：(闲聊）高考二十年后的人生轨迹</a></p><h2 id="工作-·-事业"><a href="#工作-·-事业" class="headerlink" title="工作 · 事业"></a>工作 · 事业</h2><p>之前同事问：家里人知道你是做什么的嘛。<br>这里解释下：说的高端一点是前端开发工程师，说的通俗一点则是：网站开发，比如朋友圈各种年度报告，或者百度、天猫网站、微信小程序就是我们这类人做的。<br><strong>慢慢打造个人品牌</strong><br>知识星球《前端视野》，依旧没怎么推广，共有318人加入，比去年（5月开通）增加了200余人，就是日常发些前端相关。<br>建有微信群【前端视野交流群】，没怎么推广，暂时32人。<br>在<code>SegmentFault</code>、掘金、简书、知乎、博客，累计发了10余篇技术文章，最高产时是11月份3篇。<br><code>SegmentFault</code>、知乎上都开通了专栏《若川的前端视野》<a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener">SegmentFault：若川的前端视野</a>，<a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎：若川的前端视野</a>。<br>机缘巧合，有偿给牛客网出了一些前端试题，得到了几百元的报酬。<br>年初也有偿帮别人做了一份PPT，获得了几百元的报酬。不过帮被人做<code>PPT</code>太耗时了，好久不做，做得也没大学那么顺手了。</p><h2 id="学习-·-成长"><a href="#学习-·-成长" class="headerlink" title="学习 · 成长"></a>学习 · 成长</h2><p>1月27日，成为<code>SegmentFault</code>优秀问答作者，获得官方发的一些礼物，比如抱枕等。<br>给2013年买的电脑，加了4G内存条，买了24寸的显示器，双屏显示器效率确实高了很多，看完了十余门视频课程，比去年看的多些。<br><strong>这一年，参加的技术分享活动不多，总共2场。</strong><br>4月21日，有赞前端技术开放日，写了一篇参与后感想<a href="https://www.jianshu.com/p/afe89ed8495c" target="_blank" rel="noopener">参加有赞前端技术开放日所感所想</a><br>5月20日，掘金杭州前端技术分享活动。<br><strong>这一年，加入到了freecodecamp杭州社区的活动组织中，和组织者一起举办了两场活动。</strong><br>3月19日，FCC与宋小菜联合举办线下分享活动。<br>11月10日，全国联动，<a href="https://conf.freecodecamp.one/" target="_blank" rel="noopener">freeCodeConf</a>杭州站技术分享活动。当时下班后写后续报道公众号文章<a href="https://mp.weixin.qq.com/s/HPLyoWATWWnjm2FH1kKxlw" target="_blank" rel="noopener">首届freeCodeConf杭州站圆满结束，精彩回顾</a>，写了三天。主持稿也是我写的。主持人是我请的大学同学。</p><p><strong>输出文章（在博客、掘金、思否、知乎、简书）11篇，其中技术文章9篇，技术文章比去年多写了7篇。（去年只写了2篇技术文章）</strong>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-ccda8c4d09fca3f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的掘金年度总结.png" title="">                </div>                <div class="image-caption">我的掘金年度总结.png</div>            </figure></p><p><strong>这一年，看技术书籍，主要看了几本《你不知道的JavaScript 上中下卷》、《深入浅出webpack》等，非技术书籍，主要看了《刻意练习》，此书还是值得一看，推荐给大家。</strong></p><h2 id="休闲-·-放松"><a href="#休闲-·-放松" class="headerlink" title="休闲 · 放松"></a>休闲 · 放松</h2><p>这一年旅行，只去了苏州，体验了第一次一个人旅行的感觉，大学就想体验一下，但一直没实现。苏州虎丘、博物馆、狮子园、金鸡湖景区等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-8ca19236e26b3f3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苏州金鸡湖景区.jpg" title="">                </div>                <div class="image-caption">苏州金鸡湖景区.jpg</div>            </figure></p><p>杭州周边，很多地方都去过，只是基本都是不同的人。</p><p>上面洋洋洒洒写了三千多字，看过思维导图的同学，会发现基本是思维导图的扩充（或者说补充）版本。<br>跟以往的年度总结不太一样。以往年度总结，提出了好几个观点。<br>2016年：<a href="http://lxchuan12.github.io/2017/01/07/20170107-2016-annual-summary">2016年度总结，毕业工作</a></p><ol><li>未来的路在哪2. 打造个人品牌（知识型IP）3. 时间也是资源 4. 世界发展太快，需要不断学习<br>2017年：<a href="http://lxchuan12.github.io/2018/01/05/20180105-2017-annual-summary/">2017年度总结，一如既往</a><br>1、慢慢打造个人品牌 2、危机感。<br>而现在觉得，这些都写过了，就不写了。<br>至此，昨晚写了一晚和今晚配图，2018年度总结的文章算是结束了。后续会可能有些修改。以往都只发布在朋友圈和我的个人博客，觉得博客可能迁移，图片也有时缺失，有时打开也比较慢，所以这一次也发布到了简书。</li></ol><p>同时也发表在简书<a href="https://www.jianshu.com/p/a9c7aae40e64" target="_blank" rel="noopener">简书：2018年度总结，平淡无奇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面试官问：JS的this指向</title>
    <link href="https://lxchuan12.github.io/posts/10fc72ea.html"/>
    <id>https://lxchuan12.github.io/posts/10fc72ea.html</id>
    <published>2018-12-25T14:03:49.000Z</published>
    <updated>2019-02-10T14:29:24.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试官出很多考题，基本都会变着方式来考察<code>this</code>指向，看候选人对<code>JS</code>基础知识是否扎实。<br>读者可以先拉到底部看总结，再谷歌（或各技术平台）搜索几篇类似文章，看笔者写的文章和别人有什么不同（欢迎在评论区评论不同之处），对比来看，验证与自己现有知识是否有盲点，多看几篇，自然就会完善自身知识。</p><blockquote><p>附上之前写文章写过的一段话：已经有很多关于<code>this</code>的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p>函数的<code>this</code>在调用时绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。为了搞清楚<code>this</code>的指向是什么，必须知道相关函数是如何调用的。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>非严格模式和严格模式中this都是指向顶层对象（浏览器中是<code>window</code>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this === window // true</span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">this === window;</span><br><span class="line">this.name = &apos;轩辕Rowboat&apos;;</span><br><span class="line">console.log(this.name); // 轩辕Rowboat</span><br></pre></td></tr></table></figure></p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><h3 id="普通函数调用模式"><a href="#普通函数调用模式" class="headerlink" title="普通函数调用模式"></a>普通函数调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // &apos;window&apos;</span><br></pre></td></tr></table></figure><p>你可能会误以为<code>window.doSth()</code>是调用的，所以是指向<code>window</code>。虽然本例中<code>window.doSth</code>确实等于<code>doSth</code>。<code>name</code>等于<code>window.name</code>。上面代码中这是因为在<code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是<code>window</code>）中。<br>事实上，并不是如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">let name2 = &apos;window2&apos;;</span><br><span class="line">let doSth2 = function()&#123;</span><br><span class="line">    console.log(this === window);</span><br><span class="line">    console.log(this.name2);</span><br><span class="line">&#125;</span><br><span class="line">doSth2() // true, undefined</span><br></pre></td></tr></table></figure></p><p>这个例子中<code>let</code>没有给顶层对象中（浏览器是window）添加属性，<code>window.name2和window.doSth</code>都是<code>undefined</code>。</p><p>严格模式中，普通函数中的<code>this</code>则表现不同，表现为<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 严格模式</span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(typeof this === &apos;undefined&apos;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // true，// 报错，因为this是undefined</span><br></pre></td></tr></table></figure></p><p>看过的《你不知道的<code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。<br>对<code>call</code>，<code>apply</code>熟悉的读者会类比为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSth.call(undefined);</span><br><span class="line">doSth.apply(undefined);</span><br></pre></td></tr></table></figure></p><p>效果是一样的，<code>call</code>，<code>apply</code>作用之一就是用来修改函数中的<code>this</code>指向为第一个参数的。<br>第一个参数是<code>undefined</code>或者<code>null</code>，非严格模式下，是指向<code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。<br>经常有这类代码（回调函数），其实也是普通函数调用模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;轩辕Rowboat&apos;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 语法</span><br><span class="line">setTimeout(fn | code, 0, arg1, arg2, ...)</span><br><span class="line">// 也可以是一串代码。也可以传递其他函数</span><br><span class="line">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span><br><span class="line">fn.call(undefined, arg1, arg2, ...);</span><br></pre></td></tr></table></figure></p><h3 id="对象中的函数（方法）调用模式"><a href="#对象中的函数（方法）调用模式" class="headerlink" title="对象中的函数（方法）调用模式"></a>对象中的函数（方法）调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &apos;other&apos;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &apos;轩辕Rowboat&apos;</span><br><span class="line">student.other.doSth(); // &apos;other&apos;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student);</span><br></pre></td></tr></table></figure><p>但往往会有以下场景，把对象中的函数赋值成一个变量了。<br>这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var studentDoSth = student.doSth;</span><br><span class="line">studentDoSth(); // &apos;window&apos;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">studentDoSth.call(undefined);</span><br></pre></td></tr></table></figure></p><h3 id="call、apply、bind-调用模式"><a href="#call、apply、bind-调用模式" class="headerlink" title="call、apply、bind 调用模式"></a><code>call、apply、bind</code> 调用模式</h3><p>上文提到<code>call</code>、<code>apply</code>，这里详细解读一下。先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN 文档：Function.prototype.call()</a><br><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p><p><strong>thisArg</strong><br>在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br><strong>arg1, arg2, …</strong><br>指定的参数列表<br><strong>返回值</strong><br>返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。<br><code>apply</code>和<code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p><p>根据参数<code>thisArg</code>的描述，可以知道，<code>call</code>就是改变函数中的<code>this</code>指向为<code>thisArg</code>，并且执行这个函数，这也就使<code>JS</code>灵活很多。严格模式下，<code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(name)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth.call(2, &apos;轩辕Rowboat&apos;); // Number&#123;2&#125;, &apos;轩辕Rowboat&apos;</span><br><span class="line">var doSth2 = function(name)&#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.call(2, &apos;轩辕Rowboat&apos;); // 2, &apos;轩辕Rowboat&apos;</span><br></pre></td></tr></table></figure></p><p>虽然一般不会把<code>thisArg</code>参数写成值类型。但还是需要知道这个知识。<br>之前写过一篇文章：<a href="https://juejin.im/post/5bf6c79bf265da6142738b29" target="_blank" rel="noopener">面试官问：能否模拟实现<code>JS</code>的<code>call</code>和<code>apply</code>方法</a><br>就是利用对象上的函数<code>this</code>指向这个对象，来模拟实现<code>call</code>和<code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p><p><code>bind</code>和<code>call</code>和<code>apply</code>类似，第一个参数也是修改<code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（<code>new</code>）调用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN Function.prototype.bind</a></p><blockquote><p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时<code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。<br><strong>语法：</strong><br>fun.bind(thisArg[, arg1[, arg2[, …]]])<br><strong>参数：</strong><br><strong>thisArg</strong><br>调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code>中创建一个函数（作为回调提供）时，作为<code>thisArg</code>传递的任何原始值都将转换为<code>object</code>。如果没有提供绑定的参数，则执行作用域的<code>this</code>被视为新函数的<code>thisArg</code>。<br><strong>arg1, arg2, …</strong><br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。<br><strong>返回值</strong><br>返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p></blockquote><p>之前也写过一篇文章：<a href="https://juejin.im/post/5bec4183f265da616b1044d7" target="_blank" rel="noopener">面试官问：能否模拟实现<code>JS</code>的<code>bind</code>方法</a><br>就是利用<code>call</code>和<code>apply</code>指向这个<code>thisArg</code>参数，来模拟实现<code>bind</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p><h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(this); // &#123;name: &apos;轩辕Rowboat&apos;&#125;</span><br><span class="line">    // 相当于返回了</span><br><span class="line">    // return this;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&apos;轩辕Rowboat&apos;);</span><br></pre></td></tr></table></figure><p>使用<code>new</code>操作符调用函数，会自动执行以下步骤。</p><blockquote><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol></blockquote><p>由此可以知道：<code>new</code>操作符调用时，<code>this</code>指向生成的新对象。<br><strong>特别提醒一下，<code>new</code>调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // return function f()&#123;&#125;;</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">console.log(result); &#123;name: &apos;轩辕Rowboat&apos;&#125;</span><br><span class="line">// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>很多人或者文章都忽略了这一点，直接简单用<code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p><p>之前也写了一篇文章<a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">面试官问：能否模拟实现<code>JS</code>的<code>new</code>操作符</a>，是使用apply来把this指向到生成的新生成的对象上。感兴趣的读者思考如何实现，再去看看笔者的实现。</p><h3 id="原型链中的调用模式"><a href="#原型链中的调用模式" class="headerlink" title="原型链中的调用模式"></a>原型链中的调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">var s1 = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">Student.prototype.doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">s1.doSth(); // &apos;轩辕Rowboat&apos;</span><br></pre></td></tr></table></figure><p>会发现这个似曾相识。这就是对象上的方法调用模式。自然是指向生成的新对象。<br>如果该对象继承自其它对象。同样会通过原型链查找。<br>上面代码使用<br><code>ES6</code>中<code>class</code>写法则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    doSth()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">s1.doSth();</span><br></pre></td></tr></table></figure></p><p><code>babel</code> <code>es6</code>转换成<code>es5</code>的结果，可以去<a href="https://babeljs.io/" target="_blank" rel="noopener"><code>babeljs网站转换测试</code></a>自行试试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;();</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</span><br><span class="line"></span><br><span class="line">var Student = function () &#123;</span><br><span class="line">    function Student(name) &#123;</span><br><span class="line">        _classCallCheck(this, Student);</span><br><span class="line"></span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Student, [&#123;</span><br><span class="line">        key: &apos;doSth&apos;,</span><br><span class="line">        value: function doSth() &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return Student;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var s1 = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">s1.doSth();</span><br></pre></td></tr></table></figure></p><p>由此看出，<code>ES6</code>的<code>class</code>也是通过构造函数模拟实现的，是一种语法糖。</p><h3 id="箭头函数调用模式"><a href="#箭头函数调用模式" class="headerlink" title="箭头函数调用模式"></a>箭头函数调用模式</h3><p>先看箭头函数和普通函数的重要区别：</p><blockquote><p>1、没有自己的<code>this</code>、<code>super</code>、<code>arguments</code>和<code>new.target</code>绑定。<br>2、不能使用<code>new</code>来调用。<br>3、没有原型对象。<br>4、不可以改变<code>this</code>的绑定。<br>5、形参名称不能重复。</p></blockquote><p>箭头函数中没有<code>this</code>绑定，必须通过查找作用域链来决定其值。<br>如果箭头函数被非箭头函数包含，则<code>this</code>绑定的是最近一层非箭头函数的<code>this</code>，否则<code>this</code>的值则被设置为全局对象。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: function()&#123;</span><br><span class="line">        // var self = this;</span><br><span class="line">        var arrowDoSth = () =&gt; &#123;</span><br><span class="line">            // console.log(self.name);</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        arrowDoSth();</span><br><span class="line">    &#125;,</span><br><span class="line">    arrowDoSth2: () =&gt; &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &apos;轩辕Rowboat&apos;</span><br><span class="line">student.arrowDoSth2(); // &apos;window&apos;</span><br></pre></td></tr></table></figure></p><p>其实就是相当于箭头函数外的<code>this</code>是缓存的该箭头函数上层的普通函数的<code>this</code>。如果没有普通函数，则是全局对象（浏览器中则是<code>window</code>）。<br>也就是说无法通过<code>call</code>、<code>apply</code>、<code>bind</code>绑定箭头函数的<code>this</code>(它自身没有<code>this</code>)。而<code>call</code>、<code>apply</code>、<code>bind</code>可以绑定缓存箭头函数上层的普通函数的<code>this</code>。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            console.log(&apos;arrowFn:&apos;, this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;person&apos;,</span><br><span class="line">&#125;</span><br><span class="line">student.doSth().call(person); // &apos;轩辕Rowboat&apos;  &apos;arrowFn:&apos; &apos;轩辕Rowboat&apos;</span><br><span class="line">student.doSth.call(person)(); // &apos;person&apos; &apos;arrowFn:&apos; &apos;person&apos;</span><br></pre></td></tr></table></figure></p><h3 id="DOM事件处理函数调用"><a href="#DOM事件处理函数调用" class="headerlink" title="DOM事件处理函数调用"></a><code>DOM</code>事件处理函数调用</h3><h4 id="addEventerListener、attachEvent、onclick"><a href="#addEventerListener、attachEvent、onclick" class="headerlink" title="addEventerListener、attachEvent、onclick"></a>addEventerListener、attachEvent、onclick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;button&quot;&gt;onclick&lt;/button&gt;</span><br><span class="line">&lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var button = document.querySelector(&apos;button&apos;);</span><br><span class="line">    button.onclick = function(ev)&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">        console.log(this === ev.currentTarget); // true</span><br><span class="line">    &#125;</span><br><span class="line">    var list = document.querySelector(&apos;.list&apos;);</span><br><span class="line">    list.addEventListener(&apos;click&apos;, function(ev)&#123;</span><br><span class="line">        console.log(this === list); // true</span><br><span class="line">        console.log(this === ev.currentTarget); // true</span><br><span class="line">        console.log(this);</span><br><span class="line">        console.log(ev.target);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>onclick</code>和<code>addEventerListener</code>是指向绑定事件的元素。<br>一些浏览器，比如<code>IE6~IE8</code>下使用<code>attachEvent</code>，<code>this</code>指向是<code>window</code>。<br>顺便提下：面试官也经常考察<code>ev.currentTarget</code>和<code>ev.target</code>的区别。<br><code>ev.currentTarget</code>是绑定事件的元素，而<code>ev.target</code>是当前触发事件的元素。比如这里的分别是<code>ul</code>和<code>li</code>。<br>但也可能点击的是<code>ul</code>，这时<code>ev.currentTarget</code>和<code>ev.target</code>就相等了。</p><h4 id="内联事件处理函数调用"><a href="#内联事件处理函数调用" class="headerlink" title="内联事件处理函数调用"></a>内联事件处理函数调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;btn1&quot; onclick=&quot;console.log(this === document.querySelector(&apos;.btn1&apos;))&quot;&gt;点我呀&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;console.log((function()&#123;return this&#125;)());&quot;&gt;再点我呀&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>第一个是<code>button</code>本身，所以是<code>true</code>，第二个是<code>window</code>。这里跟严格模式没有关系。<br>当然我们现在不会这样用了，但有时不小心写成了这样，也需要了解。</p><p>其实<code>this</code>的使用场景还有挺多，比如对象<code>object</code>中的<code>getter</code>、<code>setter</code>的<code>this</code>，<code>new Function()</code>、<code>eval</code>。<br>但掌握以上几种，去分析其他的，就自然迎刃而解了。<br>使用比较多的还是普通函数调用、对象的函数调用、<code>new</code>调用、<code>call、apply、bind</code>调用、箭头函数调用。<br>那么他们的优先级是怎样的呢。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>而箭头函数的<code>this</code>是上层普通函数的<code>this</code>或者是全局对象（浏览器中是<code>window</code>），所以排除，不算优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;person&apos;,</span><br><span class="line">&#125;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(&apos;return:&apos;, this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">&#125;</span><br><span class="line">// 普通函数调用</span><br><span class="line">doSth(); // window</span><br><span class="line">// 对象上的函数调用</span><br><span class="line">Student.doSth(); // &apos;轩辕Rowboat&apos;</span><br><span class="line">// call、apply 调用</span><br><span class="line">Student.doSth.call(person); // &apos;person&apos;</span><br><span class="line">new Student.doSth.call(person);</span><br></pre></td></tr></table></figure><p>试想一下，如果是<code>Student.doSth.call(person)</code>先执行的情况下，那<code>new</code>执行一个函数。是没有问题的。<br>然而事实上，这代码是报错的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a>是<code>new</code>比点号低，所以是执行<code>new (Student.doSth.call)(person)</code><br>而<code>Function.prototype.call</code>，虽然是一个函数（<code>apply</code>、<code>bind</code>也是函数），跟箭头函数一样，不能用<code>new</code>调用。所以报错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Student.doSth.call is not a constructor</span><br></pre></td></tr></table></figure></p><p>这是因为函数内部有两个不同的方法：<code>[[Call]]</code>和<code>[[Constructor]]</code>。<br>当使用普通函数调用时，<code>[[Call]]</code>会被执行。当使用构造函数调用时，<code>[[Constructor]]</code>会被执行。<code>call</code>、<code>apply</code>、<code>bind</code>和箭头函数内部没有<code>[[Constructor]]</code>方法。</p><p>从上面的例子可以看出普通函数调用优先级最低，其次是对象上的函数。<br><code>call（apply、bind）</code>调用方式和<code>new</code>调用方式的优先级，在《你不知道的JavaScript》是对比<code>bind</code>和<code>new</code>，引用了<code>mdn</code>的<code>bind</code>的<code>ployfill</code>实现，<code>new</code>调用时bind之后的函数，会忽略<code>bind</code>绑定的第一个参数，(<code>mdn</code>的实现其实还有一些问题，感兴趣的读者，可以看我之前的文章：<a href="https://juejin.im/post/5bec4183f265da616b1044d7" target="_blank" rel="noopener">面试官问：能否模拟实现<code>JS</code>的<code>bind</code>方法</a>)，说明<code>new</code>的调用的优先级最高。<br>所以它们的优先级是<code>new</code> 调用 &gt; <code>call、apply、bind</code> 调用 &gt; 对象上的函数调用 &gt; 普通函数调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要判断一个运行中函数的 <code>this</code> 绑定， 就需要找到这个函数的直接调用位置。 找到之后<br>就可以顺序应用下面这四条规则来判断 <code>this</code> 的绑定对象。</p><ol><li><code>new</code> 调用：绑定到新创建的对象，注意：显示<code>return</code>函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li><li><code>call</code> 或者 <code>apply</code>（ 或者 <code>bind</code>） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，<code>null</code>和<code>undefined</code>，指向全局对象（浏览器中是<code>window</code>），其余值指向被<code>new Object()</code>包装的对象。</li><li>对象上的函数调用：绑定到那个对象。</li><li>普通函数调用： 在严格模式下绑定到 <code>undefined</code>，否则绑定到全局对象。</li></ol><p><code>ES6</code> 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定<code>this</code>， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是<code>window</code>）。 这其实和 <code>ES6</code> 之前代码中的 <code>self = this</code> 机制一样。</p><p><code>DOM</code>事件函数：一般指向绑定事件的<code>DOM</code>元素，但有些情况绑定到全局对象（比如<code>IE6~IE8</code>的<code>attachEvent</code>）。</p><p>一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 <code>this</code> 绑<br>定， 你可以使用一个对象， 比如<code>ø = Object.create(null)</code>， 以保护全局对象。</p><p>面试官考察<code>this</code>指向就可以考察<code>new、call、apply、bind</code>，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。</p><p>读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。</p><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p><code>this</code>指向考题经常结合一些运算符等来考察。看完本文，不妨通过以下两篇面试题测试一下。<br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="noopener">小小沧海：一道常被人轻视的前端JS面试题</a><br><a href="https://segmentfault.com/a/1190000010981003" target="_blank" rel="noopener">从这两套题，重新认识JS的this、作用域、闭包、对象</a></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md" target="_blank" rel="noopener">你不知道的JavaScript 上卷</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">冴羽：JavaScript深入之从ECMAScript规范解读this</a><br><a href="https://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener">这波能反杀：前端基础进阶（五）：全方位解读this</a></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面试官出很多考题，基本都会变着方式来考察&lt;code&gt;this&lt;/code&gt;指向，看候选人对&lt;code&gt;JS&lt;/code&gt;基础知识是否扎实。&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
      <category term="面试" scheme="https://lxchuan12.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问：能否模拟实现JS的call和apply方法</title>
    <link href="https://lxchuan12.github.io/posts/410817b3.html"/>
    <id>https://lxchuan12.github.io/posts/410817b3.html</id>
    <published>2018-11-30T13:38:51.000Z</published>
    <updated>2019-02-10T14:29:24.553Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过两篇<a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">《面试官问：能否模拟实现<code>JS</code>的<code>new</code>操作符》</a>和<a href="https://juejin.im/post/5bec4183f265da616b1044d7" target="_blank" rel="noopener">《面试官问：能否模拟实现<code>JS</code>的<code>bind</code>方法》</a></p><p>其中模拟<code>bind</code>方法时是使用的<code>call</code>和<code>apply</code>修改<code>this</code>指向。但面试官可能问：能否不用<code>call</code>和<code>apply</code>来实现呢。意思也就是需要模拟实现<code>call</code>和<code>apply</code>的了。</p><blockquote><p>附上之前写文章写过的一段话：已经有很多模拟实现<code>call</code>和<code>apply</code>的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><h2 id="先通过MDN认识下call和apply"><a href="#先通过MDN认识下call和apply" class="headerlink" title="先通过MDN认识下call和apply"></a>先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN 文档：Function.prototype.call()</a><br><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p><p><strong>thisArg</strong><br>在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br><strong>arg1, arg2, …</strong><br>指定的参数列表<br><strong>返回值</strong><br>返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN 文档：Function.prototype.apply()</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p><p><strong>thisArg</strong><br>可选的。在 <code>func</code> 函数运行时使用的 <code>this</code> 值。请注意，<code>this</code>可能不是该方法看到的实际值：如果这个函数处于<strong>非严格模式</strong>下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。<br><strong>argsArray</strong><br>可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>func</code> 函数。如果该参数的值为 <code>null</code> 或  <code>undefined</code>，则表示不需要传入任何参数。从<code>ECMAScript 5</code> 开始可以使用类数组对象。<br><strong>返回值</strong><br>调用有指定this值和参数的函数的结果。<br>直接先看<strong>例子1</strong></p><h2 id="call-和-apply-的异同"><a href="#call-和-apply-的异同" class="headerlink" title="call 和 apply 的异同"></a><code>call</code> 和 <code>apply</code> 的异同</h2><p><strong>相同点：</strong><br>1、<code>call</code>和<code>apply</code>的第一个参数<code>thisArg</code>，都是<code>func</code>运行时指定的<code>this</code>。而且，<code>this</code>可能不是该方法看到的实际值：如果这个函数处于<strong>非严格模式</strong>下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。<br>2、都可以只传递一个参数。<br><strong>不同点：</strong><code>apply</code>只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计。<code>call</code>接收第二个及以后一系列的参数。<br>看两个简单例子1和2**：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子1：浏览器环境 非严格模式下</span><br><span class="line">var doSth = function(a, b)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">doSth.apply(null, [1, 2]); // this是window  // [1, 2]</span><br><span class="line">doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]</span><br><span class="line">doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]</span><br><span class="line">doSth.call(undefined, 1, 2); // this 是 window // [1, 2]</span><br><span class="line">doSth.call(&apos;0&apos;, 1, &#123;a: 1&#125;); // this 是 String(&apos;0&apos;) // [1, &#123;a: 1&#125;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 例子2：浏览器环境 严格模式下</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">var doSth2 = function(a, b)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.call(0, 1, 2); // this 是 0 // [1, 2]</span><br><span class="line">doSth2.apply(&apos;1&apos;); // this 是 &apos;1&apos; // [undefined, undefined]</span><br><span class="line">doSth2.apply(null, [1, 2]); // this 是 null // [1, 2]</span><br></pre></td></tr></table></figure><p><code>typeof</code> 有<code>7</code>种类型（<code>undefined number string boolean symbol object function</code>），笔者都验证了一遍：<strong>更加验证了相同点第一点，严格模式下，函数的<code>this</code>值就是<code>call</code>和<code>apply</code>的第一个参数<code>thisArg</code>，非严格模式下，<code>thisArg</code>值被指定为 <code>null</code> 或 <code>undefined</code> 时<code>this</code>值会自动替换为指向全局对象，原始值则会被自动包装，也就是<code>new Object()</code></strong>。</p><p>重新认识了<code>call</code>和<code>apply</code>会发现：<strong>它们作用都是一样的，改变函数里的<code>this</code>指向为第一个参数<code>thisArg</code>，如果明确有多少参数，那可以用<code>call</code>，不明确则可以使用<code>apply</code>。也就是说完全可以不使用<code>call</code>，而使用<code>apply</code>代替。</strong><br>也就是说，我们只需要模拟实现<code>apply</code>，<code>call</code>可以根据参数个数都放在一个数组中，给到<code>apply</code>即可。</p><h2 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 <code>apply</code></h2><p>既然准备模拟实现<code>apply</code>，那先得看看<code>ES5</code>规范。<a href="http://es5.github.io/#x15.3.4.3" target="_blank" rel="noopener"><code>ES5规范 英文版</code></a>，<a href="http://yanhaijing.com/es5/#322" target="_blank" rel="noopener"><code>ES5规范 中文版</code></a>。<code>apply</code>的规范下一个就是<code>call</code>的规范，可以点击打开新标签页去查看，这里摘抄一部分。</p><blockquote><p><strong>Function.prototype.apply (thisArg, argArray)</strong><br> 当以 <code>thisArg</code> 和 <code>argArray</code> 为参数在一个 <code>func</code> 对象上调用 <code>apply</code> 方法，采用如下步骤：</p></blockquote><blockquote><p>1.如果 <code>IsCallable(func)</code> 是 <code>false</code>, 则抛出一个 <code>TypeError</code> 异常。<br>2.如果 <code>argArray</code> 是 <code>null</code> 或 <code>undefined</code>, 则返回提供 <code>thisArg</code> 作为 <code>this</code> 值并以空参数列表调用 <code>func</code> 的 <code>[[Call]]</code> 内部方法的结果。<br>3.返回提供 <code>thisArg</code> 作为 <code>this</code> 值并以空参数列表调用 <code>func</code> 的 <code>[[Call]]</code> 内部方法的结果。<br>4.如果 <code>Type(argArray)</code> 不是 <code>Object</code>, 则抛出一个 <code>TypeError</code> 异常。<br>5~8 略<br>9.提供 <code>thisArg</code> 作为 <code>this</code> 值并以 <code>argList</code> 作为参数列表，调用 <code>func</code> 的 <code>[[Call]]</code> 内部方法，返回结果。<br> <code>apply</code> 方法的 <code>length</code> 属性是 <code>2</code>。</p></blockquote><blockquote><p>在外面传入的 <code>thisArg</code> 值会修改并成为 <code>this</code> 值。<code>thisArg</code> 是 <code>undefined</code> 或 <code>null</code> 时它会被替换成全局对象，所有其他值会被应用 <code>ToObject</code> 并将结果作为 <code>this</code> 值，这是第三版引入的更改。</p></blockquote><p>结合上文和规范，如何将函数里的<code>this</code>指向第一个参数<code>thisArg</code>呢，这是一个问题。<br>这时候请出<strong>例子3</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器环境 非严格模式下</span><br><span class="line">var doSth = function(a, b)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">&#125;;</span><br><span class="line">student.doSth(1, 2); // this === student // true // &apos;轩辕Rowboat&apos; // [1, 2]</span><br><span class="line">doSth.apply(student, [1, 2]); // this === student // true // &apos;轩辕Rowboat&apos; // [1, 2]</span><br></pre></td></tr></table></figure></p><p>可以<strong>得出结论1</strong>：在对象<code>student</code>上加一个函数<code>doSth</code>，再执行这个函数，这个函数里的<code>this</code>就指向了这个对象。那也就是可以在<code>thisArg</code>上新增调用函数，执行后删除这个函数即可。<br>知道这些后，我们试着容易实现第一版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器环境 非严格模式</span><br><span class="line">function getGlobalObject()&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.applyFn = function apply(thisArg, argsArray)&#123; // `apply` 方法的 `length` 属性是 `2`。</span><br><span class="line">    // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos; is not a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.如果 argArray 是 null 或 undefined, 则</span><br><span class="line">    // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line">    if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123;</span><br><span class="line">        argsArray = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .</span><br><span class="line">    if(argsArray !== new Object(argsArray))&#123;</span><br><span class="line">        throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123;</span><br><span class="line">        // 在外面传入的 thisArg 值会修改并成为 this 值。</span><br><span class="line">        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window</span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。</span><br><span class="line">    thisArg = new Object(thisArg);</span><br><span class="line">    var __fn = &apos;__fn&apos;;</span><br><span class="line">    thisArg[__fn] = this;</span><br><span class="line">    // 9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果</span><br><span class="line">    var result = thisArg[__fn](...argsArray);</span><br><span class="line">    delete thisArg[__fn];</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现第一版后，很容易找出两个问题："><a href="#实现第一版后，很容易找出两个问题：" class="headerlink" title="实现第一版后，很容易找出两个问题："></a>实现第一版后，很容易找出两个问题：</h2><ul><li>[ ] 1.<code>__fn</code> 同名覆盖问题，<code>thisArg</code>对象上有<code>__fn</code>，那就被覆盖了然后被删除了。</li></ul><p><strong>针对问题1</strong><br>解决方案一：采用<code>ES6</code> <code>Sybmol()</code> 独一无二的。可以本来就是模拟<code>ES3</code>的方法。如果面试官不允许用呢。<br>解决方案二：自己用<code>Math.random()</code>模拟实现独一无二的<code>key</code>。面试时可以直接用生成时间戳即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 生成UUID 通用唯一识别码</span><br><span class="line">// 大概生成 这样一串 &apos;18efca2d-6e25-42bf-a636-30b8f9f2de09&apos;</span><br><span class="line">function generateUUID()&#123;</span><br><span class="line">    var i, random;</span><br><span class="line">    var uuid = &apos;&apos;;</span><br><span class="line">    for (i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">        random = Math.random() * 16 | 0;</span><br><span class="line">        if (i === 8 || i === 12 || i === 16 || i === 20) &#123;</span><br><span class="line">            uuid += &apos;-&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        uuid += (i === 12 ? 4 : (i === 16 ? (random &amp; 3 | 8) : random))</span><br><span class="line">            .toString(16);</span><br><span class="line">    &#125;</span><br><span class="line">    return uuid;</span><br><span class="line">&#125;</span><br><span class="line">// 简单实现</span><br><span class="line">// &apos;__&apos; + new Date().getTime();</span><br></pre></td></tr></table></figure></p><p>如果这个<code>key</code>万一这对象中还是有，为了保险起见，可以做一次缓存操作。比如如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: &apos;doSth&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var originalVal = student.doSth;</span><br><span class="line">var hasOriginalVal = student.hasOwnProperty(&apos;doSth&apos;);</span><br><span class="line">student.doSth = function()&#123;&#125;;</span><br><span class="line">delete student.doSth;</span><br><span class="line">// 如果没有，`originalVal`则为undefined，直接赋值新增了一个undefined，这是不对的，所以需判断一下。</span><br><span class="line">if(hasOriginalVal)&#123;</span><br><span class="line">    student.doSth = originalVal;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;student:&apos;, student); // &#123; name: &apos;轩辕Rowboat&apos;, doSth: &apos;doSth&apos; &#125;</span><br></pre></td></tr></table></figure></p><ul><li>[ ] 2.使用了<code>ES6</code>扩展符<code>...</code><br>解决方案一：采用<code>eval</code>来执行函数。<blockquote><p><code>eval</code>把字符串解析成代码执行。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">MDN 文档：eval</a><br><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(string)</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>参数</strong><br><strong>string</strong><br>表示<code>JavaScript</code>表达式，语句或一系列语句的字符串。表达式可以包含变量以及已存在对象的属性。<br><strong>返回值</strong><br>执行指定代码之后的返回值。如果返回值为空，返回<code>undefined</code><br>解决方案二：但万一面试官不允许用<code>eval</code>呢，毕竟<code>eval</code>是魔鬼。可以采用<code>new Function()</code>来生成执行函数。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">MDN 文档：Function</a><br><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Function ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong><br><strong>arg1, arg2, … argN</strong><br>被函数使用的参数的名称必须是合法命名的。参数名称是一个有效的<code>JavaScript</code>标识符的字符串，或者一个用逗号分隔的有效字符串的列表;例如<code>“×”</code>，<code>“theValue”</code>，或<code>“A，B”</code>。<br><strong>functionBody</strong><br>一个含有包括函数定义的<code>JavaScript</code>语句的字符串。<br>接下来看两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单例子：</span><br><span class="line">var sum = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a + b&apos;);</span><br><span class="line">console.log(sum(2, 6));</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 稍微复杂点的例子：</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    doSth: function(argsArray)&#123;</span><br><span class="line">        console.log(argsArray);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// var result = student.doSth([&apos;Rowboat&apos;, 18]);</span><br><span class="line">// 用new Function()生成函数并执行返回结果</span><br><span class="line">var result = new Function(&apos;return arguments[0][arguments[1]](arguments[2][0], arguments[2][1])&apos;)(student, &apos;doSth&apos;, [&apos;Rowboat&apos;, 18]);</span><br><span class="line">// 个数不定</span><br><span class="line">// 所以可以写一个函数生成函数代码：</span><br><span class="line">function generateFunctionCode(argsArrayLength)&#123;</span><br><span class="line">    var code = &apos;return arguments[0][arguments[1]](&apos;;</span><br><span class="line">    for(var i = 0; i &lt; argsArrayLength; i++)&#123;</span><br><span class="line">        if(i &gt; 0)&#123;</span><br><span class="line">            code += &apos;,&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        code += &apos;arguments[2][&apos; + i + &apos;]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    code += &apos;)&apos;;</span><br><span class="line">    // return arguments[0][arguments[1]](arg1, arg2, arg3...)</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="你可能不知道在ES3、ES5中-undefined-是能修改的"><a href="#你可能不知道在ES3、ES5中-undefined-是能修改的" class="headerlink" title="你可能不知道在ES3、ES5中 undefined 是能修改的"></a>你可能不知道在<code>ES3、ES5</code>中 <code>undefined</code> 是能修改的</h2><p>可能大部分人不知道。<code>ES5</code>中虽然在全局作用域下不能修改，但在局部作用域中也是能修改的，不信可以复制以下测试代码在控制台执行下。虽然一般情况下是不会的去修改它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var undefined = 3;</span><br><span class="line">    console.log(undefined); // chrome下也是 3</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p><p>所以判断一个变量<code>a</code>是不是<code>undefined</code>，更严谨的方案是<code>typeof a === &#39;undefined&#39;</code>或者<code>a === void 0;</code><br>这里面用的是<code>void</code>，<code>void</code>的作用是计算表达式，始终返回<code>undefined</code>，也可以这样写<code>void(0)</code>。<br>更多可以查看<code>韩子迟</code>的这篇文章：<a href="https://github.com/hanzichi/underscore-analysis/issues/1" target="_blank" rel="noopener">为什么用「void 0」代替「undefined」</a><br>解决了这几个问题，比较容易实现如下代码。</p><h2 id="使用-new-Function-模拟实现的apply"><a href="#使用-new-Function-模拟实现的apply" class="headerlink" title="使用 new Function() 模拟实现的apply"></a>使用 <code>new Function()</code> 模拟实现的<code>apply</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器环境 非严格模式</span><br><span class="line">function getGlobalObject()&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">function generateFunctionCode(argsArrayLength)&#123;</span><br><span class="line">    var code = &apos;return arguments[0][arguments[1]](&apos;;</span><br><span class="line">    for(var i = 0; i &lt; argsArrayLength; i++)&#123;</span><br><span class="line">        if(i &gt; 0)&#123;</span><br><span class="line">            code += &apos;,&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        code += &apos;arguments[2][&apos; + i + &apos;]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    code += &apos;)&apos;;</span><br><span class="line">    // return arguments[0][arguments[1]](arg1, arg2, arg3...)</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.applyFn = function apply(thisArg, argsArray)&#123; // `apply` 方法的 `length` 属性是 `2`。</span><br><span class="line">    // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos; is not a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.如果 argArray 是 null 或 undefined, 则</span><br><span class="line">    // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</span><br><span class="line">    if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123;</span><br><span class="line">        argsArray = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .</span><br><span class="line">    if(argsArray !== new Object(argsArray))&#123;</span><br><span class="line">        throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123;</span><br><span class="line">        // 在外面传入的 thisArg 值会修改并成为 this 值。</span><br><span class="line">        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window</span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    &#125;</span><br><span class="line">    // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。</span><br><span class="line">    thisArg = new Object(thisArg);</span><br><span class="line">    var __fn = &apos;__&apos; + new Date().getTime();</span><br><span class="line">    // 万一还是有 先存储一份，删除后，再恢复该值</span><br><span class="line">    var originalVal = thisArg[__fn];</span><br><span class="line">    // 是否有原始值</span><br><span class="line">    var hasOriginalVal = thisArg.hasOwnProperty(__fn);</span><br><span class="line">    thisArg[__fn] = this;</span><br><span class="line">    // 9.提供 `thisArg` 作为 `this` 值并以 `argList` 作为参数列表，调用 `func` 的 `[[Call]]` 内部方法，返回结果。</span><br><span class="line">    // ES6版</span><br><span class="line">    // var result = thisArg[__fn](...args);</span><br><span class="line">    var code = generateFunctionCode(argsArray.length);</span><br><span class="line">    var result = (new Function(code))(thisArg, __fn, argsArray);</span><br><span class="line">    delete thisArg[__fn];</span><br><span class="line">    if(hasOriginalVal)&#123;</span><br><span class="line">        thisArg[__fn] = originalVal;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用模拟实现的apply模拟实现call"><a href="#利用模拟实现的apply模拟实现call" class="headerlink" title="利用模拟实现的apply模拟实现call"></a>利用模拟实现的<code>apply</code>模拟实现<code>call</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.callFn = function call(thisArg)&#123;</span><br><span class="line">    var argsArray = [];</span><br><span class="line">    var argumentsLength = arguments.length;</span><br><span class="line">    for(var i = 0; i &lt; argumentsLength - 1; i++)&#123;</span><br><span class="line">        // argsArray.push(arguments[i + 1]);</span><br><span class="line">        argsArray[i] = arguments[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;argsArray:&apos;, argsArray);</span><br><span class="line">    return this.applyFn(thisArg, argsArray);</span><br><span class="line">&#125;</span><br><span class="line">// 测试例子</span><br><span class="line">var doSth = function (name, age)&#123;</span><br><span class="line">    var type = Object.prototype.toString.call(this);</span><br><span class="line">    console.log(typeof doSth);</span><br><span class="line">    console.log(this === firstArg);</span><br><span class="line">    console.log(&apos;type:&apos;, type);</span><br><span class="line">    console.log(&apos;this:&apos;, this);</span><br><span class="line">    console.log(&apos;args:&apos;, [name, age], arguments);</span><br><span class="line">    return &apos;this--&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var name = &apos;window&apos;;</span><br><span class="line"></span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    doSth: &apos;doSth&apos;,</span><br><span class="line">    __fn: &apos;doSth&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var firstArg = student;</span><br><span class="line">var result = doSth.applyFn(firstArg, [1, &#123;name: &apos;Rowboat&apos;&#125;]);</span><br><span class="line">var result2 = doSth.callFn(firstArg, 1, &#123;name: &apos;Rowboat&apos;&#125;);</span><br><span class="line">console.log(&apos;result:&apos;, result);</span><br><span class="line">console.log(&apos;result2:&apos;, result2);</span><br></pre></td></tr></table></figure><p>细心的你会发现注释了这一句<code>argsArray.push(arguments[i + 1]);</code>，事实上<code>push</code>方法，内部也有一层循环。所以理论上不使用<code>push</code>性能会更好些。面试官也可能根据这点来问时间复杂度和空间复杂度的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 看看V8引擎中的具体实现：</span><br><span class="line">function ArrayPush() &#123;</span><br><span class="line">    var n = TO_UINT32( this.length );    // 被push的对象的length</span><br><span class="line">    var m = %_ArgumentsLength();     // push的参数个数</span><br><span class="line">    for (var i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        this[ i + n ] = %_Arguments( i );   // 复制元素     (1)</span><br><span class="line">    &#125;</span><br><span class="line">    this.length = n + m;      // 修正length属性的值    (2)</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>行文至此，就基本结束了，你可能还发现就是写的非严格模式下，<code>thisArg</code>原始值会包装成对象，添加函数并执行，再删除。而严格模式下还是原始值这个没有实现，而且万一这个对象是冻结对象呢，<code>Object.freeze({})</code>，是无法在这个对象上添加属性的。所以这个方法只能算是非严格模式下的简版实现。最后来总结一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>MDN</code>认识<code>call</code>和<code>apply</code>，阅读<code>ES5</code>规范，到模拟实现<code>apply</code>，再实现<code>call</code>。<br>就是使用在对象上添加调用<code>apply</code>的函数执行，这时的调用函数的<code>this</code>就指向了这个<code>thisArg</code>，再返回结果。引出了<code>ES6 Symbol</code>，<code>ES6</code>的扩展符<code>...</code>、<code>eval</code>、<code>new Function()</code>，严格模式等。<br>事实上，现实业务场景不需要去模拟实现<code>call</code>和<code>apply</code>,毕竟是<code>ES3</code>就提供的方法。但面试官可以通过这个面试题考察候选人很多基础知识。如：<code>call</code>、<code>apply</code>的使用。<code>ES6 Symbol</code>，<code>ES6</code>的扩展符<code>...</code>，<code>eval</code>，<code>new Function()</code>，严格模式，甚至时间复杂度和空间复杂度等。<br>读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 最终版版 删除注释版，详细注释看文章</span><br><span class="line">// 浏览器环境 非严格模式</span><br><span class="line">function getGlobalObject()&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">function generateFunctionCode(argsArrayLength)&#123;</span><br><span class="line">    var code = &apos;return arguments[0][arguments[1]](&apos;;</span><br><span class="line">    for(var i = 0; i &lt; argsArrayLength; i++)&#123;</span><br><span class="line">        if(i &gt; 0)&#123;</span><br><span class="line">            code += &apos;,&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        code += &apos;arguments[2][&apos; + i + &apos;]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    code += &apos;)&apos;;</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.applyFn = function apply(thisArg, argsArray)&#123;</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos; is not a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof argsArray === &apos;undefined&apos; || argsArray === null)&#123;</span><br><span class="line">        argsArray = [];</span><br><span class="line">    &#125;</span><br><span class="line">    if(argsArray !== new Object(argsArray))&#123;</span><br><span class="line">        throw new TypeError(&apos;CreateListFromArrayLike called on non-object&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof thisArg === &apos;undefined&apos; || thisArg === null)&#123;</span><br><span class="line">        thisArg = getGlobalObject();</span><br><span class="line">    &#125;</span><br><span class="line">    thisArg = new Object(thisArg);</span><br><span class="line">    var __fn = &apos;__&apos; + new Date().getTime();</span><br><span class="line">    var originalVal = thisArg[__fn];</span><br><span class="line">    var hasOriginalVal = thisArg.hasOwnProperty(__fn);</span><br><span class="line">    thisArg[__fn] = this;</span><br><span class="line">    var code = generateFunctionCode(argsArray.length);</span><br><span class="line">    var result = (new Function(code))(thisArg, __fn, argsArray);</span><br><span class="line">    delete thisArg[__fn];</span><br><span class="line">    if(hasOriginalVal)&#123;</span><br><span class="line">        thisArg[__fn] = originalVal;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.callFn = function call(thisArg)&#123;</span><br><span class="line">    var argsArray = [];</span><br><span class="line">    var argumentsLength = arguments.length;</span><br><span class="line">    for(var i = 0; i &lt; argumentsLength - 1; i++)&#123;</span><br><span class="line">        argsArray[i] = arguments[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return this.applyFn(thisArg, argsArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.ituring.com.cn/book/tupubarticle/7768" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》- 第二章 第 2 章　this、call和apply</a><br><a href="https://cloud.tencent.com/developer/article/1023535" target="_blank" rel="noopener">JS魔法堂：再次认识Function.prototype.call</a><br><a href="https://github.com/jawil/blog/issues/16" target="_blank" rel="noopener">不用call和apply方法模拟实现ES5的bind方法</a><br><a href="https://juejin.im/post/5907eb99570c3500582ca23c" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写过两篇&lt;a href=&quot;https://juejin.im/post/5bde7c926fb9a049f66b8b52&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《面试官问：能否模拟实现&lt;code&gt;JS&lt;/code&gt;的&lt;code&gt;new&lt;/cod
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
      <category term="面试" scheme="https://lxchuan12.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问：能否模拟实现JS的bind方法</title>
    <link href="https://lxchuan12.github.io/posts/7276cffa.html"/>
    <id>https://lxchuan12.github.io/posts/7276cffa.html</id>
    <published>2018-11-21T12:31:50.000Z</published>
    <updated>2019-02-10T14:29:24.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用过<code>React</code>的同学都知道，经常会使用<code>bind</code>来绑定<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class TodoItem extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.handleClick = this.handleClick.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick()&#123;</span><br><span class="line">        console.log(&apos;handleClick&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return  (</span><br><span class="line">            &lt;div onClick=&#123;this.handleClick&#125;&gt;点击&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">export default TodoItem;</span><br></pre></td></tr></table></figure></p><p><strong>那么面试官可能会问是否想过<code>bind</code>到底做了什么，怎么模拟实现呢。</strong></p><blockquote><p>附上之前写文章写过的一段话：已经有很多模拟实现<code>bind</code>的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p>先看一下<code>bind</code>是什么。从上面的<code>React</code>代码中，可以看出<code>bind</code>执行后是函数，并且每个函数都可以执行调用它。<br>眼见为实，耳听为虚。读者可以在控制台一步步点开<strong>例子1</strong>中的<code>obj</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(typeof Function.prototype.bind); // function</span><br><span class="line">console.log(typeof Function.prototype.bind());  // function</span><br><span class="line">console.log(Function.prototype.bind.name);  // bind</span><br><span class="line">console.log(Function.prototype.bind().name);  // bound</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/11/18/16726f4175f9c34d?w=1109&h=518&f=png&s=67135" alt="`Function.prototype.bind`" title="">                </div>                <div class="image-caption">`Function.prototype.bind`</div>            </figure><h3 id="因此可以得出结论1："><a href="#因此可以得出结论1：" class="headerlink" title="因此可以得出结论1："></a>因此可以得出结论1：</h3><p>1、<code>bind</code>是<code>Functoin</code>原型链中<code>Function.prototype</code>的一个属性，每个函数都可以调用它。<br><br>2、<code>bind</code>本身是一个函数名为<code>bind</code>的函数，返回值也是函数，函数名是<code>bound</code>。（打出来就是<code>bound加上一个空格</code>）。<br>知道了<code>bind</code>是函数，就可以传参，而且返回值<code>&#39;bound &#39;</code>也是函数，也可以传参，就很容易写出<strong>例子2</strong>：<br>后文统一 <code>bound</code> 指原函数<code>original</code> <code>bind</code>之后返回的函数，便于说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">function original(a, b)&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var bound = original.bind(obj, 1);</span><br><span class="line">var boundResult = bound(2); // &apos;轩辕Rowboat&apos;, [1, 2]</span><br><span class="line">console.log(boundResult); // false</span><br><span class="line">console.log(original.bind.name); // &apos;bind&apos;</span><br><span class="line">console.log(original.bind.length); // 1</span><br><span class="line">console.log(original.bind().length); // 2 返回original函数的形参个数</span><br><span class="line">console.log(bound.name); // &apos;bound original&apos;</span><br><span class="line">console.log((function()&#123;&#125;).bind().name); // &apos;bound &apos;</span><br><span class="line">console.log((function()&#123;&#125;).bind().length); // 0</span><br></pre></td></tr></table></figure></p><h3 id="由此可以得出结论2："><a href="#由此可以得出结论2：" class="headerlink" title="由此可以得出结论2："></a>由此可以得出结论2：</h3><p>1、调用<code>bind</code>的函数中的<code>this</code>指向<code>bind()</code>函数的第一个参数。</p><p>2、传给<code>bind()</code>的其他参数接收处理了，<code>bind()</code>之后返回的函数的参数也接收处理了，也就是说合并处理了。</p><p>3、并且<code>bind()</code>后的<code>name</code>为<code>bound + 空格 + 调用bind的函数名</code>。如果是匿名函数则是<code>bound + 空格</code>。</p><p>4、<code>bind</code>后的返回值函数，执行后返回值是原函数（<code>original</code>）的返回值。</p><p>5、<code>bind</code>函数形参（即函数的<code>length</code>）是<code>1</code>。<code>bind</code>后返回的<code>bound</code>函数形参不定，根据绑定的函数原函数（<code>original</code>）形参个数确定。</p><p>根据结论2：我们就可以简单模拟实现一个简版<code>bindFn</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 第一版 修改this指向，合并参数</span><br><span class="line">Function.prototype.bindFn = function bind(thisArg)&#123;</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos;must be a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 存储函数本身</span><br><span class="line">    var self = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function()&#123;</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">        return self.apply(thisArg, args.concat(boundArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    return bound;</span><br><span class="line">&#125;</span><br><span class="line">// 测试</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">function original(a, b)&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    console.log([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">var bound = original.bindFn(obj, 1);</span><br><span class="line">bound(2); // &apos;轩辕Rowboat&apos;, [1, 2]</span><br></pre></td></tr></table></figure></p><p>如果面试官看到你答到这里，估计对你的印象60、70分应该是会有的。<br>但我们知道函数是可以用<code>new</code>来实例化的。那么<code>bind()</code>返回值函数会是什么表现呢。<br>接下来看<strong>例子3</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">function original(a, b)&#123;</span><br><span class="line">    console.log(&apos;this&apos;, this); // original &#123;&#125;</span><br><span class="line">    console.log(&apos;typeof this&apos;, typeof this); // object</span><br><span class="line">    this.name = b;</span><br><span class="line">    console.log(&apos;name&apos;, this.name); // 2</span><br><span class="line">    console.log(&apos;this&apos;, this);  // original &#123;name: 2&#125;</span><br><span class="line">    console.log([a, b]); // 1, 2</span><br><span class="line">&#125;</span><br><span class="line">var bound = original.bind(obj, 1);</span><br><span class="line">var newBoundResult = new bound(2);</span><br><span class="line">console.log(newBoundResult, &apos;newBoundResult&apos;); // original &#123;name: 2&#125;</span><br></pre></td></tr></table></figure></p><p>从<strong>例子3</strong>种可以看出<code>this</code>指向了<code>new bound()</code>生成的新对象。</p><h3 id="可以分析得出结论3："><a href="#可以分析得出结论3：" class="headerlink" title="可以分析得出结论3："></a>可以分析得出结论3：</h3><p>1、<code>bind</code>原先指向<code>obj</code>的失效了，其他参数有效。</p><p>2、<code>new bound</code>的返回值是以<code>original</code>原函数构造器生成的新对象。<code>original</code>原函数的<code>this</code>指向的就是这个新对象。<br>另外前不久写过一篇文章：<a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">面试官问：能否模拟实现JS的new操作符</a>。简单摘要：<br><strong>new做了什么：</strong></p><blockquote><p>1.创建了一个全新的对象。<br><br>2.这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。<br><br>3.生成的新对象会绑定到函数调用的this。<br><br>4.通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。<br><br>5.如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</p></blockquote><p>所以相当于<code>new</code>调用时，<code>bind</code>的返回值函数<code>bound</code>内部要模拟实现<code>new</code>实现的操作。<br>话不多说，直接上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 第三版 实现new调用</span><br><span class="line">Function.prototype.bindFn = function bind(thisArg)&#123;</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos; must be a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 存储调用bind的函数本身</span><br><span class="line">    var self = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function()&#123;</span><br><span class="line">        // bind返回的函数 的参数转成数组</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。</span><br><span class="line">        if(this instanceof bound)&#123;</span><br><span class="line">            // 这里是实现上文描述的 new 的第 1, 2, 4 步</span><br><span class="line">            // 1.创建一个全新的对象</span><br><span class="line">            // 2.并且执行[[Prototype]]链接</span><br><span class="line">            // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">            // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。</span><br><span class="line">            if(self.prototype)&#123;</span><br><span class="line">                // ES5 提供的方案 Object.create()</span><br><span class="line">                // bound.prototype = Object.create(self.prototype);</span><br><span class="line">                // 但 既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()</span><br><span class="line">                // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</span><br><span class="line">                function Empty()&#123;&#125;</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里是实现上文描述的 new 的第 3 步</span><br><span class="line">            // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            // 这里是实现上文描述的 new 的第 5 步</span><br><span class="line">            // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，</span><br><span class="line">            // 那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">            var isObject = typeof result === &apos;object&apos; &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === &apos;function&apos;;</span><br><span class="line">            if(isObject || isFunction)&#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>面试官看到这样的实现代码，基本就是满分了，心里独白：这小伙子/小姑娘不错啊。不过可能还会问<code>this instanceof bound</code>不准确问题。<br>上文注释中提到<code>this instanceof bound</code>也不是很准确，<code>ES6 new.target</code>很好的解决这一问题，我们举个<strong>例子4</strong>:</p><h3 id="instanceof-不准确，ES6-new-target很好的解决这一问题"><a href="#instanceof-不准确，ES6-new-target很好的解决这一问题" class="headerlink" title="instanceof 不准确，ES6 new.target很好的解决这一问题"></a><code>instanceof</code> 不准确，<code>ES6 new.target</code>很好的解决这一问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    if(this instanceof Student)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(&apos;name&apos;, name);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        throw new Error(&apos;必须通过new关键字来调用Student。&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;轩辕&apos;);</span><br><span class="line">var notAStudent = Student.call(student, &apos;Rowboat&apos;); // 不抛出错误，且执行了。</span><br><span class="line">console.log(student, &apos;student&apos;, notAStudent, &apos;notAStudent&apos;);</span><br><span class="line"></span><br><span class="line">function Student2(name)&#123;</span><br><span class="line">    if(typeof new.target !== &apos;undefined&apos;)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(&apos;name&apos;, name);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        throw new Error(&apos;必须通过new关键字来调用Student2。&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var student2 = new Student2(&apos;轩辕&apos;);</span><br><span class="line">var notAStudent2 = Student2.call(student2, &apos;Rowboat&apos;);</span><br><span class="line">console.log(student2, &apos;student2&apos;, notAStudent2, &apos;notAStudent2&apos;); // 抛出错误</span><br></pre></td></tr></table></figure><p>细心的同学可能会发现了这版本的代码没有实现<code>bind</code>后的<code>bound</code>函数的<code>name</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="noopener">MDN Function.name</a>和<code>length</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="noopener">MDN Function.length</a>。面试官可能也发现了这一点继续追问，如何实现，或者问是否看过<a href="https://github.com/es-shims/es5-shim/blob/master/es5-shim.js#L201-L335" target="_blank" rel="noopener"><code>es5-shim</code>的源码实现<code>L201-L335</code></a>。如果不限<code>ES</code>版本。其实可以用<code>ES5</code>的<code>Object.defineProperties</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(bound, &#123;</span><br><span class="line">    &apos;length&apos;: &#123;</span><br><span class="line">        value: self.length,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;name&apos;: &#123;</span><br><span class="line">        value: &apos;bound &apos; + self.name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="es5-shim的源码实现bind"><a href="#es5-shim的源码实现bind" class="headerlink" title="es5-shim的源码实现bind"></a><code>es5-shim</code>的源码实现<code>bind</code></h3><p>直接附上源码（有删减注释和部分修改等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var $Array = Array;</span><br><span class="line">var ArrayPrototype = $Array.prototype;</span><br><span class="line">var $Object = Object;</span><br><span class="line">var array_push = ArrayPrototype.push;</span><br><span class="line">var array_slice = ArrayPrototype.slice;</span><br><span class="line">var array_join = ArrayPrototype.join;</span><br><span class="line">var array_concat = ArrayPrototype.concat;</span><br><span class="line">var $Function = Function;</span><br><span class="line">var FunctionPrototype = $Function.prototype;</span><br><span class="line">var apply = FunctionPrototype.apply;</span><br><span class="line">var max = Math.max;</span><br><span class="line">// 简版 源码更复杂些。</span><br><span class="line">var isCallable = function isCallable(value)&#123;</span><br><span class="line">    if(typeof value !== &apos;function&apos;)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br><span class="line">var Empty = function Empty() &#123;&#125;;</span><br><span class="line">// 源码是 defineProperties</span><br><span class="line">// 源码是bind笔者改成bindFn便于测试</span><br><span class="line">FunctionPrototype.bindFn = function bind(that) &#123;</span><br><span class="line">    var target = this;</span><br><span class="line">    if (!isCallable(target)) &#123;</span><br><span class="line">        throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);</span><br><span class="line">    &#125;</span><br><span class="line">    var args = array_slice.call(arguments, 1);</span><br><span class="line">    var bound;</span><br><span class="line">    var binder = function () &#123;</span><br><span class="line">        if (this instanceof bound) &#123;</span><br><span class="line">            var result = apply.call(</span><br><span class="line">                target,</span><br><span class="line">                this,</span><br><span class="line">                array_concat.call(args, array_slice.call(arguments))</span><br><span class="line">            );</span><br><span class="line">            if ($Object(result) === result) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return apply.call(</span><br><span class="line">                target,</span><br><span class="line">                that,</span><br><span class="line">                array_concat.call(args, array_slice.call(arguments))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var boundLength = max(0, target.length - args.length);</span><br><span class="line">    var boundArgs = [];</span><br><span class="line">    for (var i = 0; i &lt; boundLength; i++) &#123;</span><br><span class="line">        array_push.call(boundArgs, &apos;$&apos; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里是Function构造方式生成形参length $1, $2, $3...</span><br><span class="line">    bound = $Function(&apos;binder&apos;, &apos;return function (&apos; + array_join.call(boundArgs, &apos;,&apos;) + &apos;)&#123; return binder.apply(this, arguments); &#125;&apos;)(binder);</span><br><span class="line"></span><br><span class="line">    if (target.prototype) &#123;</span><br><span class="line">        Empty.prototype = target.prototype;</span><br><span class="line">        bound.prototype = new Empty();</span><br><span class="line">        Empty.prototype = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>你说出<code>es5-shim</code>源码<code>bind</code>实现，感慨这代码真是高效、严谨。面试官心里独白可能是：你就是我要找的人，薪酬福利你可以和<code>HR</code>去谈下。</p><h2 id="最后总结一下"><a href="#最后总结一下" class="headerlink" title="最后总结一下"></a>最后总结一下</h2><p>1、<code>bind</code>是<code>Function</code>原型链中的<code>Function.prototype</code>的一个属性，它是一个函数，修改<code>this</code>指向，合并参数传递给原函数，返回值是一个新的函数。<br>2、<code>bind</code>返回的函数可以通过<code>new</code>调用，这时提供的<code>this</code>的参数被忽略，指向了<code>new</code>生成的全新对象。内部模拟实现了<code>new</code>操作符。<br>3、<code>es5-shim</code>源码模拟实现<code>bind</code>时用<code>Function</code>实现了<code>length</code>。<br>事实上，平时其实很少需要使用自己实现的投入到生成环境中。但面试官通过这个面试题能考察很多知识。比如<code>this</code>指向，原型链，闭包，函数等知识，可以扩展很多。<br>读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。</p><p>文章中的例子和测试代码放在<code>github</code>中<a href="https://github.com/lxchuan12/html5/tree/gh-pages/JS%E7%9B%B8%E5%85%B3/%E5%87%BD%E6%95%B0/bind%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">bind模拟实现 github</a>。<a href="http://lxchuan12.github.io/html5/JS%E7%9B%B8%E5%85%B3/%E5%87%BD%E6%95%B0/bind%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/bind-0.html">bind模拟实现 预览地址</a> <code>F12</code>看控制台输出，结合<code>source</code>面板查看效果更佳。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 最终版 删除注释 详细注释版请看上文</span><br><span class="line">Function.prototype.bind = Function.prototype.bind || function bind(thisArg)&#123;</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(this + &apos; must be a function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = [].slice.call(arguments, 1);</span><br><span class="line">    var bound = function()&#123;</span><br><span class="line">        var boundArgs = [].slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(boundArgs);</span><br><span class="line">        if(this instanceof bound)&#123;</span><br><span class="line">            if(self.prototype)&#123;</span><br><span class="line">                function Empty()&#123;&#125;</span><br><span class="line">                Empty.prototype = self.prototype;</span><br><span class="line">                bound.prototype = new Empty();</span><br><span class="line">            &#125;</span><br><span class="line">            var result = self.apply(this, finalArgs);</span><br><span class="line">            var isObject = typeof result === &apos;object&apos; &amp;&amp; result !== null;</span><br><span class="line">            var isFunction = typeof result === &apos;function&apos;;</span><br><span class="line">            if(isObject || isFunction)&#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return self.apply(thisArg, finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://oshotokill.gitbooks.io/understandinges6-simplified-chinese/content/chapter_3.html" target="_blank" rel="noopener">OshotOkill翻译的 深入理解<code>ES6</code> 简体中文版 - 第三章 函数</a>（虽然我是看的纸质书籍，但推荐下这本在线的书）<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN Function.prototype.bind</a><br><a href="https://juejin.im/post/59093b1fa0bb9f006517b906" target="_blank" rel="noopener">冴羽: JavaScript深入之bind的模拟实现</a><br><a href="https://www.jianshu.com/p/6958f99db769" target="_blank" rel="noopener">《react状态管理与同构实战》侯策：从一道面试题，到“我可能看了假源码”</a></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用过&lt;code&gt;React&lt;/code&gt;的同学都知道，经常会使用&lt;code&gt;bind&lt;/code&gt;来绑定&lt;code&gt;this&lt;/code&gt;。
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
      <category term="面试" scheme="https://lxchuan12.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问：能否模拟实现JS的new操作符</title>
    <link href="https://lxchuan12.github.io/posts/d4c0af6f.html"/>
    <id>https://lxchuan12.github.io/posts/d4c0af6f.html</id>
    <published>2018-11-05T15:48:12.000Z</published>
    <updated>2019-02-10T14:29:24.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用过<code>Vuejs</code>的同学都知道，需要用<code>new</code>操作符来实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    mounted()&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>那么面试官可能会问是否想过<code>new</code>到底做了什么，怎么模拟实现呢。</strong></p><blockquote><p>附上之前写文章写过的一段话：已经有很多模拟实现<code>new</code>操作符的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><h2 id="new-做了什么"><a href="#new-做了什么" class="headerlink" title="new 做了什么"></a>new 做了什么</h2><p>先看简单<strong>例子1</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 例子1</span><br><span class="line">function Student()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student();</span><br><span class="line">console.log(student); // &#123;&#125;</span><br><span class="line">// student 是一个对象。</span><br><span class="line">console.log(Object.prototype.toString.call(student)); // [object Object]</span><br><span class="line">// 我们知道平时声明对象也可以用new Object(); 只是看起来更复杂</span><br><span class="line">// 顺便提一下 `new Object`(不推荐)和Object()也是一样的效果</span><br><span class="line">// 可以猜测内部做了一次判断，用new调用</span><br><span class="line">/** if (!(this instanceof Object)) &#123;</span><br><span class="line">*    return new Object();</span><br><span class="line">*  &#125;</span><br><span class="line">*/</span><br><span class="line">var obj = new Object();</span><br><span class="line">console.log(obj) // &#123;&#125;</span><br><span class="line">console.log(Object.prototype.toString.call(student)); // [object Object]</span><br><span class="line"></span><br><span class="line">typeof Student === &apos;function&apos; // true</span><br><span class="line">typeof Object === &apos;function&apos; // true</span><br></pre></td></tr></table></figure></p><p>从这里例子中，我们可以看出：一个函数用<code>new</code>操作符来调用后，生成了一个全新的对象。而且<code>Student</code>和<code>Object</code>都是函数，只不过<code>Student</code>是我们自定义的，<code>Object</code>是<code>JS</code>本身就内置的。<br>再来看下控制台输出图，感兴趣的读者可以在控制台试试。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/11/4/166dde2ad5d6bd84?w=573&h=870&f=png&s=143219" alt="例子1 控制台输出图" title="">                </div>                <div class="image-caption">例子1 控制台输出图</div>            </figure><br>与<code>new Object()</code> 生成的对象不同的是<code>new Student()</code>生成的对象中间还嵌套了一层<code>__proto__</code>，它的<code>constructor</code>是<code>Student</code>这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 也就是说：</span><br><span class="line">student.constructor === Student;</span><br><span class="line">Student.prototype.constructor === Student;</span><br></pre></td></tr></table></figure></p><h3 id="小结1：从这个简单例子来看，new操作符做了两件事："><a href="#小结1：从这个简单例子来看，new操作符做了两件事：" class="headerlink" title="小结1：从这个简单例子来看，new操作符做了两件事："></a>小结1：从这个简单例子来看，<code>new</code>操作符做了两件事：</h3><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li></ol><p>接下来我们再来看升级版的<strong>例子2</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例子2</span><br><span class="line">function Student(name)&#123;</span><br><span class="line">    console.log(&apos;赋值前-this&apos;, this); // &#123;&#125;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(&apos;赋值后-this&apos;, this); // &#123;name: &apos;轩辕Rowboat&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">console.log(student); // &#123;name: &apos;轩辕Rowboat&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>由此可以看出：这里<code>Student</code>函数中的<code>this</code>指向<code>new Student()</code>生成的对象<code>student</code>。</p><h3 id="小结2：从这个例子来看，new操作符又做了一件事："><a href="#小结2：从这个例子来看，new操作符又做了一件事：" class="headerlink" title="小结2：从这个例子来看，new操作符又做了一件事："></a>小结2：从这个例子来看，<code>new</code>操作符又做了一件事：</h3><ol><li>生成的新对象会绑定到函数调用的<code>this</code>。</li></ol><p>接下来继续看升级版<strong>例子3</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 例子3</span><br><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // this.doSth();</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.doSth = function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var student1 = new Student(&apos;轩辕&apos;);</span><br><span class="line">var student2 = new Student(&apos;Rowboat&apos;);</span><br><span class="line">console.log(student1, student1.doSth()); // &#123;name: &apos;轩辕&apos;&#125; &apos;轩辕&apos;</span><br><span class="line">console.log(student2, student2.doSth()); // &#123;name: &apos;Rowboat&apos;&#125; &apos;Rowboat&apos;</span><br><span class="line">student1.__proto__ === Student.prototype; // true</span><br><span class="line">student2.__proto__ === Student.prototype; // true</span><br><span class="line">// __proto__ 是浏览器实现的查看原型方案。</span><br><span class="line">// 用ES5 则是：</span><br><span class="line">Object.getPrototypeOf(student1) === Student.prototype; // true</span><br><span class="line">Object.getPrototypeOf(student2) === Student.prototype; // true</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/11/4/166de20191257b2a?w=628&h=898&f=png&s=120541" alt="例子3 控制台输出图" title="">                </div>                <div class="image-caption">例子3 控制台输出图</div>            </figure><p>关于JS的原型关系笔者之前看到这张图，觉得很不错，分享给大家。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee0c1854fab5?w=1019&h=741&f=png&s=43421" alt="JavaScript原型关系图" title="">                </div>                <div class="image-caption">JavaScript原型关系图</div>            </figure></p><h3 id="小结3：这个例子3再一次验证了小结1中的第2点。"><a href="#小结3：这个例子3再一次验证了小结1中的第2点。" class="headerlink" title="小结3：这个例子3再一次验证了小结1中的第2点。"></a>小结3：这个例子3再一次验证了<strong>小结1</strong>中的<strong>第2点</strong>。</h3><p>也就是这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。并且通过<code>new Student()</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个<code>Student.protytype</code>对象上。</p><p>细心的同学可能会发现这三个例子中的函数都没有返回值。那么有返回值会是怎样的情形呢。<br>那么接下来请看<strong>例子4</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 例子4</span><br><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // Null（空） null</span><br><span class="line">    // Undefined（未定义） undefined</span><br><span class="line">    // Number（数字） 1</span><br><span class="line">    // String（字符串）&apos;1&apos;</span><br><span class="line">    // Boolean（布尔） true</span><br><span class="line">    // Symbol（符号）（第六版新增） symbol</span><br><span class="line">    </span><br><span class="line">    // Object（对象） &#123;&#125;</span><br><span class="line">        // Function（函数） function()&#123;&#125;</span><br><span class="line">        // Array（数组） []</span><br><span class="line">        // Date（日期） new Date()</span><br><span class="line">        // RegExp（正则表达式）/a/</span><br><span class="line">        // Error （错误） new Error() </span><br><span class="line">    // return /a/;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&apos;轩辕Rowboat&apos;);</span><br><span class="line">console.log(student); &#123;name: &apos;轩辕Rowboat&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>笔者测试这七种类型后<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN JavaScript类型</a>，得出的结果是：前面六种基本类型都会正常返回<code>{name: &#39;轩辕Rowboat&#39;}</code>，后面的<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)都会直接返回这些值。</p><h3 id="由此得出-小结4："><a href="#由此得出-小结4：" class="headerlink" title="由此得出 小结4："></a>由此得出 小结4：</h3><ol><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol><p>结合这些小结，整理在一起就是：</p><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol><h2 id="new-模拟实现"><a href="#new-模拟实现" class="headerlink" title="new 模拟实现"></a>new 模拟实现</h2><p>知道了这些现象，我们就可以模拟实现<code>new</code>操作符。直接贴出代码和注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟实现 new 操作符</span><br><span class="line"> * @param  &#123;Function&#125; ctor [构造函数]</span><br><span class="line"> * @return &#123;Object|Function|Regex|Date|Error&#125;      [返回结果]</span><br><span class="line"> */</span><br><span class="line">function newOperator(ctor)&#123;</span><br><span class="line">    if(typeof ctor !== &apos;function&apos;)&#123;</span><br><span class="line">      throw &apos;newOperator function the first param must be a function&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    // 1.创建一个全新的对象，</span><br><span class="line">    // 2.并且执行[[Prototype]]链接</span><br><span class="line">    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&apos;object&apos;所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === &apos;function&apos;;</span><br><span class="line">    if(isObject || isFunction)&#123;</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后用模拟实现的<code>newOperator</code>函数验证下之前的<strong>例子3</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 例子3 多加一个参数</span><br><span class="line">function Student(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    // this.doSth();</span><br><span class="line">    // return Error();</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.doSth = function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var student1 = newOperator(Student, &apos;轩辕&apos;, 18);</span><br><span class="line">var student2 = newOperator(Student, &apos;Rowboat&apos;, 18);</span><br><span class="line">// var student1 = new Student(&apos;轩辕&apos;);</span><br><span class="line">// var student2 = new Student(&apos;Rowboat&apos;);</span><br><span class="line">console.log(student1, student1.doSth()); // &#123;name: &apos;轩辕&apos;&#125; &apos;轩辕&apos;</span><br><span class="line">console.log(student2, student2.doSth()); // &#123;name: &apos;Rowboat&apos;&#125; &apos;Rowboat&apos;</span><br><span class="line"></span><br><span class="line">student1.__proto__ === Student.prototype; // true</span><br><span class="line">student2.__proto__ === Student.prototype; // true</span><br><span class="line">// __proto__ 是浏览器实现的查看原型方案。</span><br><span class="line">// 用ES5 则是：</span><br><span class="line">Object.getPrototypeOf(student1) === Student.prototype; // true</span><br><span class="line">Object.getPrototypeOf(student2) === Student.prototype; // true</span><br></pre></td></tr></table></figure></p><p>可以看出，很符合<code>new</code>操作符。读者发现有不妥或可改善之处，欢迎指出。<br>回顾这个模拟<code>new</code>函数<code>newOperator</code>实现，最大的功臣当属于<code>Object.create()</code>这个<code>ES5</code>提供的<code>API</code>。</p><h2 id="Object-create-用法举例"><a href="#Object-create-用法举例" class="headerlink" title="Object.create() 用法举例"></a>Object.create() 用法举例</h2><p>笔者之前整理的一篇文章中也有讲过，可以翻看<a href="https://segmentfault.com/a/1190000010753942" target="_blank" rel="noopener">JavaScript 对象所有API解析</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN Object.create()</a></p><p><code>Object.create(proto, [propertiesObject])</code><br>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是<code>undefined</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var anotherObject = &#123;</span><br><span class="line">    name: &apos;轩辕Rowboat&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var myObject = Object.create(anotherObject, &#123;</span><br><span class="line">    age: &#123;</span><br><span class="line">        value：18,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 获得它的原型</span><br><span class="line">Object.getPrototypeOf(anotherObject) === Object.prototype; // true 说明anotherObject的原型是Object.prototype</span><br><span class="line">Object.getPrototypeOf(myObject); // &#123;name: &quot;轩辕Rowboat&quot;&#125; // 说明myObject的原型是&#123;name: &quot;轩辕Rowboat&quot;&#125;</span><br><span class="line">myObject.hasOwnProperty(&apos;name&apos;); // false; 说明name是原型上的。</span><br><span class="line">myObject.hasOwnProperty(&apos;age&apos;); // true 说明age是自身的</span><br><span class="line">myObject.name; // &apos;轩辕Rowboat&apos;</span><br><span class="line">myObject.age; // 18;</span><br></pre></td></tr></table></figure><p>对于不支持<code>ES5</code>的浏览器，<code>MDN</code>上提供了<code>ployfill</code>方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.create !== &quot;function&quot;) &#123;</span><br><span class="line">    Object.create = function (proto, propertiesObject) &#123;</span><br><span class="line">        if (typeof proto !== &apos;object&apos; &amp;&amp; typeof proto !== &apos;function&apos;) &#123;</span><br><span class="line">            throw new TypeError(&apos;Object prototype may only be an Object: &apos; + proto);</span><br><span class="line">        &#125; else if (proto === null) &#123;</span><br><span class="line">            throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support &apos;null&apos; as the first argument.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeof propertiesObject != &apos;undefined&apos;) throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support a second argument.&quot;);</span><br><span class="line"></span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line"></span><br><span class="line">        return new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，文章就基本写完了。感谢读者看到这里。</p><h2 id="最后总结一下："><a href="#最后总结一下：" class="headerlink" title="最后总结一下："></a>最后总结一下：</h2><p>1.<code>new</code>做了什么：</p><blockquote><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol></blockquote><p>2.怎么模拟实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 去除了注释</span><br><span class="line">function newOperator(ctor)&#123;</span><br><span class="line">    if(typeof ctor !== &apos;function&apos;)&#123;</span><br><span class="line">      throw &apos;newOperator function the first param must be a function&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === &apos;function&apos;;</span><br><span class="line">    if(isObject || isFunction)&#123;</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用过&lt;code&gt;Vuejs&lt;/code&gt;的同学都知道，需要用&lt;code&gt;new&lt;/code&gt;操作符来实例化。&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
      <category term="面试" scheme="https://lxchuan12.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并</title>
    <link href="https://lxchuan12.github.io/posts/d3549292.html"/>
    <id>https://lxchuan12.github.io/posts/d3549292.html</id>
    <published>2018-08-29T12:05:13.000Z</published>
    <updated>2019-02-10T14:29:24.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、puppeteer-是什么？"><a href="#1、puppeteer-是什么？" class="headerlink" title="1、puppeteer 是什么？"></a>1、<code>puppeteer</code> 是什么？</h3><p><code>puppeteer</code>: <code>Google</code> 官方出品的 <code>headless</code> <code>Chrome</code> <code>node</code> 库<br><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener"><code>puppeteer</code> <code>github</code>仓库</a><br><a href="https://pptr.dev/" target="_blank" rel="noopener"><code>puppeteer</code> <code>API</code></a></p><p><strong>官方介绍：</strong></p><blockquote><p>您可以在浏览器中手动执行的大多数操作都可以使用<code>Puppeteer</code>完成！</p></blockquote><p>生成页面的屏幕截图和<code>PDF</code>。<br>抓取<code>SPA</code>并生成预渲染内容（即“<code>SSR</code>”）。<br>自动化表单提交，<code>UI</code>测试，键盘输入等。<br>创建最新的自动化测试环境。使用最新的<code>JavaScript</code>和浏览器功能直接在最新版本的<code>Chrome</code>中运行测试。<br>捕获时间线跟踪 您的网站，以帮助诊断性能问题。<br>测试<code>Chrome</code>扩展程序。</p><h3 id="2、爬取网站生成PDF"><a href="#2、爬取网站生成PDF" class="headerlink" title="2、爬取网站生成PDF"></a>2、爬取网站生成<code>PDF</code></h3><h4 id="2-1-安装-puppeteer"><a href="#2-1-安装-puppeteer" class="headerlink" title="2.1 安装 puppeteer"></a>2.1 安装 puppeteer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装 puppeteer</span><br><span class="line">// 可能会因为网络原因安装失败，可使用淘宝镜像 </span><br><span class="line">// npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm i puppeteer</span><br><span class="line"># or &quot;yarn add puppeteer&quot;</span><br></pre></td></tr></table></figure><h4 id="2-2-《React-js小书》简介"><a href="#2-2-《React-js小书》简介" class="headerlink" title="2.2 《React.js小书》简介"></a>2.2 《<code>React.js</code>小书》简介</h4><blockquote><p>《<code>React.js</code>小书》简介<br><a href="http://huziketang.mangojuice.top/books/react/me/" target="_blank" rel="noopener">关于作者@胡子大哈</a><br>这是⼀本关于 React.js 的⼩书。<br>因为⼯作中⼀直在使⽤ <code>React.js</code>，也⼀直以来想总结⼀下⾃⼰关于 <code>React.js</code> 的⼀些<br>知识、经验。于是把⼀些想法慢慢整理书写下来，做成⼀本<strong>开源、免费、专业、简单</strong><br>的⼊⻔级别的⼩书，提供给社区。希望能够帮助到更多 <code>React.js</code> 刚⼊⻔朋友。<br>下图是《<code>React.js</code> 小书》部分截图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-c0fd9a9381674965?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《`React.js` 小书》部分截图" title="">                </div>                <div class="image-caption">《`React.js` 小书》部分截图</div>            </figure></p></blockquote><h4 id="2-3-一些可能会用到的-puppeteer-API"><a href="#2-3-一些可能会用到的-puppeteer-API" class="headerlink" title="2.3 一些可能会用到的 puppeteer API"></a>2.3 一些可能会用到的 <code>puppeteer API</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 新建 reactMiniBook.js, 运行 node reactMiniBook.js 生成pdf</span><br><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  // 启动浏览器</span><br><span class="line">  const browser = await puppeteer.launch(&#123;</span><br><span class="line">        // 无界面 默认为true,改成false,则可以看到浏览器操作，目前生成pdf只支持无界面的操作。</span><br><span class="line">        // headless: false,</span><br><span class="line">        // 开启开发者调试模式，默认false, 也就是平时F12打开的面版</span><br><span class="line">// devtools: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  // 打开一个标签页</span><br><span class="line">  const page = await browser.newPage();</span><br><span class="line">  // 跳转到页面 http://huziketang.mangojuice.top/books/react/</span><br><span class="line">  await page.goto(&apos;http://huziketang.com/books/react/&apos;, &#123;waitUntil: &apos;networkidle2&apos;&#125;);</span><br><span class="line">  // path 路径， format 生成pdf页面格式</span><br><span class="line">  await page.pdf(&#123;path: &apos;react.pdf&apos;, format: &apos;A4&apos;&#125;);</span><br><span class="line">  // 关闭浏览器</span><br><span class="line">  await browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>知道这启动浏览器打开页面关闭浏览器主流程后，再来看几个<code>API</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const args = 1;</span><br><span class="line">let wh = await page.evaluate((args) =&gt; &#123;</span><br><span class="line">    // args 可以这样传递给这个函数。</span><br><span class="line">    // 类似于 setTimeout(() =&gt; &#123;console.log(args);&#125;, 3000, args);</span><br><span class="line">    console.log(&apos;args&apos;, args); // 1</span><br><span class="line">    // 这里可以运行 dom操作等js</span><br><span class="line">    // 返回通过dom操作等获取到的数据</span><br><span class="line">    return &#123;</span><br><span class="line">        width: 1920,</span><br><span class="line">        height: document.body.clientHeight,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, args);</span><br><span class="line">// 设置视图大小</span><br><span class="line">await page.setViewport(wh);</span><br><span class="line">// 等待2s</span><br><span class="line">await page.waitFor(2000);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以iPhone X执行。</span><br><span class="line">const devices = require(&apos;puppeteer/DeviceDescriptors&apos;);</span><br><span class="line">const iPhone = devices[&apos;iPhone X&apos;];</span><br><span class="line">await page.emulate(iPhone);</span><br></pre></td></tr></table></figure><h4 id="2-4-知道了以上这些API后，就可以开始写主程序了。"><a href="#2-4-知道了以上这些API后，就可以开始写主程序了。" class="headerlink" title="2.4 知道了以上这些API后，就可以开始写主程序了。"></a>2.4 知道了以上这些<code>API</code>后，就可以开始写主程序了。</h4><p>简单说下：实现功能和主流程。从上面<code>React.js小书</code>截图来看。<br>1、打开浏览器，进入目录页，生成<code>0. React 小书 目录.pdf</code><br>2、跳转到<code>1. React.js 简介</code>页面，获取左侧所有的导航<code>a</code>链接的<code>href</code>,标题。<br>3、用获取到的<code>a链接数组</code>进行<code>for</code>循环，这个循环里主要做了如下几件事：</p><blockquote><p>  3.1 隐藏左侧导航，便于生成<code>pdf</code><br>  3.2 给<strong><code>React.js简介</code></strong>等标题 加上序号，便于查看<br>  3.3 设置<code>docment.title</code> 加上序号, 便于在页眉中使用。<br>  3.4 隐藏 <strong>传播一下知识也是一个很好的选择</strong> 这一个模块（因为页眉页脚中设置了书的链接等信息，就隐藏这个了）<br>  3.5 给 分页 上一节，下一节加上序号，便于查看。<br>  3.6 最末尾声明下该<code>pdf</code>的说明，仅供学习交流，严禁用于商业用途。<br>  3.7 返回宽高，用于设置视图大小<br>  3.8 设置视图大小，创建生成<code>pdf</code></p></blockquote><p>4、关闭浏览器</p><p>具体代码：可以查看这里<a href="https://github.com/lxchuan12/learn-nodejs/blob/master/src/puppeteer/reactMiniBook.js" target="_blank" rel="noopener">爬虫生成《React.js小书》的<code>pdf</code>每一小节的代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// node 执行这个文件</span><br><span class="line">// 笔者这里是：</span><br><span class="line">node src/puppeteer/reactMiniBook.js</span><br></pre></td></tr></table></figure><p>即可生成如下图：每一小节（0-46小节）的<code>pdf</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/201107-3366d1365aab266b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每一小节（0-46小节）的`pdf`" title="">                </div>                <div class="image-caption">每一小节（0-46小节）的`pdf`</div>            </figure><p>生成这些后，那么问题来了，就是查看时总不能看一小节，打开一小节来看，这样很不方便。<br>于是接下来就是合并这些<code>pdf</code>成为一个<code>pdf</code>文件。</p><h3 id="3、合并成一个PDF文件-pdf-merge"><a href="#3、合并成一个PDF文件-pdf-merge" class="headerlink" title="3、合并成一个PDF文件 pdf-merge"></a>3、合并成一个PDF文件 <code>pdf-merge</code></h3><p>起初，我是使用在线网站<a href="https://smallpdf.com/cn" target="_blank" rel="noopener">Smallpdf</a>，合并<code>PDF</code>。合并的效果还是很不错的。这网站还是其他功能。比如<code>word</code>转<code>pdf</code>等。<br>后来找到社区提供的一个<code>npm</code> <code>package</code><a href="https://github.com/wubzz/pdf-merge" target="_blank" rel="noopener">pdf merge</a>。 (毕竟笔者是写程序的，所以就用代码来实现合并了)</p><p>这个<code>pdf-merge</code>依赖 <a href="https://www.pdflabs.com/docs/pdftk-man-page/" target="_blank" rel="noopener">pdftk</a></p><p><strong>安装 PDFtk</strong><br><strong>Windows</strong><br><a href="https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/" target="_blank" rel="noopener">下载并安装</a><br>笔者安装后，重启电脑才能使用。</p><p><strong>Debian, Ubuntu 安装</strong><br>笔者在Ubuntu系统安装后，即可使用。<br><code>apt-get install pdftk</code></p><p><strong>使用例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const PDFMerge = require(&apos;pdf-merge&apos;);</span><br><span class="line"></span><br><span class="line">const files = [</span><br><span class="line">`$&#123;__dirname&#125;/1.pdf`,</span><br><span class="line">`$&#123;__dirname&#125;/2.pdf`,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// Buffer (Default)</span><br><span class="line">PDFMerge(files)</span><br><span class="line">.then((buffer) =&gt; &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">// Stream</span><br><span class="line">PDFMerge(files, &#123;output: &apos;Stream&apos;&#125;)</span><br><span class="line">.then((stream) =&gt; &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">// 笔者这里使用的是这个</span><br><span class="line">// Save as new file</span><br><span class="line">PDFMerge(files, &#123;output: `$&#123;__dirname&#125;/3.pdf`&#125;)</span><br><span class="line">.then((buffer) =&gt; &#123;...&#125;);</span><br></pre></td></tr></table></figure></p><p>知道这些后，可以开始写主程序了。<br>简单说下主流程<br>1、读取到生成的所有<code>pdf</code>文件路径，并排序（0-46）<br>2、判断下输出文件夹是否存在，不存在则创建<br>3、合并这些小节的<code>pdf</code>保存到新文件 <code>React小书（完整版）-作者：胡子大哈-时间戳.pdf</code></p><p>具体代码：可以查看这里<a href="https://github.com/lxchuan12/learn-nodejs/blob/master/src/puppeteer/mergePdf.js" target="_blank" rel="noopener">爬虫生成《React.js小书》的<code>pdf</code>合并<code>pdf</code>的代码</a></p><p>最终合并的<code>pdf</code>文件在这里<a href="https://github.com/lxchuan12/learn-nodejs/blob/master/src/puppeteer/reactMiniBookMerged/React%E5%B0%8F%E4%B9%A6%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89-%E4%BD%9C%E8%80%85%EF%BC%9A%E8%83%A1%E5%AD%90%E5%A4%A7%E5%93%88-1535335084919.pdf" target="_blank" rel="noopener">React小书（完整版）-作者：胡子大哈</a>，可供下载。</p><p>本想着还可以加下书签和页码，没找到合适的生成方案，那暂时先不加了。如果读者有好的方案，欢迎与笔者交流。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、<code>puppeteer</code>是<code>Google</code> 官方出品的 <code>headless</code> <code>Chrome</code> <code>node</code> 库，可以在浏览器中手动执行的大多数操作都可以使用<code>Puppeteer</code>完成。总之可以用来做很多有趣的事情。<br>2、用 <code>puppeteer</code> 生成每一小节的<code>pdf</code>，用依赖<code>pdftk</code>的<code>pdf-merge</code> <code>npm</code>包, 合并成一个新的<code>pdf</code>文件。或者使用<a href="https://smallpdf.com/cn" target="_blank" rel="noopener">Smallpdf</a>等网站合并。<br>3、《<code>React.js</code>小书》，推荐给大家。爬虫生成<code>pdf</code>，应该不会对<a href="http://huziketang.mangojuice.top/books/react/me/" target="_blank" rel="noopener">作者@胡子大哈</a>有什么影响。</p><p>最后推荐几个链接，方便大家学习 <code>puppeteer</code>。<br><a href="http://www.r9it.com/20171106/puppeteer.html" target="_blank" rel="noopener">puppeteer入门教程</a><br><a href="https://cloud.tencent.com/developer/article/1006000" target="_blank" rel="noopener">Puppeteer 初探之前端自动化测试</a><br><a href="https://github.com/zhentaoo/puppeteer-deep" target="_blank" rel="noopener">爬虫生成ES6标准入门 pdf</a><br><a href="https://jeffjade.com/2017/12/17/134-kinds-of-toss-using-puppeteer/" target="_blank" rel="noopener">大前端神器安利之 Puppeteer</a><br><a href="https://github.com/zhaoqize/puppeteer-api-zh_CN/" target="_blank" rel="noopener">puppeteer API中文文档</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、puppeteer-是什么？&quot;&gt;&lt;a href=&quot;#1、puppeteer-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、puppeteer 是什么？&quot;&gt;&lt;/a&gt;1、&lt;code&gt;puppeteer&lt;/code&gt; 是什么？&lt;/h3&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="node" scheme="https://lxchuan12.github.io/categories/node/"/>
    
    
      <category term="chrome" scheme="https://lxchuan12.github.io/tags/chrome/"/>
    
      <category term="爬虫" scheme="https://lxchuan12.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="pdf" scheme="https://lxchuan12.github.io/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>win10 安装 oh my zsh 和 window git bash 设置别名提高效率</title>
    <link href="https://lxchuan12.github.io/posts/1d41de3f.html"/>
    <id>https://lxchuan12.github.io/posts/1d41de3f.html</id>
    <published>2018-07-28T06:51:53.000Z</published>
    <updated>2019-02-10T14:29:24.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 <code>oh my zsh</code></h3><p>公司使用<code>Ubuntu</code>系统。自己安装了 <code>oh my zsh</code><a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh my zsh官网</a>。这里简述下安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">// /bin/bash 默认是bash</span><br><span class="line">// 查看下有哪些shells</span><br><span class="line">cat /etc/shells</span><br><span class="line">// # /etc/shells: valid login shells</span><br><span class="line">// /bin/sh</span><br><span class="line">// /bin/bash</span><br><span class="line">// /bin/rbash</span><br><span class="line">// /bin/dash</span><br><span class="line">// /usr/bin/tmux</span><br><span class="line">// /usr/bin/screen</span><br><span class="line">// /bin/zsh</span><br><span class="line">// /usr/bin/zsh</span><br><span class="line">sudo apt-get install zsh</span><br><span class="line">zsh --version</span><br><span class="line">// 5.1.1</span><br><span class="line">// 安装后zsh 后cat /etc/shells 才有/bin/zsh /usr/bin/zsh</span><br><span class="line"></span><br><span class="line">// 切换成zsh</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 两种安装方案可供选择：</span><br><span class="line">// Via curl</span><br><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">// Via Wget</span><br><span class="line">$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><p>安装成功后，配置信息会在<code>~/.zshrc</code>。可以通过<code>vim ~/.zshrc</code>打开编辑<code>zsh</code>配置信息，可以看到默认配置了<code>git</code> 插件<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">Plugin:git</a>。<br>也就是说，可以更加简便的使用<code>git</code> 相关的一些别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比如</span><br><span class="line">`git status`时，只需要输入`gst`。</span><br><span class="line">`git pull` 时，只需要输入`gl`。</span><br><span class="line">`git push 时，只需要输入`gp`等等。</span><br></pre></td></tr></table></figure></p><p>是因为配置里有这些简写，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">oh my zsh plugin git.plugin.zsh</a>。<br>安装成功后，同时会创建<code>~/.oh-my-zsh</code>的文件夹，其实就是<code>.oh-my-zsh</code> 的 <code>git</code> 仓库<code>master</code>分支。<br>可以发现文件夹中有一个<code>plugins</code>文件夹，内置了很多插件。可以自定义主题<code>theme</code>，具体可以看<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/themes/example.zsh-theme" target="_blank" rel="noopener">example.zsh-theme</a>。<br><code>custom</code>自定义相关。<br>插件相关会安装在这里，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/custom/plugins/example/example.plugin.zsh" target="_blank" rel="noopener">更多可以查看example.plugin.zsh</a></p><p>我暂时安装了这几个插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  // 内置插件，启用即可</span><br><span class="line">  git</span><br><span class="line">  cp</span><br><span class="line">  mv</span><br><span class="line">  // 按两下esc键，用sudo权限</span><br><span class="line">  sudo</span><br><span class="line">  // 记录历史输入的zsh命令，自动提示，快速使用</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  // zsh 命令高亮</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>顺带讲下后面两个插件的安装方法<br>安装 <code>zsh-autosuggestions</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></p><p>安装<code>zsh-syntax-highlighting</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p><p><code>$ZSH_CUSTOM</code> 其实是个变量，代表这个路径<code>~/.oh-my-zsh/custom</code>，<br>也就是安装到了这个目录下。还有很多高效插件，等您发掘~<a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh my zsh官网</a><br>不过插件安装多了，感觉会有些卡顿~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 每次修改了这个`.zshrc`配置文件，需要重载一下，才能生效。</span><br><span class="line">source .zshrc</span><br><span class="line">// 也可以封装成一个简写命令 alias</span><br><span class="line">alias rl=&apos;source ~/.zshrc&apos;</span><br></pre></td></tr></table></figure></p><p>也可以在这个配置文件中配置更多<code>alias</code>。<br><code>oh my zsh</code>命令工具确实好用，但还没买<code>mac</code>，又不想用<code>ubuntu</code>的童鞋怎么办呢~<br><code>win10</code> 支持安装<code>ubuntu</code>等子系统，就可以安装<code>oh my zsh</code>, 学习<code>linux</code>了。</p><h3 id="windows-10-安装-Ubuntu-子系统，安装oh-my-zsh"><a href="#windows-10-安装-Ubuntu-子系统，安装oh-my-zsh" class="headerlink" title="windows 10 安装 Ubuntu 子系统，安装oh my zsh"></a><code>windows 10</code> 安装 <code>Ubuntu</code> 子系统，安装<code>oh my zsh</code></h3><p>之前偶然发现自己电脑<code>windows 10</code> 有类似<code>linux</code> 功能（虽然这功能之前就有印象，但没去研究），这里有篇简短介绍文章：<a href="https://www.iplaysoft.com/ubuntu-for-windows10.html" target="_blank" rel="noopener">微软官方 Ubuntu for Win10 版免费 Linux 子系统下载！一键安装运行超简单</a></p><p>竟然也可以安装<code>oh my zsh</code><a href="http://ohmyz.sh/" target="_blank" rel="noopener">官网</a>。想学习 <code>linux</code> 又不想安装 <code>linux</code> 系统，这时候可以用<code>win10</code>自带的<code>Ubuntu</code>。<br>发现这篇写的比较详细，笔者就不再赘述了。<br>笔者安装<code>ubuntu 18.04</code>子系统后，文件目录在这个路径下。<code>C:\Users\lxchuan12\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs</code><br><a href="https://blog.csdn.net/sko121/article/details/78091083" target="_blank" rel="noopener">Win10 环境下安装配置 zsh</a></p><p><code>win10</code>安装了<code>ubuntu</code>子系统和<code>oh my zsh</code>后，则可以通过<code>/mnt/f/</code>访问<code>win10</code>下的<code>f</code>盘，或者其他盘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比如跳转到工作目录</span><br><span class="line">alias dgg=&apos;cd /mnt/f/git-source/github&apos;</span><br><span class="line">// vscode 打开要编辑的文件或文件夹</span><br><span class="line">code sticky-notes</span><br></pre></td></tr></table></figure></p><p>也就是相当于<code>win10</code>下解锁了<code>oh my zsh</code>。<br>那不是<code>win10</code>，也想通过设置别名来提高效率，是不是就没有办法了呢，可以使用<code>git bash</code>设置<code>alias</code>，安装<code>git</code>，自带<code>git bash</code>。</p><h3 id="windows-git-bash-设置别名提高效率"><a href="#windows-git-bash-设置别名提高效率" class="headerlink" title="windows git bash 设置别名提高效率"></a><code>windows</code> <code>git bash</code> 设置别名提高效率</h3><p><code>windows</code> 桌面或任意资源管理器位置，右击，选择<code>Git Bash Here</code>，即打开了<code>git bash</code>命令行。<br>先设置下主题，右击选择<code>options</code>, <code>Looks &gt; theme &gt; dracula</code><br>我选择的是<code>dracula</code>主题，看起来比较舒适。还可以设置字体等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 跳转到根路径</span><br><span class="line">cd ~</span><br><span class="line">// 查看下是否有.bash_profile文件</span><br><span class="line">la</span><br><span class="line">// 如果没有.bash_profile文件，需要创建</span><br><span class="line">touch .bash_profile</span><br><span class="line">// 打开编辑 （笔者这里安装了vscode，所以直接用其打开文件）</span><br><span class="line">code .bash_profile</span><br></pre></td></tr></table></figure></p><p>可以根据修改设置一些别名。<br>比如我们常用的<code>git status</code>命令，可以封装成<code>gst</code>。清屏<code>clear</code>命令封装成<code>cls</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias gst=&apos;git status&apos;</span><br><span class="line">alias cls=&apos;clear&apos;</span><br></pre></td></tr></table></figure></p><p>每次修改这个文件需要输入<code>source ~/.bash_profile</code>重载这个文件，才会生效。<br><code>code ~/.bash_profile</code>，用<code>vscode</code>编辑这个配置文件，封装成一个命令。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias rl=&apos;source ~/.bash_profile&apos;</span><br><span class="line">alias bashconfig=&apos;code ~/.bash_profile&apos;</span><br></pre></td></tr></table></figure></p><p>这样每次修改保存后就只需要输入<code>rl</code>，即可重载生效了。<br>还可以把一些工作目录封装，笔者的一些项目是放在<code>/f/git-source/github</code>文件下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// github上的项目</span><br><span class="line">alias dgg=&apos;cd F:/git-source/github&apos;</span><br><span class="line">// 周报相关</span><br><span class="line">alias dcwk=&apos;cd F:/git-source/coding/weekly&apos;</span><br></pre></td></tr></table></figure></p><p>每次进入项目，就直接<code>dgg</code>，即可跳转到这个目录，然后选择相应的目录即可。<br>比如<code>dgg</code>进入工作目录，<code>cd analyse-vue-cli</code>进入项目目录,（输入<code>anal</code>按<code>tab</code>键智能提示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  /f/git-source/github/analyse-vue-cli (dev)</span><br><span class="line">// 查看状态 git status</span><br><span class="line">gst</span><br><span class="line">// 用vscode 打开这个文件夹，开始编辑~</span><br><span class="line">code ./</span><br></pre></td></tr></table></figure></p><p>git 相关的，<br>例举一些平时用的比较多的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias g=&apos;git&apos;</span><br><span class="line">alias ga=&apos;git add&apos;</span><br><span class="line">alias gaa=&apos;git add -all&apos;</span><br><span class="line">alias gp=&apos;git push&apos;</span><br><span class="line">alias gl=&apos;git pull&apos;</span><br><span class="line">alias gcmsg=&apos;git commit -m&apos;</span><br><span class="line">// 分支相关</span><br><span class="line">alias gb=&apos;git branch&apos;</span><br><span class="line">alias gbr=&apos;git branch -r&apos;</span><br><span class="line">alias gba=&apos;git branch -a&apos;</span><br><span class="line">// checkout</span><br><span class="line">alias gco=&apos;git checkout&apos;</span><br><span class="line">alias gcb=&apos;git checkout -b&apos;</span><br><span class="line">// merge</span><br><span class="line">alias gm=&apos;git merge&apos;</span><br><span class="line">// diff</span><br><span class="line">alias gd=&apos;git diff&apos;</span><br><span class="line">alias gdw=&apos;git diff --word-diff&apos;</span><br></pre></td></tr></table></figure></p><p>更多可以把<code>oh my zsh</code>的插件一些命令拷贝过来，留<code>alias</code>相关的即可，<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">oh my zsh plugin git.plugin.zsh</a><br><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">Plugin:git wiki</a><br>相当于解锁了<code>oh my zsh</code> 的<code>git</code>插件。还有很多插件，比如<code>npm</code><a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/npm/npm.plugin.zsh" target="_blank" rel="noopener">点击查看</a>, <code>node 等</code>，都可以研究下。</p><p><code>git bash</code>，有没有类似<code>oh my zsh</code>的插件呢，笔者暂时没发现，如果您知道，欢迎告诉笔者。<br>目录相关的操作，也可以设置一些别名。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 回退到上一级</span><br><span class="line">alias ..=&apos;cd ..&apos;</span><br><span class="line">alias ...=&apos;cd ../..&apos;</span><br><span class="line">alias ....=&apos;cd ../../..&apos;</span><br><span class="line">alias .....=&apos;cd ../../../..&apos;</span><br><span class="line">alias ......=&apos;cd ../../../../..&apos;</span><br></pre></td></tr></table></figure></p><p>更多别名可以自定义～<br><code>windows</code>上命令行工具还可以使用<code>cmder</code><a href="http://cmder.net/" target="_blank" rel="noopener">点击查看cmder官网</a>命令行工具。虽然笔者几年前就安装了，但发现还是<code>git bash</code>用的顺畅些，可能是我还不太习惯<code>cmder</code>。<br>关于<code>cmder</code>配置相关，这里推荐晚晴幽草轩轩主的一篇文章：<br><a href="https://jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">《Win下必备神器之Cmder》</a></p><p>也有<a href="http://www.cygwin.com/" target="_blank" rel="noopener">cygwin</a>，也是<code>windows</code>命令行工具，也可以安装<code>on my zsh</code>。</p><p>当然，<code>git</code>也是可以设置别名的。</p><h3 id="git设置别名，使用tig神器"><a href="#git设置别名，使用tig神器" class="headerlink" title="git设置别名，使用tig神器"></a><code>git</code>设置别名，使用<code>tig</code>神器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// git status =&gt; git st</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><p>更多可以查看廖雪峰老师的这篇文章<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000" target="_blank" rel="noopener">git 配置别名</a>。不过可能大多数人不知道，他们可能用着可视化工具。笔者觉得可视化工具也是对<code>git</code>的一些封装，具体背后是什么命令，我们还是需要去了解熟悉的。命令行使用<code>git</code>，笔者推荐使用<code>tig</code>。<code>git log</code>增强版，性能很好。<code>Ubuntu</code>、<code>linux</code>、<code>mac</code>可以直接安装，<code>windows</code>稍微麻烦些。具体安装方法查看<a href="https://github.com/jonas/tig/blob/master/INSTALL.adoc" target="_blank" rel="noopener">tig github仓库中的官方安装文档</a>，或者查看这篇文章：<a href="https://www.jianshu.com/p/e4ca3030a9d5" target="_blank" rel="noopener">颠覆 Git 命令使用体验的神器 – tig</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>磨刀不误砍柴工，花时间折腾研究工具，有利于提高开发效率。</p><p>最新更新于 <code>2018-07-28 14:46:08</code></p><p>文章首发于<code>segmentfault</code> <a href="https://segmentfault.com/a/1190000015155864" target="_blank" rel="noopener">win10 安装 oh my zsh 和 windows git bash 设置别名提高效率</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装-oh-my-zsh&quot;&gt;&lt;a href=&quot;#安装-oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;安装 oh my zsh&quot;&gt;&lt;/a&gt;安装 &lt;code&gt;oh my zsh&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;公司使用&lt;code&gt;Ubuntu&lt;
      
    
    </summary>
    
      <category term="tool" scheme="https://lxchuan12.github.io/categories/tool/"/>
    
    
      <category term="git" scheme="https://lxchuan12.github.io/tags/git/"/>
    
      <category term="tool" scheme="https://lxchuan12.github.io/tags/tool/"/>
    
      <category term="zsh" scheme="https://lxchuan12.github.io/tags/zsh/"/>
    
      <category term="oh my zsh" scheme="https://lxchuan12.github.io/tags/oh-my-zsh/"/>
    
      <category term="git bash" scheme="https://lxchuan12.github.io/tags/git-bash/"/>
    
      <category term="ubuntu" scheme="https://lxchuan12.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>分享百度网盘下载搜索神器和一些实用浏览器插件</title>
    <link href="https://lxchuan12.github.io/posts/d214de5b.html"/>
    <id>https://lxchuan12.github.io/posts/d214de5b.html</id>
    <published>2018-07-14T14:42:50.000Z</published>
    <updated>2019-02-10T14:29:24.505Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间（端午节期间）折腾电脑，用虚拟机安装<code>mac 10.13</code>，但安装包太大，6.5G。<br>顺便放下我安装时参考的链接，说不定有人也想安装<code>mac</code>试试，不过我试验的是安装后比较卡。<a href="https://blog.csdn.net/icarus666/article/details/79536388" target="_blank" rel="noopener">验证在vm12下安装os 10.13的可行性（同适用 os 10.12.6）</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-17c2d7e071a258b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟机安装`mac`后截图.png" title="">                </div>                <div class="image-caption">虚拟机安装`mac`后截图.png</div>            </figure></p><p>文件在百度网盘中，但大家都知道百度云管家下载限制下载速度，按照限制的下载速度，不知道要下载到猴年马月。</p><h3 id="Proxyee-down-百度网盘下载神器"><a href="#Proxyee-down-百度网盘下载神器" class="headerlink" title="Proxyee-down 百度网盘下载神器"></a><code>Proxyee-down</code> 百度网盘下载神器</h3><p>于是我发现了一款百度网盘下载神器【<code>Proxyee-down</code>】（支持<code>Win/Mac/Linux</code>的百度云文件下载工具），据说下载速度不止2M/s，可以跑到20M/s。当然也跟所在网络环境有关。总之要比官方百度云管家下载速度要快。<br><a href="https://pan.lanzou.com/b203390" target="_blank" rel="noopener">下载地址（根据不同系统安装不同版本）</a><br>项目开源，安装教程等相关都可以在这个链接里找到。我就不附图了。<br><a href="https://github.com/proxyee-down-org/proxyee-down" target="_blank" rel="noopener"><code>proxyee-down</code>项目地址</a></p><h3 id="云盘万能钥匙-插件"><a href="#云盘万能钥匙-插件" class="headerlink" title="云盘万能钥匙 插件"></a>云盘万能钥匙 插件</h3><p>既然推荐了百度网盘下载工具，那就再推荐 云盘万能钥匙这个插件。<br><a href="http://www.ypsuperkey.com/" target="_blank" rel="noopener">云盘万能钥匙官网</a><br><a href="https://chrome.google.com/webstore/detail/%E4%BA%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/anlllmnpjodopgbkbpnghnjlelnogfjc?hl=zh-CN" target="_blank" rel="noopener">谷歌应用商店安装地址</a><br>官方是这样推荐的。<br>1.自动识别并填写提取密码，懒癌患者的福音<br>2.每当点击一个分享链接，却提示我分享已失效时，我的内心是崩溃的<br>3.尊重个人隐私<br>可以根据不同浏览器下载安装不同版本插件。不科学上网也可以下载安装。如何科学上网就自行百度研究了。简要推荐一个插件<code>skyZIP-Proxy</code>。<br><a href="http://www.ypsuperkey.com/helps/add-ypsuperkey-to-chrome" target="_blank" rel="noopener">在谷歌浏览器中离线安装、卸载和更新云盘万能钥匙</a></p><p>可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何离线安装可以参看这篇文章<a href="https://www.jianshu.com/p/12ca04c61fc6" target="_blank" rel="noopener">如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？</a>，也可以参看上文推荐【在谷歌浏览器中安装、卸载和更新云盘万能钥匙】文章。<br>不过还是简单说下离线安装步骤：把下载下<code>YPSuperKey-For-Chrome-Only.crx</code>文件，（如果没有扩展名，那设置显示）改成<code>YPSuperKey-For-Chrome-Only.zip</code>，然后用好压等工具解压出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-3722a404430cafce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YPSuperKey-For-Chrome-Only文件夹.png" title="">                </div>                <div class="image-caption">YPSuperKey-For-Chrome-Only文件夹.png</div>            </figure></p><p>打开<code>chrome</code>浏览器，按图所示，依次打开【更多工具】 -  【扩展程序】 - 勾选【开发者模式】【加载已解压的扩展程序】，选择刚刚的文件夹，安装这个插件成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-589dca8f83258f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="【更多工具】 -  【扩展程序】.png" title="">                </div>                <div class="image-caption">【更多工具】 -  【扩展程序】.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-29cf1303be96d7a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开发模式 - 加载已解压的扩展程序.png" title="">                </div>                <div class="image-caption">开发模式 - 加载已解压的扩展程序.png</div>            </figure></p><h3 id="ghostery-隐私广告拦截工具-插件"><a href="#ghostery-隐私广告拦截工具-插件" class="headerlink" title="ghostery 隐私广告拦截工具 插件"></a><code>ghostery</code> 隐私广告拦截工具 插件</h3><p>说到隐私，推荐这个插件，能够屏蔽网站统计收集用户信息。<br><a href="https://chrome.google.com/webstore/detail/ghostery-%E2%80%93-privacy-ad-blo/mlomiejdfkolichcflejclcbmpeaniij" target="_blank" rel="noopener">应用商店下载安装</a></p><h3 id="二维码生成-插件"><a href="#二维码生成-插件" class="headerlink" title="二维码生成 插件"></a>二维码生成 插件</h3><p>有时需要手机上访问电脑浏览器上某个地址，直接输入太长，不现实。这时候这个插件就很有用了。<br><a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="云盘精灵，一个更好的网盘搜索引擎"><a href="#云盘精灵，一个更好的网盘搜索引擎" class="headerlink" title="云盘精灵，一个更好的网盘搜索引擎"></a>云盘精灵，一个更好的网盘搜索引擎</h3><p><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵官网</a> 这网站有时需要科学上网访问。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/201107-913aa1fc467b15c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索罗小川chuan的结果，之前写的文章配套资源.png" title="">                </div>                <div class="image-caption">搜索罗小川chuan的结果，之前写的文章配套资源.png</div>            </figure></p><p>官方是这样推荐的。</p><ol><li>基于【云盘万能钥匙】收录的海量数据</li><li>支持搜索带提取密码的分享资源</li><li>资源链接失效时立即移除出搜索数据库</li><li>简洁清新的界面设计（没有低俗的广告）</li></ol><h3 id="adblock-plus-屏蔽广告插件。"><a href="#adblock-plus-屏蔽广告插件。" class="headerlink" title="adblock-plus 屏蔽广告插件。"></a><code>adblock-plus</code> 屏蔽广告插件。</h3><p>说到广告啊。我用<code>chrome</code>  <code>adblock-plus</code>插件<br><a href="https://chrome.google.com/weipibstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">应用商店安装地址</a><br>屏蔽各种网站广告。</p><h3 id="网页截图插件-fireShot-系统截图PicPick软件"><a href="#网页截图插件-fireShot-系统截图PicPick软件" class="headerlink" title="网页截图插件 fireShot , 系统截图PicPick软件"></a>网页截图插件 <code>fireShot</code> , 系统截图<code>PicPick</code>软件</h3><p><a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg" target="_blank" rel="noopener">应用商店下载地址</a><br>有时需要截取整个网页，这个插件可以做到。<br>跳出网站，系统截图我推荐<code>Snipaste</code>或者<code>PicPick</code>软件。<br><a href="https://www.snipaste.com/" target="_blank" rel="noopener"><code>Snipaste</code>官网</a>，<code>win10</code>也可以通过<code>Microsoft Store 下载安装</code>。<br><a href="https://picpick.app/" target="_blank" rel="noopener"><code>PicPick</code>官网</a>。<br>说到截图顺带提下，win系统下，按<code>PrintScreen</code>键截取整个屏幕、按<code>Alt</code>键+<code>PrintScreen</code>键截取活动窗口、按<code>Win键+</code>PrintScreen<code>键截取整个屏幕，并保存在【图片】 - 【屏幕截图】 中，一般是</code>C:\Users{你的用户名}\Pictures\Screenshots<code>中。（PS:这个按Win键+</code>PrintScreen`键，我也是前不久才发现，真是活到老，学到老。）</p><h3 id="鼠标手势插件-crxMouse-插件"><a href="#鼠标手势插件-crxMouse-插件" class="headerlink" title="鼠标手势插件 crxMouse 插件"></a>鼠标手势插件 <code>crxMouse</code> 插件</h3><p>鼠标右击画一些手势，可以操作浏览器，控制前进、后退，关闭，翻页等。很好用。<br><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo" target="_blank" rel="noopener">应用商店地址</a></p><h3 id="OneTab-插件，节省内存，减轻标签页混乱现象"><a href="#OneTab-插件，节省内存，减轻标签页混乱现象" class="headerlink" title="OneTab  插件，节省内存，减轻标签页混乱现象"></a><code>OneTab</code>  插件，节省内存，减轻标签页混乱现象</h3><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">应用商店下载安装地址</a><br>官方是这样推荐的：节省高达95％的内存，并减轻标签页混乱现象<br>有时打开很多页面，没有及时关闭，就占用挺大内存，这个插件可以一键收起。以后再打开。当然还有更多功能。</p><h3 id="octotree-树形结构-查看github项目"><a href="#octotree-树形结构-查看github项目" class="headerlink" title="octotree 树形结构 查看github项目"></a><code>octotree</code> 树形结构 查看<code>github</code>项目</h3><p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="noopener">应用商店下载安装地址</a><br><a href="https://github.com/buunguyen/octotree" target="_blank" rel="noopener">github项目地址</a></p><h3 id="Octo-Mate-增强你的-github-体验"><a href="#Octo-Mate-增强你的-github-体验" class="headerlink" title="Octo Mate, 增强你的 github 体验"></a><code>Octo Mate</code>, 增强你的 <code>github</code> 体验</h3><p>能一键下载文件和目录形式查看文档等。<br><a href="https://chrome.google.com/webstore/detail/octo-mate/baggcehellihkglakjnmnhpnjmkbmpkf" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="一键管理-扩展-插件"><a href="#一键管理-扩展-插件" class="headerlink" title="一键管理 扩展 插件"></a>一键管理 扩展 插件</h3><p>安装了那么多插件，不常用的可以先停用，这个插件可以一键管理这些插件。<br><a href="https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86/kfjmkgngkgpgjdoealkmmajmmhpnffoj" target="_blank" rel="noopener">应用商店下载安装地址</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当然我安装了很多插件和软件，先推荐这些给大家，后续有时间再更新。还有更多好玩实用的插件和软件等着我们去发掘。<br>写到这里好久之前写过这样一篇文章<a href="https://www.jianshu.com/p/93d9fbb9ad92" target="_blank" rel="noopener">提高效率的电脑技巧及软件</a>，可以看看。<br>本着<strong>学我所学，为我所用，服务他人</strong>的宗旨^_^，这篇文章主要推荐了：<br>1、<code>Proxyee-down</code> 百度网盘下载神器<br>2、云盘万能钥匙 插件<br>3、<code>ghostery</code> 隐私广告拦截工具 插件<br>4、二维码生成 插件<br>5、云盘精灵，一个更好的网盘搜索引擎<br>6、<code>adblock-plus</code> 屏蔽广告插件。<br>7、网页截图插件 <code>fireShot</code> , 系统截图<code>Snipaste</code>或者<code>PicPick</code>软件<br>8、鼠标手势插件 <code>crxMouse</code> 插件<br>9、<code>OneTab</code>  插件，节省内存，减轻标签页混乱现象<br>10、<code>Octotree</code> 树形结构 查看<code>github</code>项目<br>11、<code>Octo Mate</code>, 增强 <code>github</code> 体验<br>12、一键管理 扩展 插件</p><p>文章同时发布在我的个人博客上：<a href="http://lxchuan12.github.io/2018/07/14/20180714-some%20baiduyunpan-and%20chrome%20crx/">分享百度网盘下载搜索神器和一些实用浏览器插件</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间（端午节期间）折腾电脑，用虚拟机安装&lt;code&gt;mac 10.13&lt;/code&gt;，但安装包太大，6.5G。&lt;br&gt;顺便放下我安装时参考的链接，说不定有人也想安装&lt;code&gt;mac&lt;/code&gt;试试，不过我试验的是安装后比较卡。&lt;a href=&quot;https://blo
      
    
    </summary>
    
      <category term="实用技巧" scheme="https://lxchuan12.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="chrome" scheme="https://lxchuan12.github.io/tags/chrome/"/>
    
      <category term="skydrive" scheme="https://lxchuan12.github.io/tags/skydrive/"/>
    
      <category term="baidu" scheme="https://lxchuan12.github.io/tags/baidu/"/>
    
  </entry>
  
  <entry>
    <title>分析vue-cli@2.9.3 搭建的webpack项目工程</title>
    <link href="https://lxchuan12.github.io/posts/eba15795.html"/>
    <id>https://lxchuan12.github.io/posts/eba15795.html</id>
    <published>2018-06-11T12:22:38.000Z</published>
    <updated>2019-02-10T14:29:24.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>已经有很多分析<code>Vue-cli</code>搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p><strong>项目放在笔者的<code>github</code>上，<a href="https://github.com/lxchuan12/analyse-vue-cli" target="_blank" rel="noopener">分析vue-cli@2.9.3 搭建的webpack项目工程</a>。方便大家克隆下载，或者在线查看。同时也求个<code>star</code> <code>^_^</code>，也是对笔者的一种鼓励和支持。</strong></p><p>正文从这里开始～</p><h3 id="使用vue-cli初始化webpack工程"><a href="#使用vue-cli初始化webpack工程" class="headerlink" title="使用vue-cli初始化webpack工程"></a>使用<code>vue-cli</code>初始化<code>webpack</code>工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// # 安装</span><br><span class="line">npm install -g vue-cli</span><br><span class="line">// 安装完后vue命令就可以使用了。实际上是全局注册了vue、vue-init、vue-list几个命令</span><br><span class="line"></span><br><span class="line">// # ubuntu 系统下</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue-init@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-init</span><br><span class="line">// [vue-cli@2.9.3] link /usr/local/bin/vue-list@ -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-list</span><br><span class="line"></span><br><span class="line">vue list</span><br><span class="line">// 可以发现有browserify、browserify-simple、pwa、simple、webpack、webpack-simple几种模板可选，这里选用webpack。</span><br><span class="line"></span><br><span class="line">// # 使用 vue init</span><br><span class="line">vue init &lt;template-name&gt; &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line">// # 例子</span><br><span class="line">vue init webpack analyse-vue-cli</span><br></pre></td></tr></table></figure><p>更多<code>vue-cli</code>如何工作的可以查看这篇文章<a href="https://juejin.im/post/5a7b1b86f265da4e8f049081" target="_blank" rel="noopener">vue-cli是如何工作的</a>，或者分析Vue-cli源码查看这篇<a href="https://segmentfault.com/a/1190000013975247" target="_blank" rel="noopener">走进Vue-cli源码，自己动手搭建前端脚手架工具</a>，再或者直接查看<a href="https://github.com/vuejs/vue-cli/tree/master" target="_blank" rel="noopener">vue-cli github仓库源码</a></p><p>如果对<code>webpack</code>还不是很了解，可以查看<a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">webpack官方文档中的概念</a>，虽然是最新版本的，但概念都是差不多的。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>分析一个项目，一般从<code>package.json</code>的命令入口<code>scripts</code>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  // dev webpack-dev-server --inline 模式 --progress 显示进度 --config 指定配置文件（默认是webpack.config.js）</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">  // jest测试</span><br><span class="line">  &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,</span><br><span class="line">  // e2e测试</span><br><span class="line">  &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;,</span><br><span class="line">  // 运行jest测试和e2e测试</span><br><span class="line">  &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;,</span><br><span class="line">  // eslint --ext 指定扩展名和相应的文件</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;,</span><br><span class="line">  // node 执行build/build.js文件</span><br><span class="line">  &quot;build&quot;: &quot;node build/build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p><code>Npm Script</code> 底层实现原理是通过调用 <code>Shell</code> 去运行脚本命令。<code>npm run start</code>等同于运行<code>npm run dev</code>。</p><p><code>Npm Script</code> 还有一个重要的功能是能运行安装到项目目录里的 <code>node_modules</code> 里的可执行模块。</p><p>例如在通过命令<code>npm i -D webpack-dev-server</code>将<code>webpack-dev-server</code>安装到项目后，是无法直接在项目根目录下通过命令 <code>webpack-dev-server</code> 去执行 <code>webpack-dev-server</code> 构建的，而是要通过命令 <code>./node_modules/.bin/webpack-dev-server</code> 去执行。</p><p><code>Npm Script</code> 能方便的解决这个问题，只需要在 <code>scripts</code> 字段里定义一个任务，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span><br></pre></td></tr></table></figure></p><p><code>Npm Script</code> 会先去项目目录下的 <code>node_modules</code> 中寻找有没有可执行的 <code>webpack-dev-server</code> 文件，如果有就使用本地的，如果没有就使用全局的。 所以现在执行 <code>webpack-dev-server</code> 启动服务时只需要通过执行 <code>npm run dev</code> 去实现。</p><blockquote><p>再来看下 npm run dev<br> <code>webpack-dev-server</code> 其实是一个<code>node.js</code>的应用程序，它是通过<code>JavaScript</code>开发的。在命令行执行<code>npm run dev</code>命令等同于执行<code>node ./node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js</code>。你可以试试。</p></blockquote><p>更多<code>package.json</code>的配置项，可以查看<a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">阮一峰老师的文章 package.json文件</a></p><p><code>npm run dev</code>指定了<code>build/webpack.dev.conf.js</code>配置去启动服务，那么我们来看下这个文件做了什么。</p><h3 id="build-webpack-dev-conf-js-webpack开发环境配置"><a href="#build-webpack-dev-conf-js-webpack开发环境配置" class="headerlink" title="build/webpack.dev.conf.js webpack开发环境配置"></a><code>build/webpack.dev.conf.js</code> <code>webpack</code>开发环境配置</h3><p>这个文件主要做了以下几件事情：<br>1、引入各种依赖，同时也引入了<code>config</code>文件夹下的变量和配置，和一个工具函数<code>build/utils.js</code>，<br>2、合并<code>build/webpack.base.conf.js</code>配置文件，<br>3、配置开发环境一些<code>devServer</code>，<code>plugin</code>等配置，<br>4、最后导出了一个<code>Promise</code>，根据配置的端口，寻找可用的端口来启动服务。</p><p>具体可以看<code>build/webpack.dev.conf.js</code>这个文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 引入工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js配置</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 合并webpack配置</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 基本配置</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)</span><br><span class="line">// 拷贝插件</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">// 生成html的插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">// 友好提示的插件 https://github.com/geowarin/friendly-errors-webpack-plugin</span><br><span class="line">const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)</span><br><span class="line">// 查找可用端口 // github仓库 https://github.com/indexzero/node-portfinder</span><br><span class="line">const portfinder = require(&apos;portfinder&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// process模块用来与当前进程互动，可以通过全局变量process访问，不必使用require命令加载。它是一个EventEmitter对象的实例。</span><br><span class="line"></span><br><span class="line">// 后面有些process模块用到的，所以这里统一列举下。</span><br><span class="line">// 更多查看这篇阮一峰的这篇文章 http://javascript.ruanyifeng.com/nodejs/process.html</span><br><span class="line"></span><br><span class="line">// process对象提供一系列属性，用于返回系统信息。</span><br><span class="line">// process.pid：当前进程的进程号。</span><br><span class="line">// process.version：Node的版本，比如v0.10.18。</span><br><span class="line">// process.platform：当前系统平台，比如Linux。</span><br><span class="line">// process.title：默认值为“node”，可以自定义该值。</span><br><span class="line">// process.argv：当前进程的命令行参数数组。</span><br><span class="line">// process.env：指向当前shell的环境变量，比如process.env.HOME。</span><br><span class="line">// process.execPath：运行当前进程的可执行文件的绝对路径。</span><br><span class="line">// process.stdout：指向标准输出。</span><br><span class="line">// process.stdin：指向标准输入。</span><br><span class="line">// process.stderr：指向标准错误。</span><br><span class="line"></span><br><span class="line">// process对象提供以下方法：</span><br><span class="line">// process.exit()：退出当前进程。</span><br><span class="line">// process.cwd()：返回运行当前脚本的工作目录的路径。_</span><br><span class="line">// process.chdir()：改变工作目录。</span><br><span class="line">// process.nextTick()：将一个回调函数放在下次事件循环的顶部。</span><br><span class="line"></span><br><span class="line">// host</span><br><span class="line">const HOST = process.env.HOST</span><br><span class="line">// 端口</span><br><span class="line">const PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)</span><br><span class="line"></span><br><span class="line">// 合并基本的webpack配置</span><br><span class="line">const devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    // cssSourceMap这里配置的是true</span><br><span class="line">    rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // cheap-module-eval-source-map is faster for development</span><br><span class="line">  // 在开发环境是cheap-module-eval-source-map选项更快</span><br><span class="line">  // 这里配置的是cheap-module-eval-source-map</span><br><span class="line">  // 更多可以查看中文文档：https://webpack.docschina.org/configuration/devtool/#devtool</span><br><span class="line">  // 英文 https://webpack.js.org/configuration/devtool/#development</span><br><span class="line">  devtool: config.dev.devtool,</span><br><span class="line"></span><br><span class="line">  // these devServer options should be customized in /config/index.js</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // 配置在客户端的日志等级，这会影响到你在浏览器开发者工具控制台里看到的日志内容。</span><br><span class="line">    // clientLogLevel 是枚举类型，可取如下之一的值 none | error | warning | info。</span><br><span class="line">    // 默认为 info 级别，即输出所有类型的日志，设置成 none 可以不输出任何日志。</span><br><span class="line">    clientLogLevel: &apos;warning&apos;,</span><br><span class="line">    // historyApiFallback boolean object 用于方便的开发使用了 HTML5 History API 的单页应用。</span><br><span class="line">    // 可以简单true 或者 任意的 404 响应可以提供为 index.html 页面。</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      rewrites: [</span><br><span class="line">        // config.dev.assetsPublicPath 这里是 /</span><br><span class="line">        &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    // 开启热更新</span><br><span class="line">    hot: true,</span><br><span class="line">    // contentBase 配置 DevServer HTTP 服务器的文件根目录。</span><br><span class="line">    // 默认情况下为当前执行目录，通常是项目根目录，所有一般情况下你不必设置它，除非你有额外的文件需要被 DevServer 服务。</span><br><span class="line">    contentBase: false, // since we use CopyWebpackPlugin.</span><br><span class="line">    // compress 配置是否启用 gzip 压缩。boolean 为类型，默认为 false。</span><br><span class="line">    compress: true,</span><br><span class="line">    // host</span><br><span class="line">    // 例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 --host 0.0.0.0</span><br><span class="line">    // 或者直接设置为 0.0.0.0</span><br><span class="line">    // 这里配置的是localhost</span><br><span class="line">    host: HOST || config.dev.host,</span><br><span class="line">    // 端口号 这里配置的是8080</span><br><span class="line">    port: PORT || config.dev.port,</span><br><span class="line">    // 打开浏览器，这里配置是不打开false</span><br><span class="line">    open: config.dev.autoOpenBrowser,</span><br><span class="line">    // 是否在浏览器以遮罩形式显示报错信息 这里配置的是true</span><br><span class="line">    overlay: config.dev.errorOverlay</span><br><span class="line">      ? &#123; warnings: false, errors: true &#125;</span><br><span class="line">      : false,</span><br><span class="line">      // 这里配置的是 /</span><br><span class="line">    publicPath: config.dev.assetsPublicPath,</span><br><span class="line">    // 代理 这里配置的是空&#123;&#125;,有需要可以自行配置</span><br><span class="line">    proxy: config.dev.proxyTable,</span><br><span class="line">    // 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    // 开启后一般非常干净只有类似的提示 Your application is running here: http://localhost:8080</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin</span><br><span class="line">    // webpack-dev-middleware</span><br><span class="line">    // watch: false,</span><br><span class="line">    // 启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。Watch 模式默认关闭。</span><br><span class="line">    // webpack-dev-server 和 webpack-dev-middleware 里 Watch 模式默认开启。</span><br><span class="line">    // Watch 模式的选项</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">      // 或者指定毫秒为单位进行轮询。</span><br><span class="line">      // 这里配置为false</span><br><span class="line">      poll: config.dev.poll,</span><br><span class="line">    &#125;</span><br><span class="line">    // 更多查看中文文档：https://webpack.docschina.org/configuration/watch/#src/components/Sidebar/Sidebar.jsx</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 定义为开发环境</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      // 这里是 &#123; NODE_ENV: &apos;&quot;development&quot;&apos; &#125;</span><br><span class="line">      &apos;process.env&apos;: require(&apos;../config/dev.env&apos;)</span><br><span class="line">    &#125;),</span><br><span class="line">    // 热更新插件</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    // 热更新时显示具体的模块路径</span><br><span class="line">    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.</span><br><span class="line">    // 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    // github仓库 https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: &apos;index.html&apos;,</span><br><span class="line">      // inject 默认值 true，script标签位于html文件的 body 底部</span><br><span class="line">      // body 通true, header, script 标签位于 head 标签内</span><br><span class="line">      // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;),</span><br><span class="line">    // copy custom static assets</span><br><span class="line">    // 把static资源复制到相应目录。</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        // 这里是 static</span><br><span class="line">        from: path.resolve(__dirname, &apos;../static&apos;),</span><br><span class="line">        // 这里是 static</span><br><span class="line">        to: config.dev.assetsSubDirectory,</span><br><span class="line">        // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git</span><br><span class="line">        ignore: [&apos;.*&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">// 导出一个promise</span><br><span class="line">module.exports = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // process.env.PORT 可以在命令行指定端口号，比如PORT=2000 npm run dev，那访问就是http://localhost:2000</span><br><span class="line">  // config.dev.port 这里配置是 8080</span><br><span class="line">  portfinder.basePort = process.env.PORT || config.dev.port</span><br><span class="line">  // 以配置的端口为基准，寻找可用的端口，比如：如果8080占用，那就8081,以此类推</span><br><span class="line">  // github仓库 https://github.com/indexzero/node-portfinder</span><br><span class="line">  portfinder.getPort((err, port) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // publish the new Port, necessary for e2e tests</span><br><span class="line">      process.env.PORT = port</span><br><span class="line">      // add port to devServer config</span><br><span class="line">      devWebpackConfig.devServer.port = port</span><br><span class="line"></span><br><span class="line">      // Add FriendlyErrorsPlugin</span><br><span class="line">      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123;</span><br><span class="line">        compilationSuccessInfo: &#123;</span><br><span class="line">          messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`],</span><br><span class="line">        &#125;,</span><br><span class="line">        // notifyOnErrors 这里配置是 true</span><br><span class="line">        // onErrors 是一个函数，出错输出错误信息，系统原生的通知</span><br><span class="line">        onErrors: config.dev.notifyOnErrors</span><br><span class="line">        ? utils.createNotifierCallback()</span><br><span class="line">        : undefined</span><br><span class="line">      &#125;))</span><br><span class="line"></span><br><span class="line">      resolve(devWebpackConfig)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="build-utils-js-工具函数"><a href="#build-utils-js-工具函数" class="headerlink" title="build/utils.js 工具函数"></a><code>build/utils.js</code> 工具函数</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/utils.js</code>工具函数。<br>该文件主要写了以下几个工具函数：<br>1、<code>assetsPath</code>返回输出路径，<br>2、<code>cssLoaders</code>返回相应的<code>css-loader</code>配置，<br>3、<code>styleLoaders</code>返回相应的处理样式的配置，<br>4、<code>createNotifierCallback</code>创建启动服务时出错时提示信息回调。</p><p>具体配置可以看该文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入配置文件config/index.js</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 提取css的插件</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line">// 引入package.json配置</span><br><span class="line">const packageConfig = require(&apos;../package.json&apos;)</span><br><span class="line">// 返回路径</span><br><span class="line">exports.assetsPath = function (_path) &#123;</span><br><span class="line">  const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">    // 二级目录 这里是 static</span><br><span class="line">    ? config.build.assetsSubDirectory</span><br><span class="line">    // 二级目录 这里是 static</span><br><span class="line">    : config.dev.assetsSubDirectory</span><br><span class="line"></span><br><span class="line">  // 生成跨平台兼容的路径</span><br><span class="line">  // 更多查看Node API链接：https://nodejs.org/api/path.html#path_path_posix</span><br><span class="line">  return path.posix.join(assetsSubDirectory, _path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.cssLoaders = function (options) &#123;</span><br><span class="line">  // 作为参数传递进来的options对象</span><br><span class="line">  // &#123;</span><br><span class="line">  //   // sourceMap这里是true</span><br><span class="line">  //   sourceMap: true,</span><br><span class="line">  //   // 是否提取css到单独的css文件</span><br><span class="line">  //   extract: true,</span><br><span class="line">  //   // 是否使用postcss</span><br><span class="line">  //   usePostCSS: true</span><br><span class="line">  // &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const cssLoader = &#123;</span><br><span class="line">    loader: &apos;css-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const postcssLoader = &#123;</span><br><span class="line">    loader: &apos;postcss-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // generate loader string to be used with extract text plugin</span><br><span class="line">  // 创建对应的loader配置</span><br><span class="line">  function generateLoaders (loader, loaderOptions) &#123;</span><br><span class="line">    // 是否使用usePostCSS，来决定是否采用postcssLoader</span><br><span class="line">    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]</span><br><span class="line"></span><br><span class="line">    if (loader) &#123;</span><br><span class="line">      loaders.push(&#123;</span><br><span class="line">        loader: loader + &apos;-loader&apos;,</span><br><span class="line">        // 合并 loaderOptions 生成options</span><br><span class="line">        options: Object.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">          sourceMap: options.sourceMap</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Extract CSS when that option is specified</span><br><span class="line">    // (which is the case during production build)</span><br><span class="line">    if (options.extract) &#123;</span><br><span class="line">      // 如果提取使用ExtractTextPlugin插件提取</span><br><span class="line">      // 更多配置 看插件中文文档：https://webpack.docschina.org/plugins/extract-text-webpack-plugin/</span><br><span class="line">      return ExtractTextPlugin.extract(&#123;</span><br><span class="line">        // 指需要什么样的loader去编译文件</span><br><span class="line">        // loader 被用于将资源转换成一个 CSS 导出模块 (必填)</span><br><span class="line">        use: loaders,</span><br><span class="line">        // loader（例如 &apos;style-loader&apos;）应用于当 CSS 没有被提取(也就是一个额外的 chunk，当 allChunks: false)</span><br><span class="line">        fallback: &apos;vue-style-loader&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return [&apos;vue-style-loader&apos;].concat(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // https://vue-loader.vuejs.org/en/configurations/extract-css.html</span><br><span class="line">  return &#123;</span><br><span class="line">    css: generateLoaders(),</span><br><span class="line">    postcss: generateLoaders(),</span><br><span class="line">    less: generateLoaders(&apos;less&apos;),</span><br><span class="line">    // sass indentedSyntax 语法缩进，类似下方格式</span><br><span class="line">    // #main</span><br><span class="line">    //   color: blue</span><br><span class="line">    //   font-size: 0.3em</span><br><span class="line">    sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;),</span><br><span class="line">    scss: generateLoaders(&apos;sass&apos;),</span><br><span class="line">    stylus: generateLoaders(&apos;stylus&apos;),</span><br><span class="line">    styl: generateLoaders(&apos;stylus&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Generate loaders for standalone style files (outside of .vue)</span><br><span class="line">// 最终会返回webpack css相关的配置</span><br><span class="line">exports.styleLoaders = function (options) &#123;</span><br><span class="line">  // &#123;</span><br><span class="line">  //   // sourceMap这里是true</span><br><span class="line">  //   sourceMap: true,</span><br><span class="line">  //   // 是否提取css到单独的css文件</span><br><span class="line">  //   extract: true,</span><br><span class="line">  //   // 是否使用postcss</span><br><span class="line">  //   usePostCSS: true</span><br><span class="line">  // &#125;</span><br><span class="line">  const output = []</span><br><span class="line">  const loaders = exports.cssLoaders(options)</span><br><span class="line"></span><br><span class="line">  for (const extension in loaders) &#123;</span><br><span class="line">    const loader = loaders[extension]</span><br><span class="line">    output.push(&#123;</span><br><span class="line">      test: new RegExp(&apos;\\.&apos; + extension + &apos;$&apos;),</span><br><span class="line">      use: loader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// npm run dev 出错时， FriendlyErrorsPlugin插件 配置 onErrors输出错误信息</span><br><span class="line">exports.createNotifierCallback = () =&gt; &#123;</span><br><span class="line">  // &apos;node-notifier&apos;是一个跨平台系统通知的页面，当遇到错误时，它能用系统原生的推送方式给你推送信息</span><br><span class="line">  const notifier = require(&apos;node-notifier&apos;)</span><br><span class="line"></span><br><span class="line">  return (severity, errors) =&gt; &#123;</span><br><span class="line">    if (severity !== &apos;error&apos;) return</span><br><span class="line"></span><br><span class="line">    const error = errors[0]</span><br><span class="line">    const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop()</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      title: packageConfig.name,</span><br><span class="line">      message: severity + &apos;: &apos; + error.name,</span><br><span class="line">      subtitle: filename || &apos;&apos;,</span><br><span class="line">      icon: path.join(__dirname, &apos;logo.png&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-webpack-base-conf-js-webpack基本配置文件"><a href="#build-webpack-base-conf-js-webpack基本配置文件" class="headerlink" title="build/webpack.base.conf.js webpack基本配置文件"></a><code>build/webpack.base.conf.js</code> <code>webpack</code>基本配置文件</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/webpack.base.conf.js</code>这个<code>webpack</code>基本配置文件。<br>这个文件主要做了以下几件事情：<br>1、引入各种插件、配置等，其中引入了<code>build/vue-loader.conf.js</code>相关配置，<br>2、创建<code>eslint</code>规则配置，默认启用，<br>3、导出<code>webpack</code>配置对象，其中包含<code>context</code>，入口<code>entry</code>，输出<code>output</code>，<code>resolve</code>，<code>module</code>下的<code>rules</code>（处理对应文件的规则），和<code>node</code>相关的配置等。</p><p>具体可以看这个文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// 使用严格模式，更多严格模式可以查看</span><br><span class="line">// [阮一峰老师的es标准入门](http://es6.ruanyifeng.com/?search=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F&amp;x=0&amp;y=0#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)</span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入配置文件，也就是config/index.js文件</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 引入vue-loader的配置文件</span><br><span class="line">const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)</span><br><span class="line">// 定义获取绝对路径函数</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, &apos;..&apos;, dir)</span><br><span class="line">&#125;</span><br><span class="line">// 创建eslint配置</span><br><span class="line">const createLintingRule = () =&gt; (&#123;</span><br><span class="line">  test: /\.(js|vue)$/,</span><br><span class="line">  loader: &apos;eslint-loader&apos;,</span><br><span class="line">  // 执行顺序，前置，还有一个选项是post是后置</span><br><span class="line">  // 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查</span><br><span class="line">  enforce: &apos;pre&apos;,</span><br><span class="line">  // 包含文件夹</span><br><span class="line">  include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    // 使用友好的eslint提示插件</span><br><span class="line">    formatter: require(&apos;eslint-friendly-formatter&apos;),</span><br><span class="line">    // eslint报错提示是否显示以遮罩形式显示在浏览器中</span><br><span class="line">    // 这里showEslintErrorsInOverlay配置是false</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 运行环境的上下文，就是实际的目录，也就是项目根目录</span><br><span class="line">  context: path.resolve(__dirname, &apos;../&apos;),</span><br><span class="line">  // 入口</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 输出</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 路径 这里是根目录下的dist</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    // 文件名</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    publicPath: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">      // 这里是 /，但要上传到github pages等会路径不对，需要修改为./</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      // 这里配置是 /</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  // Webpack 在启动后会从配置的入口模块出发找出所有依赖的模块，Resolve 配置 Webpack 如何寻找模块所对应的文件。</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 配置了这个，对应的扩展名可以省略</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      // 给定对象的键后的末尾添加 $，以表示精准匹配 node_modules/vue/dist/vue.esm.js</span><br><span class="line">      // 引用 import Vue from &apos;vue&apos;就是引入的这个文件最后export default Vue 导出的Vue;</span><br><span class="line">      // 所以这句可以以任意大写字母命名 比如：import V from &apos;vue&apos;</span><br><span class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">      // src别名 比如 ：引入import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 定义一些文件的转换规则</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // 是否使用eslint 这里配置是true</span><br><span class="line">      ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        // vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/</span><br><span class="line">        loader: &apos;vue-loader&apos;,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // js文件使用babel-loader转换</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 图片文件使用url-loader转换</span><br><span class="line">        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 限制大小10000B(bytes)以内，转成base64编码的dataURL字符串</span><br><span class="line">          limit: 10000,</span><br><span class="line">          // 输出路径 img/名称.7位hash.扩展名</span><br><span class="line">          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 视频文件使用url-loader转换</span><br><span class="line">        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // 这里的node是一个对象，其中每个属性都是 Node.js 全局变量或模块的名称，每个 value 是以下其中之一</span><br><span class="line">  // empty 提供空对象。</span><br><span class="line">  // false 什么都不提供。</span><br><span class="line">  // 更多查看 中文文档：https://webpack.docschina.org/configuration/node/</span><br><span class="line">  node: &#123;</span><br><span class="line">    // prevent webpack from injecting useless setImmediate polyfill because Vue</span><br><span class="line">    // source contains it (although only uses it if it&apos;s native).</span><br><span class="line">    // 防止webpack注入一些polyfill 因为Vue已经包含了这些。</span><br><span class="line">    setImmediate: false,</span><br><span class="line">    // prevent webpack from injecting mocks to Node native modules</span><br><span class="line">    // that does not make sense for the client</span><br><span class="line">    dgram: &apos;empty&apos;,</span><br><span class="line">    fs: &apos;empty&apos;,</span><br><span class="line">    net: &apos;empty&apos;,</span><br><span class="line">    tls: &apos;empty&apos;,</span><br><span class="line">    child_process: &apos;empty&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-vue-loader-conf-js-vue-loader配置文件"><a href="#build-vue-loader-conf-js-vue-loader配置文件" class="headerlink" title="build/vue-loader.conf.js vue-loader配置文件"></a><code>build/vue-loader.conf.js</code> <code>vue-loader</code>配置文件</h3><p>上文<code>build/webpack.dev.conf.js</code>提到引入了<code>build/vue-loader.conf.js</code>。</p><p>这个文件主要导出了一份<code>Vue-loader</code>的配置，<br>主要有：<code>loaders</code>，<code>cssSourceMap</code>，<code>cacheBusting</code>，<code>transformToRequire</code>。</p><p>具体看该文件注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">const isProduction = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">const sourceMapEnabled = isProduction</span><br><span class="line">  // 这里是true</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  // 这里是true</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line">// 更多配置 可以查看vue-loader中文文档：https://vue-loader-v14.vuejs.org/zh-cn/</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // cssLoaders 生成相应loader配置，具体看utils文件中的cssLoader</span><br><span class="line">  loaders: utils.cssLoaders(&#123;</span><br><span class="line">    // 是否开启sourceMap，便于调试</span><br><span class="line">    sourceMap: sourceMapEnabled,</span><br><span class="line">    // 是否提取vue单文件的css</span><br><span class="line">    extract: isProduction</span><br><span class="line">  &#125;),</span><br><span class="line">  // 是否开启cssSourceMap，便于调试</span><br><span class="line">  cssSourceMap: sourceMapEnabled,</span><br><span class="line">  // 这里是true</span><br><span class="line">  // 缓存破坏，进行sourceMap debug时，设置成false很有帮助。</span><br><span class="line">  cacheBusting: config.dev.cacheBusting,</span><br><span class="line">  // vue单文件中，在模板中的图片等资源引用转成require的形式。以便目标资源可以由 webpack 处理。</span><br><span class="line">  transformToRequire: &#123;</span><br><span class="line">    video: [&apos;src&apos;, &apos;poster&apos;],</span><br><span class="line">    source: &apos;src&apos;,</span><br><span class="line">    img: &apos;src&apos;,</span><br><span class="line">    // 默认配置会转换 &lt;img&gt; 标签上的 src 属性和 SVG 的 &lt;image&gt; 标签上的 xlink：href 属性。</span><br><span class="line">    image: &apos;xlink:href&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完了这些文件相应配置，开发环境的相关配置就串起来了。其中<code>config/</code>文件夹下的配置，笔者都已经注释在<code>build/</code>文件夹下的对应的文件中，所以就不单独说明了。</p><p>那回过头来看，<code>package.json</code>的<code>scripts</code>中的<code>npm run build</code>配置，<code>node build/build.js</code>，其实就是用<code>node</code>去执行<code>build/build.js</code>文件。</p><h3 id="build-build-js-npm-run-build-指定执行的文件"><a href="#build-build-js-npm-run-build-指定执行的文件" class="headerlink" title="build/build.js npm run build 指定执行的文件"></a><code>build/build.js</code> <code>npm run build</code> 指定执行的文件</h3><p>这个文件主要做了以下几件事情：<br>1、引入<code>build/check-versions</code>文件，检查<code>node</code>和<code>npm</code>的版本，<br>2、引入相关插件和配置，其中引入了<code>webpack</code>生产环境的配置<code>build/webpack.prod.conf.js</code>，<br>3、先控制台输出<code>loading</code>，删除<code>dist</code>目录下的文件，开始构建，构建失败和构建成功都给出相应的提示信息。</p><p>具体可以查看相应的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 检查node npm的版本</span><br><span class="line">require(&apos;./check-versions&apos;)()</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV = &apos;production&apos;</span><br><span class="line">// 命令行中的loading</span><br><span class="line">const ora = require(&apos;ora&apos;)</span><br><span class="line">// 删除文件或文件夹</span><br><span class="line">const rm = require(&apos;rimraf&apos;)</span><br><span class="line">// 路径相关</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalk</span><br><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 引入 生产环境webpack配置</span><br><span class="line">const webpackConfig = require(&apos;./webpack.prod.conf&apos;)</span><br><span class="line"></span><br><span class="line">// 控制台输入开始构建loading</span><br><span class="line">const spinner = ora(&apos;building for production...&apos;)</span><br><span class="line">spinner.start()</span><br><span class="line"></span><br><span class="line">// 删除原有构建输出的目录文件 这里是dist 和 static</span><br><span class="line">rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123;</span><br><span class="line">  // 如果出错，抛出错误</span><br><span class="line">  if (err) throw err</span><br><span class="line">  webpack(webpackConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    // 关闭 控制台输入开始构建loading</span><br><span class="line">    spinner.stop()</span><br><span class="line">    // 如果出错，抛出错误</span><br><span class="line">    if (err) throw err</span><br><span class="line">    process.stdout.write(stats.toString(&#123;</span><br><span class="line">      colors: true,</span><br><span class="line">      modules: false,</span><br><span class="line">      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span><br><span class="line">      chunks: false,</span><br><span class="line">      chunkModules: false</span><br><span class="line">    &#125;) + &apos;\n\n&apos;)</span><br><span class="line"></span><br><span class="line">    // 如果有错，控制台输出构建失败</span><br><span class="line">    if (stats.hasErrors()) &#123;</span><br><span class="line">      console.log(chalk.red(&apos;  Build failed with errors.\n&apos;))</span><br><span class="line">      process.exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 控制台输出构建成功相关信息</span><br><span class="line">    console.log(chalk.cyan(&apos;  Build complete.\n&apos;))</span><br><span class="line">    console.log(chalk.yellow(</span><br><span class="line">      &apos;  Tip: built files are meant to be served over an HTTP server.\n&apos; +</span><br><span class="line">      &apos;  Opening index.html over file:// won\&apos;t work.\n&apos;</span><br><span class="line">    ))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="build-check-versions-检查node和npm版本"><a href="#build-check-versions-检查node和npm版本" class="headerlink" title="build/check-versions 检查node和npm版本"></a><code>build/check-versions</code> 检查<code>node</code>和<code>npm</code>版本</h3><p>上文提到<code>build/check-versions</code> 检查<code>node</code>和<code>npm</code>版本，这个文件主要引入了一些插件和配置，最后导出一个函数，版本不符合预期就输出警告。</p><p>具体查看这个配置文件注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 控制台输入样式 chalk 更多查看：https://github.com/chalk/chalk</span><br><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">// 语义化控制版本的插件 更多查看：https://github.com/npm/node-semver</span><br><span class="line">const semver = require(&apos;semver&apos;)</span><br><span class="line">// package.json配置</span><br><span class="line">const packageConfig = require(&apos;../package.json&apos;)</span><br><span class="line">// shell 脚本 Unix shell commands for Node.js 更多查看：https://github.com/shelljs/shelljs</span><br><span class="line">const shell = require(&apos;shelljs&apos;)</span><br><span class="line"></span><br><span class="line">function exec (cmd) &#123;</span><br><span class="line">  return require(&apos;child_process&apos;).execSync(cmd).toString().trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const versionRequirements = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;node&apos;,</span><br><span class="line">    currentVersion: semver.clean(process.version),</span><br><span class="line">    // 这里配置是&quot;node&quot;: &quot;&gt;= 6.0.0&quot;,</span><br><span class="line">    versionRequirement: packageConfig.engines.node</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">// 需要使用npm</span><br><span class="line">if (shell.which(&apos;npm&apos;)) &#123;</span><br><span class="line">  versionRequirements.push(&#123;</span><br><span class="line">    name: &apos;npm&apos;,</span><br><span class="line">    currentVersion: exec(&apos;npm --version&apos;),</span><br><span class="line">    // 这里配置是&quot;npm&quot;: &quot;&gt;= 3.0.0&quot;</span><br><span class="line">    versionRequirement: packageConfig.engines.npm</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 导出一个检查版本的函数</span><br><span class="line">module.exports = function () &#123;</span><br><span class="line">  const warnings = []</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; versionRequirements.length; i++) &#123;</span><br><span class="line">    const mod = versionRequirements[i]</span><br><span class="line"></span><br><span class="line">    // 当前版本不大于所需版本</span><br><span class="line">    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</span><br><span class="line">      warnings.push(mod.name + &apos;: &apos; +</span><br><span class="line">        chalk.red(mod.currentVersion) + &apos; should be &apos; +</span><br><span class="line">        chalk.green(mod.versionRequirement)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果有警告，全部输出到控制台</span><br><span class="line">  if (warnings.length) &#123;</span><br><span class="line">    console.log(&apos;&apos;)</span><br><span class="line">    console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;))</span><br><span class="line">    console.log()</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; warnings.length; i++) &#123;</span><br><span class="line">      const warning = warnings[i]</span><br><span class="line">      console.log(&apos;  &apos; + warning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log()</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-webpack-prod-conf-js-webpack生产环境配置"><a href="#build-webpack-prod-conf-js-webpack生产环境配置" class="headerlink" title="build/webpack.prod.conf.js webpack生产环境配置"></a><code>build/webpack.prod.conf.js</code> <code>webpack</code>生产环境配置</h3><p>上文<code>build/build.js</code>提到，引入了这个配置文件。<br>这个文件主要做了以下几件事情：<br>1、引入一些插件和配置，其中引入了<code>build/webpack.base.conf.js</code> <code>webpack</code>基本配置文件，<br>2、用<code>DefinePlugin</code>定义环境，<br>3、合并基本配置，定义自己的配置<code>webpackConfig</code>，配置了一些<code>modules</code>下的<code>rules</code>，<code>devtools</code>配置，<code>output</code>输出配置，一些处理<code>js</code>、提取<code>css</code>、压缩<code>css</code>、输出<code>html</code>插件、提取公共代码等的<br><code>plugins</code>，<br>4、如果启用<code>gzip</code>，再使用相应的插件处理，<br>5、如果启用了分析打包后的插件，则用<code>webpack-bundle-analyzer</code>，<br>6、最后导出这份配置。</p><p>具体可以查看这个文件配置注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">// 引入node路径相关</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 引入utils工具函数</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">// 引入webpack</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">// 引入config/index.js配置文件</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">// 合并webpack配置的插件</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">// 基本的webpack配置</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)</span><br><span class="line">// 拷贝文件和文件夹的插件</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理HTML的插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理css的插件</span><br><span class="line">const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">// 压缩处理js的插件</span><br><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">// 用DefinePlugin定义环境</span><br><span class="line">const env = process.env.NODE_ENV === &apos;testing&apos;</span><br><span class="line">  // 这里是 &#123; NODE_ENV: &apos;&quot;testing&quot;&apos; &#125;</span><br><span class="line">  ? require(&apos;../config/test.env&apos;)</span><br><span class="line">  // 这里是 &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125;</span><br><span class="line">  : require(&apos;../config/prod.env&apos;)</span><br><span class="line">// 合并基本webpack配置</span><br><span class="line">const webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    // 通过styleLoaders函数生成样式的一些规则</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      // sourceMap这里是true</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      // 是否提取css到单独的css文件</span><br><span class="line">      extract: true,</span><br><span class="line">      // 是否使用postcss</span><br><span class="line">      usePostCSS: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 配置使用sourceMap true 这里是 #source-map</span><br><span class="line">  devtool: config.build.productionSourceMap ? config.build.devtool : false,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 这里是根目录下的dist</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    // 文件名称 chunkhash</span><br><span class="line">    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;),</span><br><span class="line">    // chunks名称 chunkhash</span><br><span class="line">    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // http://vuejs.github.io/vue-loader/en/workflow/production.html</span><br><span class="line">    // 定义具体是什么环境</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env&apos;: env</span><br><span class="line">    &#125;),</span><br><span class="line">    // 压缩js插件</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          // 警告</span><br><span class="line">          warnings: false</span><br><span class="line">          // 构建后的文件 常用的配置还有这些</span><br><span class="line">          // 去除console.log 默认为false。  传入true会丢弃对console函数的调用。</span><br><span class="line">          // drop_console: true,</span><br><span class="line">          // 去除debugger</span><br><span class="line">          // drop_debugger: true,</span><br><span class="line">          // 默认为null. 你可以传入一个名称的数组，而UglifyJs将会假定那些函数不会产生副作用。</span><br><span class="line">          // pure_funcs: [ &apos;console.log&apos;, &apos;console.log.apply&apos; ],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 是否开启sourceMap 这里是true</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      // 平行处理（同时处理）加快速度</span><br><span class="line">      parallel: true</span><br><span class="line">    &#125;),</span><br><span class="line">    // extract css into its own file</span><br><span class="line">    // 提取css到单独的css文件</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      // 提取到相应的文件名 使用内容hash contenthash</span><br><span class="line">      filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;),</span><br><span class="line">      // Setting the following option to `false` will not extract CSS from codesplit chunks.</span><br><span class="line">      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.</span><br><span class="line">      // It&apos;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&apos;s `false`,</span><br><span class="line">      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110</span><br><span class="line">      // allChunks 默认是false,true指提取所有chunks包括动态引入的组件。</span><br><span class="line">      allChunks: true,</span><br><span class="line">    &#125;),</span><br><span class="line">    // Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">    // duplicated CSS from different components can be deduped.</span><br><span class="line">    new OptimizeCSSPlugin(&#123;</span><br><span class="line">      // 这里配置是true</span><br><span class="line">      cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">        ? &#123; safe: true, map: &#123; inline: false &#125; &#125;</span><br><span class="line">        : &#123; safe: true &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // generate dist index.html with correct asset hash for caching.</span><br><span class="line">    // you can customize output by editing /index.html</span><br><span class="line">    // see https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      // 输出html名称</span><br><span class="line">      filename: process.env.NODE_ENV === &apos;testing&apos;</span><br><span class="line">        ? &apos;index.html&apos;</span><br><span class="line">        // 这里是 根目录下的dist/index.html</span><br><span class="line">        : config.build.index,</span><br><span class="line">      // 使用哪个模板</span><br><span class="line">      template: &apos;index.html&apos;,</span><br><span class="line">      // inject 默认值 true，script标签位于html文件的 body 底部</span><br><span class="line">      // body 通true, header, script 标签位于 head 标签内</span><br><span class="line">      // false 不插入生成的 js 文件，只是单纯的生成一个 html 文件</span><br><span class="line">      inject: true,</span><br><span class="line">      // 压缩</span><br><span class="line">      minify: &#123;</span><br><span class="line">        // 删除注释</span><br><span class="line">        removeComments: true,</span><br><span class="line">        // 删除空格和换行</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        // 删除html标签中属性的双引号</span><br><span class="line">        removeAttributeQuotes: true</span><br><span class="line">        // 更多配置查看html-minifier插件</span><br><span class="line">        // more options:</span><br><span class="line">        // https://github.com/kangax/html-minifier#options-quick-reference</span><br><span class="line">      &#125;,</span><br><span class="line">      // necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br><span class="line">      // 在chunk被插入到html之前，你可以控制它们的排序。允许的值 ‘none’ | ‘auto’ | ‘dependency’ | &#123;function&#125; 默认为‘auto’.</span><br><span class="line">      // dependency 依赖（从属）</span><br><span class="line">      chunksSortMode: &apos;dependency&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    // keep module.id stable when vendor modules does not change</span><br><span class="line">    // 根据代码内容生成普通模块的id，确保源码不变，moduleID不变。</span><br><span class="line">    new webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    // enable scope hoisting</span><br><span class="line">    // 开启作用域提升 webpack3新的特性，作用是让代码文件更小、运行的更快</span><br><span class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    // split vendor js into its own file</span><br><span class="line">    // 提取公共代码</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &apos;vendor&apos;,</span><br><span class="line">      minChunks (module) &#123;</span><br><span class="line">        // any required modules inside node_modules are extracted to vendor</span><br><span class="line">        return (</span><br><span class="line">          module.resource &amp;&amp;</span><br><span class="line">          /\.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">          module.resource.indexOf(</span><br><span class="line">            path.join(__dirname, &apos;../node_modules&apos;)</span><br><span class="line">          ) === 0</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // extract webpack runtime and module manifest to its own file in order to</span><br><span class="line">    // prevent vendor hash from being updated whenever app bundle is updated</span><br><span class="line">    // 提取公共代码</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      // 把公共的部分放到 manifest 中</span><br><span class="line">      name: &apos;manifest&apos;,</span><br><span class="line">      // 传入 `Infinity` 会马上生成 公共chunk，但里面没有模块。</span><br><span class="line">      minChunks: Infinity</span><br><span class="line">    &#125;),</span><br><span class="line">    // This instance extracts shared chunks from code splitted chunks and bundles them</span><br><span class="line">    // in a separate chunk, similar to the vendor chunk</span><br><span class="line">    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span><br><span class="line">    // 提取动态组件</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &apos;app&apos;,</span><br><span class="line">      // 如果设置为 `true`，一个异步的  公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。</span><br><span class="line">      // 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。</span><br><span class="line">      async: &apos;vendor-async&apos;,</span><br><span class="line">      // 如果设置为 `true`，所有  公共chunk 的子模块都会被选择</span><br><span class="line">      children: true,</span><br><span class="line">      // 最小3个，包含3，chunk的时候提取</span><br><span class="line">      minChunks: 3</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    // copy custom static assets</span><br><span class="line">    // 把static资源复制到相应目录。</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        from: path.resolve(__dirname, &apos;../static&apos;),</span><br><span class="line">        // 这里配置是static</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        // 忽略.开头的文件。比如这里的.gitkeep，这个文件是指空文件夹也提交到git</span><br><span class="line">        ignore: [&apos;.*&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">// 如果开始gzip压缩，使用compression-webpack-plugin插件处理。这里配置是false</span><br><span class="line">// 需要使用是需要安装 npm i compression-webpack-plugin -D</span><br><span class="line">if (config.build.productionGzip) &#123;</span><br><span class="line">  const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(&#123;</span><br><span class="line">      // asset： 目标资源名称。 [file] 会被替换成原始资源。</span><br><span class="line">      // [path] 会被替换成原始资源的路径， [query] 会被替换成查询字符串。默认值是 &quot;[path].gz[query]&quot;。</span><br><span class="line">      asset: &apos;[path].gz[query]&apos;,</span><br><span class="line">      // algorithm： 可以是 function(buf, callback) 或者字符串。对于字符串来说依照 zlib 的算法(或者 zopfli 的算法)。默认值是 &quot;gzip&quot;。</span><br><span class="line">      algorithm: &apos;gzip&apos;,</span><br><span class="line">      // test： 所有匹配该正则的资源都会被处理。默认值是全部资源。</span><br><span class="line">      // config.build.productionGzipExtensions 这里是[&apos;js&apos;, &apos;css&apos;]</span><br><span class="line">      test: new RegExp(</span><br><span class="line">        &apos;\\.(&apos; +</span><br><span class="line">        config.build.productionGzipExtensions.join(&apos;|&apos;) +</span><br><span class="line">        &apos;)$&apos;</span><br><span class="line">      ),</span><br><span class="line">      // threshold： 只有大小大于该值的资源会被处理。单位是 bytes。默认值是 0。</span><br><span class="line">      threshold: 10240,</span><br><span class="line">      // minRatio： 只有压缩率小于这个值的资源才会被处理。默认值是 0.8。</span><br><span class="line">      minRatio: 0.8</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出分析的插件 运行npm run build --report</span><br><span class="line">// config.build.bundleAnalyzerReport这里是 process.env.npm_config_report</span><br><span class="line">// build结束后会自定打开 http://127.0.0.1:8888 链接</span><br><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  // 更多查看链接地址：https://www.npmjs.com/package/webpack-bundle-analyzer</span><br><span class="line">  const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line">// 当然也可以用官方提供的网站 http://webpack.github.io/analyse/#home</span><br><span class="line">// 运行类似 webpack --profile --json &gt; stats.json 命令</span><br><span class="line">// 把生成的构建信息stats.json上传即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 最终导出 webpackConfig</span><br><span class="line">module.exports = webpackConfig</span><br></pre></td></tr></table></figure><p>至此，我们就分析完了<code>package.json</code>中的<code>npm run dev</code>和<code>npm run build</code>两个命令。测试相关的类似就略过吧。</p><p><code>npm run lint</code>，<code>.eslintrc.js</code>中的配置不多，更多可以查看<a href="https://eslint.org/" target="_blank" rel="noopener">eslint英文文档</a>或<a href="http://eslint.cn/" target="_blank" rel="noopener"><code>eslint</code>中文官网</a>，所以也略过吧。不过提一下，把<code>eslint</code>整合到<code>git</code>工作流。可以安装<code>husky</code>，<code>npm i husky -S</code>。安装后，配置<code>package.json</code>的<code>scripts</code>中，配置<code>precommit</code>，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit test/e2e/specs&quot;,</span><br><span class="line">  &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>配置好后，每次<code>git commit -m</code>提交会检查代码是否通过<code>eslint</code>校验，如果没有校验通过则提交失败。还可以配置<code>prepush</code>。<code>husky</code>不断在更新，现在可能与原先的配置不太相同了，具体查看<a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky github仓库</a>。原理就是<code>git-hooks</code>,<code>pre-commit</code>的钩子。对<code>shell</code>脚本熟悉的同学也可以自己写一份<code>pre-commit</code>。复制到项目的<code>.git/hooks/pre-commit</code>中。不需要依赖<code>husky</code>包。我司就是用的<code>shell</code>脚本。</p><p>最后提一下<code>.babelrc</code>文件中的配置。</p><h3 id="babelrc-babel相关配置"><a href="#babelrc-babel相关配置" class="headerlink" title=".babelrc babel相关配置"></a><code>.babelrc</code> <code>babel</code>相关配置</h3><p>配置了一些转码规则。这里附上两个链接：<a href="https://babeljs.io/" target="_blank" rel="noopener"><code>babel</code>英文官网</a>和<a href="https://babel.bootcss.com/" target="_blank" rel="noopener"><code>babel</code>的中文官网</a>。</p><p>具体看文件中的配置注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // presets指明转码的规则</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    // env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;modules&quot;: false,</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line">  // plugins 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。</span><br><span class="line">  // transform-vue-jsx 表明可以在项目中使用jsx语法，会使用这个插件转换</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;],</span><br><span class="line">  // 在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;],</span><br><span class="line">      &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-es2015-modules-commonjs&quot;, &quot;dynamic-import-node&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件中<code>presets</code>中有配置<code>env</code>和<code>stage-2</code>，可能不知道是什么。这里引用<a href="http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-1%E4%BD%BF%E7%94%A8ES6%E8%AF%AD%E8%A8%80.html" target="_blank" rel="noopener">深入浅出webpack</a>书中，第三章，<code>3-1</code>使用<code>ES6</code>语言 小节的一段，解释一下。</p><blockquote><p><code>presets</code> 属性告诉 <code>Babel</code> 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 <code>Presets</code> 可以叠加。 <code>Presets</code> 其实是一组 <code>Plugins</code> 的集合，每一个 <code>Plugin</code> 完成一个新语法的转换工作。<code>Presets</code> 是按照 <code>ECMAScript</code> 草案来组织的，通常可以分为以下三大类（书中就是说三大类，我发现就两点~~~）：<br>1、已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为：<br>es2015 包含在2015里加入的新特性；<br>es2016 包含在2016里加入的新特性；<br>es2017 包含在2017里加入的新特性；<br>es2017 包含在2017里加入的新特性；<br>env 包含当前所有 ECMAScript 标准里的最新特性。<br>2、被社区提出来的但还未被写入 <code>ECMAScript</code> 标准里特性，这其中又分为以下四种：<br><code>stage0</code> 只是一个美好激进的想法，有 <code>Babel</code> 插件实现了对这些特性的支持，但是不确定是否会被定为标准；<br><code>stage1</code> 值得被纳入标准的特性；<br><code>stage2</code> 该特性规范已经被起草，将会被纳入标准里；<br><code>stage3</code> 该特性规范已经定稿，各大浏览器厂商和 <code></code> 社区开始着手实现；<br><code>stage4</code> 在接下来的一年将会加入到标准里去。</p></blockquote><p>至此，就算相对完整的分析完了<code>Vue-cli</code>(版本<code>v2.9.3</code>)搭建的<code>webpack</code>项目工程。希望对大家有所帮助。<br><strong>项目放在笔者的<code>github</code>上，<a href="https://github.com/lxchuan12/analyse-vue-cli" target="_blank" rel="noopener">分析vue-cli@2.9.3 搭建的webpack项目工程</a>。方便大家克隆下载，或者在线查看。同时也求个<code>star</code> <code>^_^</code>，也是对笔者的一种鼓励和支持。</strong><br>笔者知识能力有限，文章有什么不妥之处，欢迎指出~</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、分析这些，逐行注释，还是需要一些时间的。其中有些不是很明白的地方，及时查阅相应的官方文档和插件文档（建议看英文文档和最新的文档），不过文档没写明白的地方，可以多搜索一些别人的博客文章，相对比较清晰明了。<br>2、前端发展太快，这个<a href="mailto:`Vue-cli@2.9.3" target="_blank" rel="noopener">`Vue-cli@2.9.3</a><code></code>webpack<code>版本还是</code>v3.x<code>，webpack现在官方版本已经是</code>v4.12.0<code>，相信不久后，</code>Vue-cli<code>也将发布支持</code>webpack v4.x<code>的版本，</code>v3.0.0<code>已经是</code>beta.16<code>了。3、后续有余力，可能会继续分析新版的</code>vue-cli<code>构建的</code>webpack`项目工程。</p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;已经有很多分析&lt;code&gt;Vue-cli&lt;/code&gt;搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，
      
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://lxchuan12.github.io/tags/vue/"/>
    
      <category term="vue-cli" scheme="https://lxchuan12.github.io/tags/vue-cli/"/>
    
      <category term="webpack" scheme="https://lxchuan12.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴</title>
    <link href="https://lxchuan12.github.io/posts/564cef63.html"/>
    <id>https://lxchuan12.github.io/posts/564cef63.html</id>
    <published>2018-05-15T16:15:21.000Z</published>
    <updated>2019-02-10T14:29:24.517Z</updated>
    
    <content type="html"><![CDATA[<p>近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。<br>老模块是用的<a href="http://code.ciaoca.com/javascript/qrcode/" target="_blank" rel="noopener">qrocode中文文档</a>，<a href="https://github.com/davidshimjs/qrcodejs" target="_blank" rel="noopener">qrcode github</a>。</p><p>先想着新模块中是否有生成二维码的插件，看了下<code>package.json</code>。<br>有安装一个<a href="https://github.com/theomessin/vue-qriously" target="_blank" rel="noopener">vue-qriously</a>…<a id="more"></a>但搜索了一下，竟然没有使用，可能是因为很多二维码都是后端生成返回链接给前端的。而在其他H5、微信项目中使用了。看了下这个项目<code>star</code>数是<code>113</code>。但我不想重新引入老模块的<code>qrcodejs</code>，重新引入其他的二维码插件，相对比较麻烦。于是就保持统一用<code>vue-qriously</code>了。<br>猜想当时引入这个是<a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">vue 资源合集<code>awesome-vue</code></a>中，<code>qrcode</code>相关第一个就是<code>vue-qriously</code>。</p><h3 id="vue-qriously插件使用"><a href="#vue-qriously插件使用" class="headerlink" title="vue-qriously插件使用"></a><code>vue-qriously</code>插件使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 入口js文件</span><br><span class="line">// npm install vue-qriously -S</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import VueQriously from &apos;vue-qriously&apos;;</span><br><span class="line">Vue.use(VueQriously);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// vue 文件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;qriously :value=&quot;value&quot; size=&quot;size&quot; :backgroundAlpha=&quot;backgroundAlpha&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;app&apos;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            // 可以自定义，必填项。</span><br><span class="line">            value: &apos;http://lxchuan12.github.io/&apos;,</span><br><span class="line">            // 二维码大小 默认 100</span><br><span class="line">            size: 80,</span><br><span class="line">            // 背景透明度，默认透明 0 </span><br><span class="line">            backgroundAlpha： 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更多参数配置可以查看：<a href="https://github.com/theomessin/vue-qriously/blob/master/src/components/v-qriously.vue" target="_blank" rel="noopener">github 仓库 v-qriously.vue源码</a><br>查看代码可以发现，开头引用了<code>qrious</code>，这个<code>star</code>就多一点，<code>600</code>多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Qrious from &apos;qrious&apos;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/neocotic/qrious" target="_blank" rel="noopener"><code>qrious</code> github 地址</a><br><a href="https://neocotic.com/qrious/" target="_blank" rel="noopener"><code>qrious</code> 文档</a></p><h3 id="下载二维码"><a href="#下载二维码" class="headerlink" title="下载二维码"></a>下载二维码</h3><p>粗略的翻看下以上相关文档，写完正准备要做下载功能。这时发现，哎呀，竟然就是只生成了一个<code>canvas</code>。<br>于是百度(暴露了用百度…我也想用谷歌，但现在不行…)了下<code>canvas</code>如何转图片。<br><a href="https://stackoverflow.com/questions/923885/capture-html-canvas-as-gif-jpg-png-pdf" target="_blank" rel="noopener">stackoverflow Capture HTML Canvas as gif/jpg/png/pdf?</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&quot;mycanvas&quot;);</span><br><span class="line">var imgSrc    = canvas.toDataURL(&quot;image/png&quot;);</span><br><span class="line">document.write(&apos;&lt;img src=&quot;&apos;+img+&apos;&quot;/&gt;&apos;);</span><br><span class="line">// 搜索到一些其他的方案，感觉挺麻烦。</span><br><span class="line">// 嗯，这个简单。想着我们项目兼容性没什么要求，于是就用这个了。</span><br></pre></td></tr></table></figure></p><p>生成了<code>img</code>的<code>src</code>资源，那么就可以下载了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 老模块是用的`jquery` + `seajs` + `vue1.x`</span><br><span class="line">// 新模块尽量要去除`jquery`。</span><br><span class="line">let src = $(&apos;.img&apos;).src;</span><br><span class="line">let aLink = $(&apos;&lt;a&gt;&lt;/a&gt;&apos;).attr(&apos;href&apos;, src).attr(&apos;download&apos;, &apos;xxx二维码.png&apos;).appendTo(&apos;body&apos;);</span><br><span class="line">aLink[0].click();</span><br><span class="line">aLink.remove();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 新模块 去除jquery</span><br><span class="line">let elem = document.createElement(&apos;a&apos;);</span><br><span class="line">elem.setAttribute(&apos;href&apos;, imgSrc);</span><br><span class="line">elem.setAttribute(&apos;download&apos;, &apos;xxx二维码.png&apos;);</span><br><span class="line">document.body.appendChild(elem);</span><br><span class="line">elem.click();</span><br><span class="line">document.body.removeChild(elem);</span><br></pre></td></tr></table></figure><p>但这样写也相对比较麻烦。<br>项目中封装了一个<code>v-click</code>指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vClick 触发点击</span><br><span class="line"> * @type &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const vClick = &#123;</span><br><span class="line">directives: &#123;</span><br><span class="line">click: &#123;</span><br><span class="line">/**</span><br><span class="line"> * 值更新时候触发点击</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> * @param  &#123;HTMLElement&#125; el                指令所绑定的元素</span><br><span class="line"> * @param  &#123;Boolean&#125;     options.value     绑定值(新)</span><br><span class="line"> * @param  &#123;Boolean&#125;     options.oldValue  绑定值(旧)</span><br><span class="line"> */</span><br><span class="line">update(el, &#123; value, oldValue &#125;)&#123;</span><br><span class="line">if(value &amp;&amp; !oldValue)&#123;</span><br><span class="line">el.click();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot; v-show=&quot;listShareShow&quot;&gt;</span><br><span class="line">        &lt;qriously id=&quot;qriously&quot; :backgroundAlpha=&quot;1&quot; :value=&quot;listSharingLink&quot; :size=&quot;160&quot; v-show=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;img :src=&quot;listSharingLinkSrc&quot; alt=&quot;xxx二维码&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;a :href=&quot;exportLink&quot; v-click=&quot;download&quot; :download=&quot;downloadFilename&quot;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a  @click.stop=&quot;listShare&quot;&gt;查看链接/二维码&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    // 提取出主要代码</span><br><span class="line">    data()&#123;</span><br><span class="line">        retrun &#123;</span><br><span class="line">            // 下载</span><br><span class="line">download: false,</span><br><span class="line">downloadFilename: &apos;xxx二维码&apos;,</span><br><span class="line">listSharingLinkSrc: &apos;&apos;,</span><br><span class="line">            listSharingLinkSrc: &apos;&apos;,</span><br><span class="line">            listShareShow: false,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        /**</span><br><span class="line"> * 查看链接/二维码</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> */</span><br><span class="line">listShare(event)&#123;</span><br><span class="line">if(!this.listSharingLinkSrc)&#123;</span><br><span class="line">let canvas = document.querySelector(&apos;#qriously canvas&apos;);</span><br><span class="line">let imgSrc = canvas.toDataURL(&apos;image/png&apos;);</span><br><span class="line">this.listSharingLinkSrc = imgSrc;</span><br><span class="line">&#125;</span><br><span class="line">this.listShareShow = !this.listShareShow;</span><br><span class="line">&#125;,</span><br><span class="line">        /**</span><br><span class="line"> * 表格上方：下载二维码列表</span><br><span class="line"> * @author 轩辕Rowboat &lt;lxchuan12@163.com&gt;</span><br><span class="line"> * @date   2018-05-15</span><br><span class="line"> */</span><br><span class="line">downloadQrcode(event, linkSrc, downloadFilename)&#123;</span><br><span class="line">event.stopPropagation();</span><br><span class="line">this.exportLink = linkSrc;</span><br><span class="line">this.downloadFilename = downloadFilename;</span><br><span class="line">this.download = true;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.exportLink = &apos;&apos;;</span><br><span class="line">this.download = false;</span><br><span class="line">this.downloadFilename = &apos;&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>代码写到这里，嗯，实现完了下载。但又发现又一需求，显示大小是<code>80 * 80</code>，下载需要是<code>160 * 160</code>。</p><h3 id="显示大小和下载大小不一样。"><a href="#显示大小和下载大小不一样。" class="headerlink" title="显示大小和下载大小不一样。"></a>显示大小和下载大小不一样。</h3><p>参考了下老模块，<code>qrcodejs</code>渲染出来的<code>html</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  跟这个类似</span><br><span class="line">&lt;div id=&quot;qrcode_1&quot; title=&quot;your content&quot;&gt;</span><br><span class="line">    &lt;canvas width=&quot;256&quot; height=&quot;256&quot; style=&quot;display: none;&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;img alt=&quot;Scan me!&quot; style=&quot;display: block;&quot; src=&quot;data:image/png;base64,xxx&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><code>vue-qriously</code>渲染出来是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;canvas width=&quot;80&quot; width=&quot;80&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>于是我可以把生成的<code>imgSrc</code>资源,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;canvas width=&quot;160&quot; width=&quot;160&quot; v-show=&quot;false&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;img class=&quot;img&quot; :src=&quot;imgSrc&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">.img&#123;</span><br><span class="line">    width: 80px;</span><br><span class="line">    height: 80px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>这就实现了下载的资源是<code>160 * 160</code>，用样式控制图片显示<code>80 * 80</code>。<br>代码写完，觉得应该给<code>vue-qriously</code>写个<code>pr</code>,实现 不仅仅是渲染<code>canvas</code>，而是让大家可以选择时<code>img</code>还是<code>canvas</code>。又去翻了翻这个项目的<code>issue</code>,有一个<code>issue</code><a href="https://github.com/theomessin/vue-qriously/issues/10" target="_blank" rel="noopener">链接：how to make this canvas exchange to img</a> 就是说的这个。还没关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i think u can create type let user select img and canvas.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 有一个回复</span><br><span class="line">If you want to make it become downloadable, maybe you can transform it from canvas easily by canvas.toDataURL()</span><br></pre></td></tr></table></figure><p>文章写到这里，我发现这样似乎不太妥。我的场景，是点击时显示浮层（浮层有二维码和复制链接地址和下载二维码按钮等），获取<code>canvas</code>元素，去转成<code>img</code> <code>src</code>，再去渲染到页面，而且图片可能会闪，因为是实际大小是<code>160</code>，样式强制控制在<code>80</code>。<br>何不生成两份，一份是用来获取资源下载的。一份用来显示的。嗯，之后去优化下。<br>顺带说一下，复制粘贴</p><h3 id="cliploard-复制粘贴"><a href="#cliploard-复制粘贴" class="headerlink" title="cliploard 复制粘贴"></a>cliploard 复制粘贴</h3><p>老模块中是用的<code>cliploard</code><a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard github仓库</a>。就是我引入的。</p><p>新模块还没使用过，但依然使用这个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">// npm install clipboard --save</span><br><span class="line">&lt;template @click=&quot;Clip($event, &apos;快来复制&apos;)&quot;&gt;&lt;template&gt;</span><br><span class="line">// 封装成一个函数</span><br><span class="line">import Clipboard from &apos;clipboard&apos;;</span><br><span class="line">export default function Clip(event，text) &#123;</span><br><span class="line">  const clipboard = new Clipboard(event.target, &#123;</span><br><span class="line">    text: () =&gt; text</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.on(&apos;success&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;复制成功&apos;);</span><br><span class="line">    clipboard.off(&apos;error&apos;);</span><br><span class="line">    clipboard.off(&apos;success&apos;);</span><br><span class="line">    clipboard.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.on(&apos;error&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;复制失败，请刷新试试&apos;);</span><br><span class="line">    clipboard.off(&apos;error&apos;)</span><br><span class="line">    clipboard.off(&apos;success&apos;)</span><br><span class="line">    clipboard.destroy()</span><br><span class="line">  &#125;);</span><br><span class="line">  clipboard.onClick(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以封装成<code>vue</code>指令。<br>可以参考<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin这个项目</a><br>之前我看的时候还是<code>3000</code>多<code>star</code>，现在<code>1.2w+</code>，说明值得学习。<br>另外推荐<a href="https://www.awesomes.cn/" target="_blank" rel="noopener"><code>awesomes</code>网站 工具类库合集</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、引入第三方插件等使用时，多查看<code>github</code> 文档 <code>issue</code>等，在技术社区搜索别人使用的方案。<br>2、选用第三方插件时，尽可能挑选<code>star</code>比较多的，<code>issue</code>处理比较及时的，在更新维护的。<br>3、富余时间可以多研究下别人的项目是如何组织文件，和实现的一些常用功能的。<br>4、尽可能去优化自己的代码，总结回顾。</p><p>文章首发于<a href="https://segmentfault.com/a/1190000014875645" target="_blank" rel="noopener">vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴</a></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。&lt;br&gt;老模块是用的&lt;a href=&quot;http://code.ciaoca.com/javascript/qrcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qrocode中文文档&lt;/a&gt;，&lt;a href=&quot;https://github.com/davidshimjs/qrcodejs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qrcode github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;先想着新模块中是否有生成二维码的插件，看了下&lt;code&gt;package.json&lt;/code&gt;。&lt;br&gt;有安装一个&lt;a href=&quot;https://github.com/theomessin/vue-qriously&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-qriously&lt;/a&gt;…
    
    </summary>
    
      <category term="vue" scheme="https://lxchuan12.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://lxchuan12.github.io/tags/vue/"/>
    
      <category term="qrcode" scheme="https://lxchuan12.github.io/tags/qrcode/"/>
    
      <category term="clipboard" scheme="https://lxchuan12.github.io/tags/clipboard/"/>
    
  </entry>
  
  <entry>
    <title>参加有赞前端技术开放日所感所想</title>
    <link href="https://lxchuan12.github.io/posts/d41e56e9.html"/>
    <id>https://lxchuan12.github.io/posts/d41e56e9.html</id>
    <published>2018-04-21T12:08:26.000Z</published>
    <updated>2019-02-10T14:29:24.485Z</updated>
    
    <content type="html"><![CDATA[<p>从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。<br>之前参加过网易云课堂学习节、拉勾网理想之上、<a href="https://coding.net/" target="_blank" rel="noopener">coding.net</a> 技术小馆、阿里<code>D2</code>两次、阿里<code>work like alibaba</code>沙龙、<code>freeCodeCamp</code>线下分享等…自己也参与到<code>freeCodeCamp</code>(<code>FCC</code>)，<a href="https://freecodecamp.cn/" target="_blank" rel="noopener">点击访问freeCodeCamp</a>，杭州线下分享活动的组织中<a id="more"></a></p><h3 id="为什么这么热衷于参加这类活动呢？"><a href="#为什么这么热衷于参加这类活动呢？" class="headerlink" title="为什么这么热衷于参加这类活动呢？"></a>为什么这么热衷于参加这类活动呢？</h3><p>可能拿之前D2填写的参会理由可以很好的解答这个问题。</p><p><strong>D2报名填写的参会理由:</strong><br>1、了解讲师碰到的问题，有哪些解决方案，是如何解决的，学习他们的解决思路和方案。<br>2、了解现在前端技术发展情况和未来发展趋势，把握学习方向。<br>3、结交前端圈内朋友，让自己融入到更积极的技术氛围，促进自己的技术提升。</p><h3 id="为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？"><a href="#为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？" class="headerlink" title="为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？"></a>为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？</h3><p>刚好看到知乎上有这个帖子。<a href="https://www.zhihu.com/question/274150609" target="_blank" rel="noopener">参加有赞前端技术开放日是种怎样的体验？</a></p><p>因为之前都是免费的活动。好像也没什么可写的。觉得发条朋友圈简明扼要的总结下即可。这次有赞的活动是收费的，都这么多人参加，直播观看量3w人次（最高时），而且有其他城市的人过来。比如：罗辑思维（北京），简书（上海）。<strong>可见前端圈的小伙伴对参与这类活动也是十分活跃的，同时说明了有赞宣传的比较好。</strong>所以，觉得有必要写一下。技术方面不多写，可以回看PPT，或视频。</p><p>可以看下官方微信公众号发布的活动总结文章，里面有PPT，视频回放等。<br><a href="https://mp.weixin.qq.com/s/9FIESH8rGaV0JPR1lMgUTQ" target="_blank" rel="noopener">有赞技术活动首秀——有赞前端技术开放日圆满结束</a><br>主题主要有：<br>1、主题一：有赞开源项目最佳实践<br>2、主题二：本地调试线上代码——<a href="https://github.com/youzan/zan-proxy" target="_blank" rel="noopener">已开源，点击访问<code>ZanProxy</code></a><br>3、主题三：让前后端协作更高效——<code>ZanAPI</code><br>4、主题四：<code>Node</code> 在有赞的实践<br>5、主题五：有赞内部代码管理工具串讲</p><p>为什么会有这么多产出，主要有三点：<br>1、业务逼的<br>2、工程师文化<br>3、注重技术基础</p><p>感觉就是有赞前端技术团队，碰到什么问题，奔着高效工作的目的，提出解决方案，团队内部适用、推广，最后把做得比较好的项目开源。<br>总之有赞前端技术团队靠谱、有追求。值得加入。</p><p>我是12点多到达场地。这时人还不多。拍了两张照。</p><img src="/posts/d41e56e9/first-1.jpg" title="开场前场外"><img src="/posts/d41e56e9/first-2.jpg" title="开场前场内"><h3 id="回顾一下整场活动，主要有六点："><a href="#回顾一下整场活动，主要有六点：" class="headerlink" title="回顾一下整场活动，主要有六点："></a>回顾一下整场活动，主要有六点：</h3><p><strong>1、人脉圈子</strong></p><p>有赞前端技术负责人施德来（下文简称<strong>德来</strong>）分享的缘起，说杭州兑吧公司想去有赞参观参观，交流交流。于是干脆办一个技术开放日。然后邀请了杭州一些公司来参与。比如点我达、丁香园、兑吧等。<br>说明杭州各个公司的前端负责人的有技术圈子，都相互认识熟悉，而且比较注重交流。<br>有人脉圈子，对于程序员来说，很重要。</p><p><strong>2、正向反馈</strong><br>虽然有赞搞了很多成功的项目，但也有失败的项目。<br>所有的失败项目，总结起来，就一条：没有准确估计投入产出比。<br>就是说没有正向反馈，就最后不了了之了。平时自己学习也是如此，如果没能看到正反馈，很难坚持下去。</p><p><strong>3、演讲能力</strong></p><p>德来宣称他们内部演讲已经练习过几次了。<br>程序员可能比较欠缺演讲能力，毕竟很少机会上台面对上百人演讲，分享技术。</p><p><strong>4、救场解围</strong><br>Q/A问答环节，可能有些问题讲师解答不是很清晰，或者说提问者不停追问，就容易导致僵持下去，现场尴尬，时间不可控等。<br>于是好几次都是德来来解答提问者的问题。</p><p><strong>5、技术（开源）项目本质上是：理念、套路、规范的工具化。</strong><br>这句话是德来说的，印象比较深刻。<br>比如开源的项目<a href="https://github.com/youzan/felint" target="_blank" rel="noopener">点击访问<code>felint</code></a>就是一个集成了 <code>eslint</code>、<code>stylelint</code>、<code>git hook</code> 的前端代码检查工具。<br>规范定好，提交代码时强制校验，或者说<strong>随你怎么写，代码都一样</strong>，最后提交会验证一遍。<br>我司用的就是<code>githooks</code> <code>git commit</code> 时校验代码规范性。</p><p><strong>6、参与到开源项目</strong><br>有余力的情况下，可以参与到开源项目，也是对自己的一种提升。</p><p>最后放两张照片</p><img src="/posts/d41e56e9/rest-time.jpg" title="茶歇时间场外交流"><img src="/posts/d41e56e9/full.jpg" title="微信群中工作人员拍的场内全景图"><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/blog/lxchuan12" target="_blank" rel="noopener"><code>segmentfault</code>前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金专栏</a>，欢迎关注<br><a href="https://zhuanlan.zhihu.com/lxchuan12" target="_blank" rel="noopener">知乎前端视野专栏</a>，开通了<strong>前端视野</strong>专栏，欢迎关注<br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a>，欢迎<code>follow</code>~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。&lt;br&gt;之前参加过网易云课堂学习节、拉勾网理想之上、&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coding.net&lt;/a&gt; 技术小馆、阿里&lt;code&gt;D2&lt;/code&gt;两次、阿里&lt;code&gt;work like alibaba&lt;/code&gt;沙龙、&lt;code&gt;freeCodeCamp&lt;/code&gt;线下分享等…自己也参与到&lt;code&gt;freeCodeCamp&lt;/code&gt;(&lt;code&gt;FCC&lt;/code&gt;)，&lt;a href=&quot;https://freecodecamp.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击访问freeCodeCamp&lt;/a&gt;，杭州线下分享活动的组织中
    
    </summary>
    
      <category term="随笔" scheme="https://lxchuan12.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lxchuan12.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结，一如既往</title>
    <link href="https://lxchuan12.github.io/posts/5c654ba9.html"/>
    <id>https://lxchuan12.github.io/posts/5c654ba9.html</id>
    <published>2018-01-05T15:56:52.000Z</published>
    <updated>2019-02-10T14:29:24.490Z</updated>
    
    <content type="html"><![CDATA[<p>斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。</p><p>年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。<br>比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…<a id="more"></a><br><img src="/posts/5c654ba9/2017-cover.png" title="封面"><br>翻看着电脑上【N-年度总结】文件夹中2014~2016年年度总结。一般文件夹中有一份PPT和一份思维导图。</p><p>新建了一个【2017年】的文件夹，翻看2017年微博整理出2017微博时间轴，继而整理出2017年的各个方面的思维导图。</p><img src="/posts/5c654ba9/2017xmind.png" title="2017年八大层面"><p>再看看2017年年初的年度大体计划，付出、收获这样的词汇，似乎不太合适。2018年的年度计划不敢写了。</p><img src="/posts/5c654ba9/2017plan.jpg" title="2016年总结的最后一页PPT"><p>如果说2015年关键词是<strong>PPT</strong>，2016年说是<strong>毕业、开发</strong>，那么2017年依旧是<strong>开发</strong>。2017年和2016年基本一样，没什么波澜，一如既往。</p><h3 id="“丰富多彩的生活”"><a href="#“丰富多彩的生活”" class="headerlink" title="“丰富多彩的生活”"></a>“丰富多彩的生活”</h3><p>1月份，过年期间去舅舅家拜年，舅舅和姐夫都说我2016年工作后变了挺多，尤其酒量不错。大学室友说我工作后比较爱玩了，大学期间比较喜欢宅在寝室。其实我是那种宅也可以，游山玩水也可以的一类人。</p><p>12月份，和一朋友聊天，她说了一句：<strong>看你朋友圈各方面蛮精彩的</strong>。想起高中关系比较好的几个同学都在985、211读研，虽然他们表示比较羡慕我朋友圈发的”丰富多彩”的生活，但我也比较羡慕他们的。这也许就是人们常说的围城吧。城外的人想进城，城里的人想出城。</p><p>但事实上，我们总是习惯地去推测：看到一个人去图书馆，就推测TA博览群书。看到一个人发朋友圈在旅行，就推测TA经常在旅行。看到一个人去参加各种线下活动学习，就推测TA经常去参加这类活动。<br>于是将美好的别人与糟糕的自己对比，从而心生羡慕。但往往这种推测不准确。</p><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h3><p>这一年，每天基本都是12点10分左右，有时睡得比较晚上班就容易打哈欠，同事开玩笑说是不是早起偷能量了。</p><p>基本也没怎么锻炼，（半小时左右）上半年基本走路上下班，下半年就成基本骑车上下班了。</p><p>年初体检了一次，年底体检了一次，虽无大碍，但还是要注意身体。体检时听到体检机构的工作人员讨论，别看现在的年轻人年轻，但他们经常很晚才睡，熬夜，不吃早餐等。是啊，年轻人更应该注意身体，尤其是IT行业的程序员。</p><h3 id="慢慢打造“个人品牌”"><a href="#慢慢打造“个人品牌”" class="headerlink" title="慢慢打造“个人品牌”"></a>慢慢打造“个人品牌”</h3><p>这一年，换了工作，在前端开发上有所成长，偶尔会在segmentFault社区答题，主要是10月份，一个月声望值增长976分。月度排行榜排名第六。现在声望值2.2K。虽然比较少，但基本是今年才涨的。全年只在segmentFault社区、掘金发布了两篇文章。</p><p>5月份，开通了“前端视野”，知识星球（原“小密圈”），偶尔发一些前端开发相关的知识和感想，没怎么推广的情况下，没想到到年底有91人加入。</p><p>很多人努力学习知识，参加各种沙龙，向前辈学习，参加开源项目，把自己的心得无私的分享出来，慢慢的，他们踏上了不一样的平台，快速成长。</p><p>这样努力的人我朋友圈就有一位。毕业四年在北京，月薪早已超出同龄人的水平。但基本学习到2点左右睡，6:50起，午休睡一会，一般一天不少于6小时。还读着英文文档，玩转各种开发语言。想想我身边他这层次的人也没有这么拼啊，他解释道：个人追求也不同，追求也不一样。他都这样的努力确实让我敬佩不已。真是应了那句话：比你优秀的人不可怕，可怕的是比你优秀的人比你更努力。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>这一年，清明假期和同学去了江苏无锡鼋头渚、惠山古镇、三国城等。<br>太湖四月天，无锡鼋头渚。登上赏樱楼，樱花似白雪。<br>惠山古镇，历史悠久，古迹众多，人文荟萃。宝界山林，远眺太湖。湖光山色，相映生辉。<br><img src="/posts/5c654ba9/img1.jpg" title="太湖"><br><img src="/posts/5c654ba9/img2.jpg" title="三英醒狮会"><br><img src="/posts/5c654ba9/img3.jpg" title="三国城门口"></p><p>五一假期去了浙江舟山。人生中的第一次看海，海上日出日落。</p><img src="/posts/5c654ba9/img4.jpg" title="舟山海上日出"><img src="/posts/5c654ba9/img5.jpg"><p>随便放了几张照片。<br>2017年初上写的旅行计划去黄山、上海、出境游通通没有实现，现实版的计划赶不上变化，是多么痛的领悟。</p><h3 id="危机感"><a href="#危机感" class="headerlink" title="危机感"></a>危机感</h3><p>5月13日，和课题组的两位同学，一起回学校参加课题组老师的婚礼，老师说：“到时你们婚礼的时候派代表参加”。一次和毕业几年的表哥聊天，聊到年轻的时候最重要的两件事就是结婚和买房。同事也会问准备一直在杭州吗。感觉这类话题，不管和谁聊天都会聊到。我就感慨到：现如今，大学毕业生靠自己在杭州买房，真是难于上青天。</p><blockquote><p>到底有多难，我大概算了下。假如杭州郊区算3万一平，那么一套房算300万，首付30%则需90万。假如一年存款能有10万，那么也要攒9年。你可能会说工资会涨，但可以肯定没有房价涨得快…而且只是付完首付而已，就要9年。9年后又到了人们常说的中年危机，面对各方面的压力，那么以后的日子更加艰难。照这样想想都后怕。<br>但在大城市还是有一定机会的，虽然比较渺茫。<br>退一步回老家买房，但小县城房价均价据说都6K+了。而且感觉在老家买房，自己在外漂泊也不是办法啊。</p></blockquote><p>写到这里，看到统计的字数是1818字，刚好2018年，很吉利。2017年度总结算是收尾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。&lt;/p&gt;
&lt;p&gt;年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。&lt;br&gt;比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴…
    
    </summary>
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lxchuan12.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践 读书笔记 - 未完待续...不用点开了~</title>
    <link href="https://lxchuan12.github.io/posts/f0c8bd37.html"/>
    <id>https://lxchuan12.github.io/posts/f0c8bd37.html</id>
    <published>2017-12-05T15:25:01.000Z</published>
    <updated>2019-02-10T14:29:24.482Z</updated>
    
    <content type="html"><![CDATA[<p>看完此书，打算慢慢整理下读书笔记。便于巩固消化。</p><h3 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h3><h3 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h3><h4 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h4><h5 id="定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。"><a href="#定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。" class="headerlink" title="定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。"></a>定义：单例模式的定义是：保证一个类仅有一个实例，并提供它的全局访问点。</h5><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>比如弹窗</p><h5 id="通用的惰性单例"><a href="#通用的惰性单例" class="headerlink" title="通用的惰性单例"></a>通用的惰性单例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function(fn)&#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result ||  (result = fn.apply(this, arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三部分-设计原则和编程技巧"><a href="#第三部分-设计原则和编程技巧" class="headerlink" title="第三部分 设计原则和编程技巧"></a>第三部分 设计原则和编程技巧</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完此书，打算慢慢整理下读书笔记。便于巩固消化。&lt;/p&gt;
&lt;h3 id=&quot;第一部分-基础知识&quot;&gt;&lt;a href=&quot;#第一部分-基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 基础知识&quot;&gt;&lt;/a&gt;第一部分 基础知识&lt;/h3&gt;&lt;h3 id=&quot;第二部分-
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>移动端双击事件和PC端</title>
    <link href="https://lxchuan12.github.io/posts/69cc5a1e.html"/>
    <id>https://lxchuan12.github.io/posts/69cc5a1e.html</id>
    <published>2017-12-04T13:37:29.000Z</published>
    <updated>2019-02-10T14:29:24.461Z</updated>
    
    <content type="html"><![CDATA[<p>SF上，有个问题<a href="https://segmentfault.com/q/1010000012279336/a-1020000012280637" target="_blank" rel="noopener">想请教一下，一般类似于微信那样的，双击屏幕回到顶部是怎么做的呀？</a><br>刚开始我回答的直接是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 原生JS、PC端可以在`body`上添加双击事件</span><br><span class="line">document.addEventListener(&apos;dblclick&apos;, function()&#123;</span><br><span class="line">    window.scrollTo(0, 0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在PC端测试了下，没问题。然后再看到别人的回答，似乎好像在移动端不起作用。于是用<code>Chrome</code>浏览器的移动端模拟试了下果然没用。<br>然后百度搜索了下，看到两篇文章<a href="http://www.mzwu.com/article.asp?id=4276" target="_blank" rel="noopener">移动手机端不能触发jQuery双击事件dblclick解决方法</a>，<br><a href="http://drunkhero.com/bingolife/home.php/home/blog/detail/passage/59.html" target="_blank" rel="noopener">双击事件dblclick在移动端不起作用？</a>，<br>加上了下面的答案。测试通过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 移动端双击不起作用。</span><br><span class="line">// 可以用单击事件模拟</span><br><span class="line">var touchTime = Date.now();</span><br><span class="line">function handleClick()&#123;</span><br><span class="line">    if( Date.now() - touchTime &lt; 800 )&#123;</span><br><span class="line">         window.scrollTo(0, 0);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果第二次点击在第一次点击0.8秒后，</span><br><span class="line">        //则第二次点击默认为下一次双击判断的第一次点击</span><br><span class="line">        touchTime = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.addEventListener(&apos;click&apos;, handleClick);</span><br></pre></td></tr></table></figure></p><p>那么问题又来了，我知道直接在<code>document</code>上挂载事件是正确的。但为什么不用<code>document.body</code>呢，我一下说不上来。document.body是<code>&lt;body&gt;&lt;/body&gt;</code>。是<strong>只适用于<code>HTML</code>对象的<code>DOM</code>对象</strong>。类似这样的还有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.images -- 当前页面中所有图片的集合。等价于Core DOM组件中的document.getElementsByTagName(&apos;img&apos;)调用。</span><br><span class="line">document.applets -- 等价于document.getElementsByTagName(&apos;applets&apos;)。</span><br><span class="line">document.links -- 是一个列表，包含了页面中所有的`&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;`标签，也就是页面中所有含有`href`属性的A标签。</span><br><span class="line">document.anchors -- 是包含所有带name熟悉的链接。即`&lt;a name=&quot;...&quot;&gt;&lt;/a&gt;`</span><br><span class="line">document.forms -- 用的比较广泛。forms标签的集合。document.forms[0] === document.getElementsByTagName(&apos;form&apos;)[0]</span><br><span class="line">// 以上只适用于`HTML`对象的`DOM`对象内容，摘抄于《JavaScript面向对象编程指南 · 第2版》</span><br></pre></td></tr></table></figure></p><p>我们常见的获取元素是<code>document.querySelector(&#39;body&#39;)</code>，<code>document.getElementById()</code>，或者<code>document.getElementsByClassName()</code>,<code>document.getElementsByTagName()</code>,<code>document.getElementsByName()</code>等。<br>于是我谷歌了一下，<code>document</code>和<code>document.body</code>却出来了<code>document.ducumentElement</code>的对比。<br>我们知道<code>document.documentElement</code>是<code>HTML</code>节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(document)</span><br><span class="line">&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(document.body)</span><br><span class="line">&quot;[object HTMLBodyElement]&quot;</span><br><span class="line">Object.prototype.toString.call(document.documentElement)</span><br><span class="line">&quot;[object HTMLHtmlElement]&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var divNode = document.createElement(&apos;div&apos;);</span><br><span class="line">document.appendChild(divNode);</span><br><span class="line">// 报错：</span><br><span class="line">// VM396:1 Uncaught DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: Only one element on document allowed.</span><br><span class="line">document.body.appendChild(divNode);</span><br></pre></td></tr></table></figure><p>我翻了翻<code>w3c规范</code><br><a href="http://w3help.org/zh-cn/standards/" target="_blank" rel="noopener">W3C 标准内容列表</a><br><a href="https://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html" target="_blank" rel="noopener">1.文档对象模型（核心）级别1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptors(document);</span><br><span class="line">// &#123;location: &#123;&#125;&#125;</span><br><span class="line">document.location === window.location;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SF上，有个问题&lt;a href=&quot;https://segmentfault.com/q/1010000012279336/a-1020000012280637&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;想请教一下，一般类似于微信那样的，双击屏幕回到顶部
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript上卷-读书笔记 - 未完待续...不用点开了~</title>
    <link href="https://lxchuan12.github.io/posts/47e68ed7.html"/>
    <id>https://lxchuan12.github.io/posts/47e68ed7.html</id>
    <published>2017-10-26T15:36:52.000Z</published>
    <updated>2019-02-10T14:29:24.464Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望<br>你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之<br>后， 无论什么技术、 框架和流行词语你都能轻松理解。<br>使用代码示例<br>可以在这里下载本书第一部分“作用域和闭包” 随附的资料（代码示例、 练习题等） ：<br><a href="http://bit.ly/1c8HEWF。" target="_blank" rel="noopener">http://bit.ly/1c8HEWF。</a><br>可以在这里下载本书第二部分“this 和对象原型” 随附的资料（代码示例、 练习题等） ：<br><a href="http://bit.ly/ydkjs-this-code" target="_blank" rel="noopener">http://bit.ly/ydkjs-this-code</a><br>要了解更多 O’Reilly 图书、 培训课程、 会议和新闻的信息， 请访问以下网站：<br><a href="http://www.oreilly.com" target="_blank" rel="noopener">http://www.oreilly.com</a><br>我们在 Facebook 的地址如下： <a href="http://facebook.com/oreilly" target="_blank" rel="noopener">http://facebook.com/oreilly</a><br>请关注我们的 Twitter 动态： <a href="http://twitter.com/oreillymedia" target="_blank" rel="noopener">http://twitter.com/oreillymedia</a><br>我们的 YouTube 视频地址如下： <a href="http://www.youtube.com/oreillymedia" target="_blank" rel="noopener">http://www.youtube.com/oreillymedia</a><br>要查看“你不知道的 JavaScript” 系列丛书中的全部图书， 请访问：<br><a href="http://YouDontKnowJS.com" target="_blank" rel="noopener">http://YouDontKnowJS.com</a></p><h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><p>知其然， 也要知其所以然。</p><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h2><h4 id="分词-词法分析（Tokenizing-Lexing）"><a href="#分词-词法分析（Tokenizing-Lexing）" class="headerlink" title="分词/词法分析（Tokenizing/Lexing）"></a>分词/词法分析（Tokenizing/Lexing）</h4><p>这个过程会将由字符组成的字符串分解成（对编程语言来说） 有意义的代码块， 这些代<br>码块被称为词法单元（token）。 例如， 考虑程序 var a = 2;。 这段程序通常会被分解成<br>为下面这些词法单元： var、 a、 =、 2 、 ;。 空格是否会被当作词法单元， 取决于空格在<br>这门语言中是否具有意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;你们应当像我一样， 不满足于只是让代码正常工作， 而是想要弄清楚“为什么”。 我希望&lt;br&gt;你能勇于挑战这条崎岖颠簸的“少有人走的路”， 拥抱整个 JavaScript。 掌握了这些知识之&lt;br&gt;后， 无论什么技术、 框架和流行词语你都能轻松理解。&lt;br&gt;使用
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript正则表达式迷你书-阅读笔记</title>
    <link href="https://lxchuan12.github.io/posts/cb601326.html"/>
    <id>https://lxchuan12.github.io/posts/cb601326.html</id>
    <published>2017-10-12T15:45:52.000Z</published>
    <updated>2019-02-10T14:29:24.573Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">正则可视化工具</a><br><a href="https://regexper.com/#jsah" target="_blank" rel="noopener">正则可视化工具-regexper</a><br><a href="http://regex101.com/" target="_blank" rel="noopener">正则在线测试工具-regex101</a></p><h1 id="勘误："><a href="#勘误：" class="headerlink" title="勘误："></a>勘误：</h1><p>2.4.2.5. 格式化<br>$ 1888.00 -&gt; $ 1,888.00</p><p>3.3.1. 括号嵌套怎么办？<br>最后的是 \4，找到第3个开括号  -&gt; 最后的是 \4，找到第4个开括号</p><p>3.5.6. 匹配成对标签<br>其中开标签 &lt;[\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;  -&gt;  其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt;</p><p>5.1. 结构和操作符<br>在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构—&gt;按照原文：这里的因此应该不标红。</p><p>6.3.2. 匹配浮点数<br>因此整个正则是这三者的或的关系，提取公众部分后是：—-&gt;公共部分</p><p>[《JavaScript 正则表达式迷你书》问世了！]（<a href="https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）</a></p><h1 id="记录一些学到的"><a href="#记录一些学到的" class="headerlink" title="记录一些学到的"></a>记录一些学到的</h1><h1 id="1-第一章-正则表达式字符匹配攻略"><a href="#1-第一章-正则表达式字符匹配攻略" class="headerlink" title="1. 第一章 正则表达式字符匹配攻略"></a>1. 第一章 正则表达式字符匹配攻略</h1><h3 id="1-2-1-范围表示法"><a href="#1-2-1-范围表示法" class="headerlink" title="1.2.1. 范围表示法"></a>1.2.1. 范围表示法</h3><p>因为连字符有特殊用途，那么要匹配 “a”、”-“、”z” 这三者中任意一个字符，该怎么做呢？<br>不能写成 [a-z]，因为其表示小写字符中的任何一个字符。<br>可以写成如下的方式：[-az] 或 [az-] 或 [a-z]。<br>即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</p><h3 id="1-2-3-常见的简写形式"><a href="#1-2-3-常见的简写形式" class="headerlink" title="1.2.3. 常见的简写形式"></a>1.2.3. 常见的简写形式</h3><p>如果要匹配任意字符怎么办？可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。</p><h3 id="1-3-2-贪婪匹配与惰性匹配"><a href="#1-3-2-贪婪匹配与惰性匹配" class="headerlink" title="1.3.2. 贪婪匹配与惰性匹配"></a>1.3.2. 贪婪匹配与惰性匹配</h3><p>其中 /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。</p><h2 id="1-4-多选分支"><a href="#1-4-多选分支" class="headerlink" title="1.4. 多选分支"></a>1.4. 多选分支</h2><p>但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 “goodbye” 字符串时，结果是 “good”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|goodbye/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;good&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /goodbye|good/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;goodbye&quot;]</span><br></pre></td></tr></table></figure><p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</p><h3 id="1-5-1-匹配-16-进制颜色值"><a href="#1-5-1-匹配-16-进制颜色值" class="headerlink" title="1.5.1. 匹配 16 进制颜色值"></a>1.5.1. 匹配 16 进制颜色值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line">var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;]</span><br></pre></td></tr></table></figure><h3 id="1-5-2-匹配时间"><a href="#1-5-2-匹配时间" class="headerlink" title="1.5.2. 匹配时间"></a>1.5.2. 匹配时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><p>如果也要求匹配 “7:9”，也就是说时分前面的 “0” 可以省略。<br>此时正则变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">console.log( regex.test(&quot;7:9&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-3-匹配日期"><a href="#1-5-3-匹配日期" class="headerlink" title="1.5.3. 匹配日期"></a>1.5.3. 匹配日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line">console.log( regex.test(&quot;2017-06-10&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-4-window-操作系统文件路径"><a href="#1-5-4-window-操作系统文件路径" class="headerlink" title="1.5.4. window 操作系统文件路径"></a>1.5.4. window 操作系统文件路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/;</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\regular expression.pdf&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><h3 id="1-5-5-匹配-id"><a href="#1-5-5-匹配-id" class="headerlink" title="1.5.5. 匹配 id"></a>1.5.5. 匹配 id</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 解决之道，可以使用惰性匹配：</span><br><span class="line">var regex = /id=&quot;.*?&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br></pre></td></tr></table></figure><p>当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;[^&quot;]*&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br><span class="line">// 思考：id里有特殊字符呢。</span><br></pre></td></tr></table></figure><h1 id="2-第二章-正则表达式位置匹配攻略"><a href="#2-第二章-正则表达式位置匹配攻略" class="headerlink" title="2. 第二章 正则表达式位置匹配攻略"></a>2. 第二章 正则表达式位置匹配攻略</h1><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p><h2 id="2-2-如何匹配位置呢？"><a href="#2-2-如何匹配位置呢？" class="headerlink" title="2.2. 如何匹配位置呢？"></a>2.2. 如何匹配位置呢？</h2><p>在 ES5 中，共有 6 个锚：<br>^、$、\b、\B、(?=p)、(?!p)</p><h3 id="2-2-1-和"><a href="#2-2-1-和" class="headerlink" title="2.2.1. ^ 和 $"></a>2.2.1. ^ 和 $</h3><p>^（脱字符）匹配开头，在多行匹配中匹配行开头。<br>$（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p><h3 id="2-2-2-b-和-B"><a href="#2-2-2-b-和-B" class="headerlink" title="2.2.2. \b 和 \B"></a>2.2.2. \b 和 \B</h3><p>\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。<br>比如考察文件名 “[JS] Lesson_01.mp4” 中的 \b，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\b/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></pre></td></tr></table></figure></p><p>\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。<br>具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。<br>比如上面的例子，把所有 \B 替换成 “#”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\B/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-p-和-p"><a href="#2-2-3-p-和-p" class="headerlink" title="2.2.3. (?=p) 和 (?!p)"></a>2.2.3. (?=p) 和 (?!p)</h3><p>(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。<br>比如 (?=l)，表示 “l” 字符前面的位置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;he#l#lo&quot;</span><br></pre></td></tr></table></figure></p><p>而 (?!p) 就是 (?=p) 的反面意思，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#h#ell#o#&quot;</span><br></pre></td></tr></table></figure></p><p>二者的学名分别是 positive lookahead 和 negative lookahead。<br>中文翻译分别是正向先行断言和负向先行断言。<br>ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。<br>具体是 (?&lt;=p) 和 (?&lt;!p)。<br>也有书上把这四个东西，翻译成环视，即看看右边和看看左边。<br>但一般书上，没有很好强调这四者是个位置。<br>比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。<br><strong>而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。</strong></p><h2 id="2-3-位置的特性"><a href="#2-3-位置的特性" class="headerlink" title="2.3. 位置的特性"></a>2.3. 位置的特性</h2><p><strong>对于位置的理解，我们可以理解成空字符 “”。</strong><br>也等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /^^hello$$$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>甚至可以写成更复杂的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /(?=he)^^he(?=\w)llo$\b\b$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>也就是说字符之间的位置，可以写成多个。</p><p><strong>TIP 把位置理解空字符，是对位置非常有效的理解方式。</strong></p><h2 id="2-4-相关案例"><a href="#2-4-相关案例" class="headerlink" title="2.4. 相关案例"></a>2.4. 相关案例</h2><h3 id="2-4-1-不匹配任何东西的正则"><a href="#2-4-1-不匹配任何东西的正则" class="headerlink" title="2.4.1. 不匹配任何东西的正则"></a>2.4.1. 不匹配任何东西的正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.^/</span><br></pre></td></tr></table></figure><h3 id="2-4-2-数字的千位分隔符表示法"><a href="#2-4-2-数字的千位分隔符表示法" class="headerlink" title="2.4.2 数字的千位分隔符表示法"></a>2.4.2 数字的千位分隔符表示法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。</span><br><span class="line">var regex = /(?!^)(?=(\d&#123;3&#125;)+$)/g;</span><br><span class="line">var result = &quot;12345678&quot;.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678&quot;</span><br><span class="line">result = &quot;123456789&quot;.replace(regex, &apos;,&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;123,456,789&quot;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/lxchuan12/html5/blob/gh-pages/JS%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/5.2%E3%80%81%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D.html" target="_blank" rel="noopener">github上 demo 5.2、添加千分位</a></p><p><a href="https://idiotwu.me/milli-formatting-digitals-with-regex/" target="_blank" rel="noopener">千位分隔符的完整攻略</a></p><h4 id="2-4-2-4-支持其他形式"><a href="#2-4-2-4-支持其他形式" class="headerlink" title="2.4.2.4. 支持其他形式"></a>2.4.2.4. 支持其他形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345678 123456789&quot;,</span><br><span class="line">regex = /(?!\b)(?=(\d&#123;3&#125;)+\b)/g;</span><br><span class="line">var result = string.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678 123,456,789&quot;</span><br></pre></td></tr></table></figure><p>其中 (?!\b) 怎么理解呢？<br>要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。<br>因此最终正则变成了：/\B(?=(\d{3})+\b)/g。</p><h4 id="2-4-2-5-格式化"><a href="#2-4-2-5-格式化" class="headerlink" title="2.4.2.5. 格式化"></a>2.4.2.5. 格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function format (num) &#123;</span><br><span class="line">return num.toFixed(2).replace(/\B(?=(\d&#123;3&#125;)+\b)/g, &quot;,&quot;).replace(/^/, &quot;$$ &quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log( format(1888) );</span><br><span class="line">// =&gt; &quot;$ 1,888.00&quot;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-验证密码问题（TODO-Read-again）"><a href="#2-4-3-验证密码问题（TODO-Read-again）" class="headerlink" title="2.4.3. 验证密码问题（TODO Read again）"></a>2.4.3. 验证密码问题（TODO Read again）</h3><p>密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。<br>此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。<br>那么，我们就来挑战一下。看看我们对位置的理解是否深刻。<br>（(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。）</p><p>// 扩展： 密码中必须包含字母、数字、特称字符，至少8个字符，最多30个字符。</p><p><a href="https://segmentfault.com/q/1010000007500712/a-1020000007500959" target="_blank" rel="noopener">Array.apply(null, {length: 10})和Array(10)有什么区别?</a></p><p><a href="https://segmentfault.com/q/1010000006793990" target="_blank" rel="noopener">关于apply，Array.apply(null, {length:5})怎么理解</a></p><h1 id="第三章-正则表达式括号的作用"><a href="#第三章-正则表达式括号的作用" class="headerlink" title="第三章 正则表达式括号的作用"></a>第三章 正则表达式括号的作用</h1><p><strong>NOTE</strong> match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的<br>内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match<br>返回的数组格式是不一样的。</p><h3 id="3-2-1-提取数据"><a href="#3-2-1-提取数据" class="headerlink" title="3.2.1. 提取数据"></a>3.2.1. 提取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 提取日期</span><br><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">console.log( regex.exec(string) );  // 这里的结果一样。</span><br><span class="line">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span><br></pre></td></tr></table></figure><p>同时，也可以使用构造函数的全局属性 $1 至 $9 来获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">//regex.exec(string);</span><br><span class="line">//string.match(regex);</span><br><span class="line">console.log(RegExp.$1); // &quot;2017&quot;</span><br><span class="line">console.log(RegExp.$2); // &quot;06&quot;</span><br><span class="line">console.log(RegExp.$3); // &quot;12&quot;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-替换"><a href="#3-2-2-替换" class="headerlink" title="3.2.2. 替换"></a>3.2.2. 替换</h3><p>比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">var result = string.replace(regex, &quot;$2/$3/$1&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;06/12/2017&quot;</span><br></pre></td></tr></table></figure></p><p>其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result = string.replace(regex, function () &#123;</span><br><span class="line">return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 也等价于</span><br><span class="line">var result = string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">return month + &quot;/&quot; + day + &quot;/&quot; + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h2 id="3-3-反向引用"><a href="#3-3-反向引用" class="headerlink" title="3.3. 反向引用"></a>3.3. 反向引用</h2><p>除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。(\1,\2)这类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = &quot;2017-06-12&quot;;</span><br><span class="line">var string2 = &quot;2017/06/12&quot;;</span><br><span class="line">var string3 = &quot;2017.06.12&quot;;</span><br><span class="line">var string4 = &quot;2016-06/12&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // true</span><br><span class="line">console.log( regex.test(string4) ); // false</span><br></pre></td></tr></table></figure></p><h3 id="3-3-1-括号嵌套怎么办？"><a href="#3-3-1-括号嵌套怎么办？" class="headerlink" title="3.3.1. 括号嵌套怎么办？"></a>3.3.1. 括号嵌套怎么办？</h3><p>以左括号（开括号）为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = &quot;1231231233&quot;;</span><br><span class="line">console.log( regex.test(string) ); // true</span><br><span class="line">console.log( RegExp.$1 ); // 123</span><br><span class="line">console.log( RegExp.$2 ); // 1</span><br><span class="line">console.log( RegExp.$3 ); // 23</span><br><span class="line">console.log( RegExp.$4 ); // 3</span><br></pre></td></tr></table></figure></p><p><a href="https://regexper.com/#%5E((%5Cd" target="_blank" rel="noopener">该正则图形化</a>(%5Cd(%5Cd)))%5C1%5C2%5C3%5C4%24)</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">在线正则测试</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((\d)(\d([a-z])))\1\2\3\4$</span><br><span class="line">12a12a12aa</span><br></pre></td></tr></table></figure></p><h3 id="3-3-2-10-表示什么呢？"><a href="#3-3-2-10-表示什么呢？" class="headerlink" title="3.3.2. \10 表示什么呢？"></a>3.3.2. \10 表示什么呢？</h3><p>另外一个疑问可能是，即 \10 是表示第 10 个分组，还是 \1 和 0 呢？<br>答案是前者，虽然一个正则里出现 \10 比较罕见。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;</span><br><span class="line">var string = &quot;123456789# ######&quot;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p><strong>TIP</strong> 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)。</p><h3 id="3-3-3-引用不存在的分组会怎样？"><a href="#3-3-3-引用不存在的分组会怎样？" class="headerlink" title="3.3.3. 引用不存在的分组会怎样？"></a>3.3.3. 引用不存在的分组会怎样？</h3><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配<br>反向引用的字符本身。例如 \2，就匹配 “\2”。注意 “\2” 表示对 “2” 进行了转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(&quot;\1\2\3\4\5\6\7\8\9&quot;) );</span><br><span class="line">console.log( &quot;\1\2\3\4\5\6\7\8\9&quot;.split(&quot;&quot;) );</span><br><span class="line">// Chrome 浏览器打印的结果（不同的浏览器和版本，打印的结果可能不一样）</span><br></pre></td></tr></table></figure></p><h3 id="3-3-4-分组后面有量词会怎样？"><a href="#3-3-4-分组后面有量词会怎样？" class="headerlink" title="3.3.4. 分组后面有量词会怎样？"></a>3.3.4. 分组后面有量词会怎样？</h3><p>分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+/;</span><br><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p><p>同理对于反向引用，也是这样的。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+ \1/;</span><br><span class="line">console.log( regex.test(&quot;12345 1&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( regex.test(&quot;12345 5&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h2 id="3-4-非捕获括号"><a href="#3-4-非捕获括号" class="headerlink" title="3.4. 非捕获括号"></a>3.4. 非捕获括号</h2><p>之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分<br>支。<br>如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。<br>此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)。</p><h2 id="3-5-相关案例"><a href="#3-5-相关案例" class="headerlink" title="3.5. 相关案例"></a>3.5. 相关案例</h2><h3 id="3-5-1-字符串-trim-方法模拟"><a href="#3-5-1-字符串-trim-方法模拟" class="headerlink" title="3.5.1. 字符串 trim 方法模拟"></a>3.5.1. 字符串 trim 方法模拟</h3><p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim(str) &#123;</span><br><span class="line">return str.replace(/^\s+|\s+$/g, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar&quot;</span><br></pre></td></tr></table></figure></p><p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim (str) &#123;</span><br><span class="line">return str.replace(/^\s*(.*?)\s*$/g, &quot;$1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar</span><br></pre></td></tr></table></figure></p><p>当然，前者效率高。</p><h3 id="3-5-2-将每个单词的首字母转换为大写"><a href="#3-5-2-将每个单词的首字母转换为大写" class="headerlink" title="3.5.2. 将每个单词的首字母转换为大写"></a>3.5.2. 将每个单词的首字母转换为大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unction titleize (str) &#123;</span><br><span class="line">    return str.toLowerCase().replace(/(?:^|\s)\w/g, function (c) &#123;</span><br><span class="line">        return c.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(&apos;my name is epeli&apos;) );</span><br><span class="line">// =&gt; &quot;My Name Is Epeli&quot;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-驼峰化"><a href="#3-5-3-驼峰化" class="headerlink" title="3.5.3. 驼峰化"></a>3.5.3. 驼峰化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function camelize (str) &#123;</span><br><span class="line">    return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123;</span><br><span class="line">        return c ? c.toUpperCase() : &apos;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(&apos;-moz-transform&apos;) );</span><br><span class="line">// =&gt; &quot;MozTransform&quot;</span><br><span class="line">// 这里c不需要判断。&apos;&apos;.toUpperCase() === &apos;&apos;; // true</span><br></pre></td></tr></table></figure><h3 id="3-5-4-中划线化"><a href="#3-5-4-中划线化" class="headerlink" title="3.5.4. 中划线化"></a>3.5.4. 中划线化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function dasherize (str) &#123;</span><br><span class="line">    return str.replace(/([A-Z])/g, &apos;-$1&apos;).replace(/[-_\s]+/g, &apos;-&apos;).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">console.log( dasherize(&apos;MozTransform&apos;) );</span><br><span class="line">// =&gt; &quot;-moz-transform&quot;</span><br></pre></td></tr></table></figure><h3 id="3-5-5-HTML-转义和反转义"><a href="#3-5-5-HTML-转义和反转义" class="headerlink" title="3.5.5. HTML 转义和反转义"></a>3.5.5. HTML 转义和反转义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 将HTML特殊字符转换成等值的实体</span><br><span class="line">function escapeHTML (str) &#123;</span><br><span class="line">    var escapeChars = &#123;</span><br><span class="line">    &apos;&lt;&apos; : &apos;lt&apos;,</span><br><span class="line">    &apos;&gt;&apos; : &apos;gt&apos;,</span><br><span class="line">    &apos;&quot;&apos; : &apos;quot&apos;,</span><br><span class="line">    &apos;&amp;&apos; : &apos;amp&apos;,</span><br><span class="line">    &apos;\&apos;&apos; : &apos;#39&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(new RegExp(&apos;[&apos; + Object.keys(escapeChars).join(&apos;&apos;) +&apos;]&apos;, &apos;g&apos;),</span><br><span class="line">    function (match) &#123;</span><br><span class="line">        return &apos;&amp;&apos; + escapeChars[match] + &apos;;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( escapeHTML(&apos;&lt;div&gt;Blah blah blah&lt;/div&gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;;</span><br></pre></td></tr></table></figure><p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。<br>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 实体字符转换为等值的HTML。</span><br><span class="line">function unescapeHTML (str) &#123;</span><br><span class="line">    var htmlEntities = &#123;</span><br><span class="line">        nbsp: &apos; &apos;,</span><br><span class="line">        lt: &apos;&lt;&apos;,</span><br><span class="line">        gt: &apos;&gt;&apos;,</span><br><span class="line">        quot: &apos;&quot;&apos;,</span><br><span class="line">        amp: &apos;&amp;&apos;,</span><br><span class="line">        apos: &apos;\&apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(/\&amp;([^;]+);/g, function (match, key) &#123;</span><br><span class="line">        if (key in htmlEntities) &#123;</span><br><span class="line">            return htmlEntities[key];</span><br><span class="line">        &#125;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure></p><p>通过 key 获取相应的分组引用，然后作为对象的键。</p><h3 id="3-5-6-匹配成对标签"><a href="#3-5-6-匹配成对标签" class="headerlink" title="3.5.6. 匹配成对标签"></a>3.5.6. 匹配成对标签</h3><p>要求匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line">&lt;p&gt;laoyao bye bye&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;，<br>匹配一个闭标签，可以使用 &lt;\/[^&gt;]+&gt;，<br>但是要求匹配成对标签，那就需要使用反向引用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;</span><br><span class="line">var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;</span><br><span class="line">var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // false</span><br></pre></td></tr></table></figure></p><p><strong>疑惑</strong>：为什么这里没有用.<em>匹配呢，或者说为啥没用.</em>?阻止贪婪匹配模式（惰性模式）呢</p><h1 id="4-第四章-正则表达式回溯法原理"><a href="#4-第四章-正则表达式回溯法原理" class="headerlink" title="4. 第四章 正则表达式回溯法原理"></a>4. 第四章 正则表达式回溯法原理</h1><p>学习正则表达式，是需要懂点儿匹配原理的。<br>而研究匹配原理时，有两个字出现的频率比较高：“回溯”。</p><h2 id="4-1-没有回溯的匹配"><a href="#4-1-没有回溯的匹配" class="headerlink" title="4.1. 没有回溯的匹配"></a>4.1. 没有回溯的匹配</h2><p>假设我们的正则是 /ab{1,3}c/，<br>而当目标字符串是 “abbbc” 时，就没有所谓的“回溯”。</p><h2 id="4-2-有回溯的匹配"><a href="#4-2-有回溯的匹配" class="headerlink" title="4.2. 有回溯的匹配"></a>4.2. 有回溯的匹配</h2><p>如果目标字符串是”abbc”，中间就有回溯。</p><p>图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 “b”，准备尝试第三个时，<br>结果发现接下来的字符是 “c”。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即<br>第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 “c”。当然，此时整个表达式匹配成功了。<br>图中的第 6 步，就是“回溯”。</p><p>再举一个例子：<br>/ab{1,3}bbc/</p><p>目标字符串是”abbbc”，匹配过程是：<br>/“.*”/<br>目标字符串是：”abc”de，</p><p>图中省略了尝试匹配双引号失败的过程。可以看出 .<em> 是非常影响效率的。<br>为了减少一些不必要的回溯，可以把正则修改为 /“[^”]</em>“/。</p><h2 id="4-3-常见的回溯形式"><a href="#4-3-常见的回溯形式" class="headerlink" title="4.3. 常见的回溯形式"></a>4.3. 常见的回溯形式</h2><p>正则表达式匹配字符串的这种方式，有个学名，叫<strong>回溯法</strong>。</p><p>本质上就是<strong>深度优先搜索算法</strong>。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中<br>，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。<br>道理，我们是懂了。<strong>那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？</strong></p><h3 id="4-3-1-贪婪量词"><a href="#4-3-1-贪婪量词" class="headerlink" title="4.3.1 贪婪量词"></a>4.3.1 贪婪量词</h3><p>之前的例子都是贪婪量词相关的。</p><p>此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？<br>答案是，先下手为强！因为深度优先搜索。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">var regex = /(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="4-3-2-惰性量词"><a href="#4-3-2-惰性量词" class="headerlink" title="4.3.2 惰性量词"></a>4.3.2 惰性量词</h3><p>虽然惰性量词不贪，但也会有回溯的现象。<br>比如正则式：/^\d{1,3}?\d{1,3}$/<br>目标字符串是 “12345”。</p><p>知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \d{1,3}? 匹配的字<br>符是 “12”，是两个数字，而不是一个。</p><h3 id="4-3-3-分支结构"><a href="#4-3-3-分支结构" class="headerlink" title="4.3.3 分支结构"></a>4.3.3 分支结构</h3><p>我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 “candy”，得到的结果是 “can”，因为分支会<br>一个一个尝试，如果前面的满足了，后面就不会再试验了。<br>分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分<br>支。这种尝试也可以看成一种回溯。</p><p>比如：/^(?:can|candy)$/ 目标字符串是’candy’</p><p>上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是<br>一种回溯的。</p><h2 id="4-4-本章小结"><a href="#4-4-本章小结" class="headerlink" title="4.4. 本章小结"></a>4.4. 本章小结</h2><p>其实回溯法，很容易掌握的。<br>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最<br>后都试完后，发现整体匹配不成功。</p><blockquote><p>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。<br>• 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。<br>• 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。<br>既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动<br>机”的简写。<br>而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。<br>大部分语言中的正则都是 NFA，为啥它这么流行呢？<br>答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。</p></blockquote><h1 id="5-第五章-正则表达式的拆分"><a href="#5-第五章-正则表达式的拆分" class="headerlink" title="5. 第五章 正则表达式的拆分"></a>5. 第五章 正则表达式的拆分</h1><h2 id="5-1-结构和操作符"><a href="#5-1-结构和操作符" class="headerlink" title="5.1. 结构和操作符"></a>5.1. 结构和操作符</h2><p>JavaScript 正则表达式中，都有哪些结构呢？<br>字符字面量、字符组、量词、锚、分组、选择分支、反向引用。</p><p><strong>其中涉及到的操作符有：</strong><br>操作符描述 操作符 优先级<br>转义符  \  1<br>括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2<br>量词限定符 {m}、{m,n}、{m,}、?、*、+ 3<br>位置和序列 ^、$、\元字符、一般字符 4<br>管道符（竖杠） | 5</p><h2 id="5-2-注意要点"><a href="#5-2-注意要点" class="headerlink" title="5.2. 注意要点"></a>5.2. 注意要点</h2><h3 id="5-2-1-匹配字符串整体问题"><a href="#5-2-1-匹配字符串整体问题" class="headerlink" title="5.2.1 匹配字符串整体问题"></a>5.2.1 匹配字符串整体问题</h3><p>比如要匹配目标字符串 “abc” 或者 “bcd” 时，如果一不小心，就会写成 /^abc|bcd$/。<br>而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是。</p><p>开始-abc<br>bcd-结束<br>应该是：<br>/^(abc|bcd)$/</p><h3 id="5-2-2-量词连缀问题"><a href="#5-2-2-量词连缀问题" class="headerlink" title="5.2.2 量词连缀问题"></a>5.2.2 量词连缀问题</h3><ol><li>每个字符为 “a、”b”、”c” 任选其一，</li><li>字符串的长度是 3 的倍数。<br><code>/^[abc]{3}+$/</code>，这样会报错，说 + 前面没什么可重复的。<br>应该为：<br>/([abc]{3})+/</li></ol><h3 id="5-2-3-元字符转义问题"><a href="#5-2-3-元字符转义问题" class="headerlink" title="5.2.3 元字符转义问题"></a>5.2.3 元字符转义问题</h3><p>所谓元字符，就是正则中有特殊含义的字符。<br>所有结构里，用到的元字符总结如下：<br>^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,<br>当匹配上面的字符本身时，可以一律转义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,/;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>其中 string 中的 \ 字符也要转义的。<br>另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var string2 = &quot;\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,&quot;;</span><br><span class="line">console.log( string == string2 );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>现在的问题是，是不是每个字符都需要转义呢？否，看情况。</p><h4 id="5-2-3-1-字符组中的元字符"><a href="#5-2-3-1-字符组中的元字符" class="headerlink" title="5.2.3.1. 字符组中的元字符"></a>5.2.3.1. 字符组中的元字符</h4><p>跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然<br>会把整个字符组，看成反义字符组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /[\^$.*+?|\\/\[\]&#123;&#125;=!:\-,]/g;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;,</span><br><span class="line">&quot;-&quot;, &quot;,&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="5-2-3-2-匹配-“-abc-”-和-“-3-5-”"><a href="#5-2-3-2-匹配-“-abc-”-和-“-3-5-”" class="headerlink" title="5.2.3.2. 匹配 “[abc]” 和 “{3,5}”"></a>5.2.3.2. 匹配 “[abc]” 和 “{3,5}”</h4><p>我们知道 [abc]，是个字符组。如果要匹配字符串 “[abc]” 时，该怎么办？<br>可以写成 /[abc]/，也可以写成 /[abc]/<br>只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。</p><p>同理，要匹配字符串 “{3,5}”，只需要把正则写成 /{3,5}/ 即可。<br>另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报<br>错。当然，匹配的字符串也是 “{,n}”，测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;&#123;,3&#125;&quot;;</span><br><span class="line">var regex = /&#123;,3&#125;/g;</span><br><span class="line">console.log( string.match(regex)[0] );</span><br><span class="line">// =&gt; &quot;&#123;,3&#125;&quot;</span><br></pre></td></tr></table></figure></p><h4 id="5-2-3-3-其余情况"><a href="#5-2-3-3-其余情况" class="headerlink" title="5.2.3.3. 其余情况"></a>5.2.3.3. 其余情况</h4><p>比如 =、!、:、-、, 等符号，只要不在特殊结构中，并不需要转义。<br>但是，括号需要前后都转义的，如 /(123)/。<br>至于剩下的 ^、$、.、*、+、?、|、\、/ 等字符，只要不在字符组内，都需要转义的。</p><h2 id="5-3-案例分析"><a href="#5-3-案例分析" class="headerlink" title="5.3. 案例分析"></a>5.3. 案例分析</h2><h3 id="5-3-1-身份证"><a href="#5-3-1-身份证" class="headerlink" title="5.3.1 身份证"></a>5.3.1 身份证</h3><p>正则表达式是：<br>/^(\d{15}|\d{17}[\dxX])$/</p><h3 id="5-3-2-IPV4-地址"><a href="#5-3-2-IPV4-地址" class="headerlink" title="5.3.2 IPV4 地址"></a>5.3.2 IPV4 地址</h3><p>正则表达式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)&#123;3&#125;(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/</span><br></pre></td></tr></table></figure></p><p>这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：<br>((…).){3}(…)<br>其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是<br>3位数.3位数.3位数.3位数<br>然后再来分析 (…)：<br>(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])</p><h1 id="6-第六章-正则表达式的构建"><a href="#6-第六章-正则表达式的构建" class="headerlink" title="6. 第六章 正则表达式的构建"></a>6. 第六章 正则表达式的构建</h1><h2 id="6-1-平衡法则"><a href="#6-1-平衡法则" class="headerlink" title="6.1. 平衡法则"></a>6.1. 平衡法则</h2><p>构建正则有一点非常重要，需要做到下面几点的平衡：<br>1.• 匹配预期的字符串<br>2.• 不匹配非预期的字符串<br>3.• 可读性和可维护性<br>4.• 效率</p><h2 id="6-2-构建正则前提"><a href="#6-2-构建正则前提" class="headerlink" title="6.2. 构建正则前提"></a>6.2. 构建正则前提</h2><p>比如匹配这样的字符串：1010010001…。<br>虽然很有规律，但是只靠正则就是无能为力。</p><h3 id="6-2-2-是否有必要使用正则？"><a href="#6-2-2-是否有必要使用正则？" class="headerlink" title="6.2.2. 是否有必要使用正则？"></a>6.2.2. 是否有必要使用正则？</h3><p>要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。<strong>能用字符串 API 解决的简单问题，就不该正则出马。</strong></p><p>比如，从日期中提取出年月日，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var regex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;]</span><br></pre></td></tr></table></figure></p><p>其实，可以使用字符串的 split 方法来做，即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var result = string.split(&quot;-&quot;);</span><br><span class="line">console.log( result );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]</span><br></pre></td></tr></table></figure></p><p>比如，判断是否有问号，虽然可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.search(/\?/) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p><p>其实，可以使用字符串的 indexOf 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.indexOf(&quot;?&quot;) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p><p>比如获取子串，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.match(/.&#123;4&#125;(.+)/)[1] );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p><p>其实，可以直接使用字符串的 substring 或 substr 方法（语言精粹中推荐使用slice,substr是在ES5规范附则里。）来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.substring(4) );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p><h3 id="6-2-3-是否有必要构建一个复杂的正则？"><a href="#6-2-3-是否有必要构建一个复杂的正则？" class="headerlink" title="6.2.3. 是否有必要构建一个复杂的正则？"></a>6.2.3. 是否有必要构建一个复杂的正则？</h3><p>6.2.3. 是否有必要构建一个复杂的正则？<br>比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字<br>符。<br>在第2章里，我们写出了正则是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">其实可以使用多个小正则来做：</span><br><span class="line">var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;</span><br><span class="line">var regex2 = /^[0-9]&#123;6,12&#125;$/;</span><br><span class="line">var regex3 = /^[A-Z]&#123;6,12&#125;$/;</span><br><span class="line">var regex4 = /^[a-z]&#123;6,12&#125;$/;</span><br><span class="line">function checkPassword (string) &#123;</span><br><span class="line">    if (!regex1.test(string)) return false;</span><br><span class="line">    if (regex2.test(string)) return false;</span><br><span class="line">    if (regex3.test(string)) return false;</span><br><span class="line">    if (regex4.test(string)) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-准确性"><a href="#6-3-准确性" class="headerlink" title="6.3. 准确性"></a>6.3. 准确性</h2><p>所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。<br>这里提到了“预期”二字，那么我们就需要知道目标的组成规则。</p><h3 id="6-3-1-匹配固定电话"><a href="#6-3-1-匹配固定电话" class="headerlink" title="6.3.1. 匹配固定电话"></a>6.3.1. 匹配固定电话</h3><p>比如要匹配如下格式的固定电话号码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">055188888888</span><br><span class="line">0551-88888888</span><br><span class="line">(0551)88888888</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(0\d&#123;2,3&#125;-?|\(0\d&#123;2,3&#125;\))[1-9]\d&#123;6,7&#125;$/</span><br></pre></td></tr></table></figure><p>这就是一个平衡取舍问题，一般够用就行。</p><h3 id="6-3-2-匹配浮点数"><a href="#6-3-2-匹配浮点数" class="headerlink" title="6.3.2. 匹配浮点数"></a>6.3.2. 匹配浮点数</h3><p>要求匹配如下的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.23、+1.23、-1.23</span><br><span class="line">10、+10、-10</span><br><span class="line">.2、+.2、-.2</span><br></pre></td></tr></table></figure></p><p>上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：<br>/^[+-]?(\d+)?(.\d+)?$/<br>此正则看似没问题，但这个正则也会匹配空字符 “”。<br>因为目标字符串的形式关系不是要求每部分都是可选的。<br>/^[+-]?(\d+.\d+|\d+|.\d+)$/</p><h2 id="6-4-效率"><a href="#6-4-效率" class="headerlink" title="6.4. 效率"></a>6.4. 效率</h2><p>保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正<br>则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。<br>正则表达式的运行分为如下的阶段：</p><p>• 1. 编译；<br>• 2. 设定起始位置；<br>• 3. 尝试匹配；<br>• 4. 匹配失败的话，从下一位开始继续第 3 步；<br>• 5. 最终结果：匹配成功或失败</p><p>当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。<br>但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。</p><h3 id="6-4-1-使用具体型字符组来代替通配符，来消除回溯"><a href="#6-4-1-使用具体型字符组来代替通配符，来消除回溯" class="headerlink" title="6.4.1. 使用具体型字符组来代替通配符，来消除回溯"></a>6.4.1. 使用具体型字符组来代替通配符，来消除回溯</h3><p>而在第三阶段，最大的问题就是回溯。<br>因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。</p><h3 id="6-4-2-使用非捕获型分组"><a href="#6-4-2-使用非捕获型分组" class="headerlink" title="6.4.2. 使用非捕获型分组"></a>6.4.2. 使用非捕获型分组</h3><p>因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。<br>当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。</p><h3 id="6-4-3-独立出确定字符"><a href="#6-4-3-独立出确定字符" class="headerlink" title="6.4.3. 独立出确定字符"></a>6.4.3. 独立出确定字符</h3><p>例如，/a+/ 可以修改成 /aa*/。</p><h3 id="6-4-4-提取分支公共部分"><a href="#6-4-4-提取分支公共部分" class="headerlink" title="6.4.4. 提取分支公共部分"></a>6.4.4. 提取分支公共部分</h3><p>比如，<code>/^abc|^def/</code> 修改成 <code>/^(?:abc|def)/</code>。<br>又比如， /this|that/修改成 /th(?:is|at)/。<br>这样做，可以减少匹配过程中可消除的重复。</p><h3 id="6-4-5-减少分支的数量，缩小它们的范围"><a href="#6-4-5-减少分支的数量，缩小它们的范围" class="headerlink" title="6.4.5. 减少分支的数量，缩小它们的范围"></a>6.4.5. 减少分支的数量，缩小它们的范围</h3><p>/red|read/ 可以修改成 /rea?d/。<br>此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。</p><h1 id="7-第七章-正则表达式编程"><a href="#7-第七章-正则表达式编程" class="headerlink" title="7. 第七章 正则表达式编程"></a>7. 第七章 正则表达式编程</h1><h2 id="7-1-正则表达式的四种操作"><a href="#7-1-正则表达式的四种操作" class="headerlink" title="7.1. 正则表达式的四种操作"></a>7.1. 正则表达式的四种操作</h2><p>正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。<br>有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。</p><h3 id="7-1-1-验证"><a href="#7-1-1-验证" class="headerlink" title="7.1.1. 验证"></a>7.1.1. 验证</h3><p>比如，判断一个字符串中是否有数字。<br>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!~string.search(regex) );</span><br><span class="line">// ~0 === -1</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure><p>使用 match：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!string.match(regex) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>使用 exec：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!regex.exec(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><p>其中，最常用的是 test。</p><h3 id="7-1-2-切分"><a href="#7-1-2-切分" class="headerlink" title="7.1.2. 切分"></a>7.1.2. 切分</h3><p>匹配上了，我们就可以进行一些操作，比如切分。<br>所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。</p><h3 id="7-1-3-提取"><a href="#7-1-3-提取" class="headerlink" title="7.1.3. 提取"></a>7.1.3. 提取</h3><p>虽然整体匹配上了，但有时需要提取部分匹配的数据。<br>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。<br>这里，还是以日期为例，提取出年月日。注意下面正则中的括号：<br>使用 match：<br>使用 exec：<br>使用 test：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">regex.test(string);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p><p>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">string.search(regex);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p><p>使用 replace：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">var date = [];</span><br><span class="line">string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">date.push(year, month, day);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(date);</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span><br></pre></td></tr></table></figure></p><p>其中，最常用的是 match。</p><h3 id="7-1-4-替换"><a href="#7-1-4-替换" class="headerlink" title="7.1.4. 替换"></a>7.1.4. 替换</h3><p>找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。</p><h2 id="7-2-相关-API-注意要点"><a href="#7-2-相关-API-注意要点" class="headerlink" title="7.2. 相关 API 注意要点"></a>7.2. 相关 API 注意要点</h2><p>从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String#search</span><br><span class="line">String#split</span><br><span class="line">String#match</span><br><span class="line">String#replace</span><br><span class="line">RegExp#test</span><br><span class="line">RegExp#exec</span><br></pre></td></tr></table></figure></p><h3 id="7-2-1-search-和-match-的参数问题"><a href="#7-2-1-search-和-match-的参数问题" class="headerlink" title="7.2.1. search 和 match 的参数问题"></a>7.2.1. search 和 match 的参数问题</h3><p>我们知道字符串实例的那 4 个方法参数都支持正则和字符串。<br>但 search 和 match，会把字符串转换为正则的。<br>replace和split不会。</p><h3 id="7-2-2-match-返回结果的格式问题"><a href="#7-2-2-match-返回结果的格式问题" class="headerlink" title="7.2.2. match 返回结果的格式问题"></a>7.2.2. match 返回结果的格式问题</h3><p>match 返回结果的格式，与正则对象是否有修饰符 g 有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017.06.27&quot;;</span><br><span class="line">var regex1 = /\b(\d+)\b/;</span><br><span class="line">var regex2 = /\b(\d+)\b/g;</span><br><span class="line">console.log( string.match(regex1) );</span><br><span class="line">console.log( string.match(regex2) );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;]</span><br></pre></td></tr></table></figure></p><p>没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然<br>后是整体匹配的第一个下标，最后是输入的目标字符串。<br>有 g，返回的是所有匹配的内容。<br>当没有匹配时，不管有无 g，都返回 null。</p><h3 id="7-2-3-exec-比-match-更强大"><a href="#7-2-3-exec-比-match-更强大" class="headerlink" title="7.2.3. exec 比 match 更强大"></a>7.2.3. exec 比 match 更强大</h3><p>当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。<br>而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配：<br>其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。<br>比如第一次匹配了 “2017”，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配<br>的位置是 4。<br>从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环：</p><h3 id="7-2-4-修饰符-g，对-exex-和-test-的影响"><a href="#7-2-4-修饰符-g，对-exex-和-test-的影响" class="headerlink" title="7.2.4. 修饰符 g，对 exex 和 test 的影响"></a>7.2.4. 修饰符 g，对 exex 和 test 的影响</h3><p>上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。<br><strong>字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。</strong><br>而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。</p><h3 id="7-2-5-test-整体匹配时需要使用-和"><a href="#7-2-5-test-整体匹配时需要使用-和" class="headerlink" title="7.2.5. test 整体匹配时需要使用 ^ 和 $"></a>7.2.5. test 整体匹配时需要使用 ^ 和 $</h3><p>这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。<br>如果，要整体匹配，正则前后需要添加开头和结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log( /123/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">console.log( /^123$/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( /^123$/.test(&quot;123&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-2-6-split-相关注意事项"><a href="#7-2-6-split-相关注意事项" class="headerlink" title="7.2.6. split 相关注意事项"></a>7.2.6. split 相关注意事项</h3><p>split 方法看起来不起眼，但要注意的地方有两个的。<br>第一，它可以有第二个参数，表示结果数组的最大长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/,/, 2) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;css&quot;]</span><br></pre></td></tr></table></figure></p><p>第二，正则使用分组时，结果数组中是包含分隔符的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/(,)/) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="7-2-7-replace-是很强大的"><a href="#7-2-7-replace-是很强大的" class="headerlink" title="7.2.7. replace 是很强大的"></a>7.2.7. replace 是很强大的</h3><p>《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。<br>因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。<br>总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。<br>当第二个参数是字符串时，如下的字符有特殊的含义：</p><p><pre><br>属性 描述<br>$1,$2,…,$99 匹配第 1-99 个 分组里捕获的文本<br>$&amp; 匹配到的子串文本<br>$` 匹配到的子串的左边文本<br>$’ 匹配到的子串的右边文本<br>$$ 美元符号<br>记忆中语言精粹中有列举更多。<br></pre><br>再例如，把 “2+3=5”，变成 “2+3=2+3=5=5”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;2+3=2+3=5=5</span><br></pre></td></tr></table></figure></p><p>我们对最后这个进行一下说明。要把 “2+3=5”，变成 “2+3=2+3=5=5”，其实就是想办法把 = 替换成<br>=2+3=5=，其中，$&amp; 匹配的是 =， $<code>匹配的是 2+3，$&#39; 匹配的是 5。因此使用 &quot;$&amp;$</code>$&amp;$’$&amp;” 便达成了<br>目的。<br>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;1234 2345 3456&quot;.replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123;</span><br><span class="line">console.log([match, $1, $2, index, input]);</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;]</span><br></pre></td></tr></table></figure></p><p>此时我们可以看到 replace 拿到的信息，并不比 exec 少。</p><h3 id="7-2-8-使用构造函数需要注意的问题"><a href="#7-2-8-使用构造函数需要注意的问题" class="headerlink" title="7.2.8. 使用构造函数需要注意的问题"></a>7.2.8. 使用构造函数需要注意的问题</h3><p>一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 <code>\</code>。</p><h3 id="7-2-9-修饰符"><a href="#7-2-9-修饰符" class="headerlink" title="7.2.9. 修饰符"></a>7.2.9. 修饰符</h3><p><code>ES5</code> 中修饰符，共 3 个：g,i,m<br>当然正则对象也有相应的只读属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\w/img;</span><br><span class="line">console.log( regex.global );</span><br><span class="line">console.log( regex.ignoreCase );</span><br><span class="line">console.log( regex.multiline );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-2-10-source-属性"><a href="#7-2-10-source-属性" class="headerlink" title="7.2.10. source 属性"></a>7.2.10. source 属性</h3><p>正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source<br>属性。<br>它什么时候有用呢？<br>比如，<strong>在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var className = &quot;high&quot;;</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">console.log( regex.source )</span><br><span class="line">// =&gt; (^|\s)high(\s|$) 即字符串&quot;(^|\\s)high(\\s|$)&quot;</span><br></pre></td></tr></table></figure></p><h3 id="7-2-11-构造函数属性"><a href="#7-2-11-构造函数属性" class="headerlink" title="7.2.11. 构造函数属性"></a>7.2.11. 构造函数属性</h3><p>构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的<br>属性（有兼容性问题）：</p><p><pre><br>静态属性 描述 简写形式<br>RegExp.input 最近一次目标字符串 RegExp[“$_”]<br>RegExp.lastMatch 最近一次匹配的文本 RegExp[“$&amp;”]<br>RegExp.lastParen 最近一次捕获的文本 RegExp[“$+”]<br>RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”]<br>RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[“$’”]<br></pre></p><h2 id="7-3-真实案例"><a href="#7-3-真实案例" class="headerlink" title="7.3. 真实案例"></a>7.3. 真实案例</h2><h3 id="7-3-1-使用构造函数生成正则表达式"><a href="#7-3-1-使用构造函数生成正则表达式" class="headerlink" title="7.3.1. 使用构造函数生成正则表达式"></a>7.3.1. 使用构造函数生成正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3333&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function getElementsByClassName (className) &#123;</span><br><span class="line">var elements = document.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var i = 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">var element = elements[i];</span><br><span class="line">if (regex.test(element.className)) &#123;</span><br><span class="line">result.push(element)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">var highs = getElementsByClassName(&apos;high&apos;);</span><br><span class="line">highs.forEach(function (item) &#123;</span><br><span class="line">item.style.color = &apos;red&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-使用字符串保存数据"><a href="#7-3-2-使用字符串保存数据" class="headerlink" title="7.3.2. 使用字符串保存数据"></a>7.3.2. 使用字符串保存数据</h3><p>一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。<br>使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var utils = &#123;&#125;;</span><br><span class="line">&quot;Boolean|Number|String|Function|Array|Date|RegExp|Object|Error&quot;.split(&quot;|&quot;).forEach(fun</span><br><span class="line">ction (item) &#123;</span><br><span class="line">utils[&quot;is&quot; + item] = function (obj) &#123;</span><br><span class="line">return &#123;&#125;.toString.call(obj) == &quot;[object &quot; + item + &quot;]&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log( utils.isArray([1, 2, 3]) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><h3 id="7-3-3-if-语句中使用正则替代-amp-amp"><a href="#7-3-3-if-语句中使用正则替代-amp-amp" class="headerlink" title="7.3.3. if 语句中使用正则替代 &amp;&amp;"></a>7.3.3. if 语句中使用正则替代 &amp;&amp;</h3><p>比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var readyRE = /complete|loaded|interactive/;</span><br><span class="line">function ready (callback) &#123;</span><br><span class="line">if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">document.addEventListener(</span><br><span class="line">&apos;DOMContentLoaded&apos;,</span><br><span class="line">function () &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;,</span><br><span class="line">false</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ready(function () &#123;</span><br><span class="line">alert(&quot;加载完毕！&quot;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="7-3-4-使用强大的-replace"><a href="#7-3-4-使用强大的-replace" class="headerlink" title="7.3.4. 使用强大的 replace"></a>7.3.4. 使用强大的 replace</h3><p>因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。<br>这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何<br>东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function compress (source) &#123;</span><br><span class="line">var keys = &#123;&#125;;</span><br><span class="line">source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123;</span><br><span class="line">keys[key] = (keys[key] ? keys[key] + &apos;,&apos; : &apos;&apos;) + value;</span><br><span class="line">&#125;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var key in keys) &#123;</span><br><span class="line">result.push(key + &apos;=&apos; + keys[key]);</span><br><span class="line">&#125;</span><br><span class="line">return result.join(&apos;&amp;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;) );</span><br><span class="line">// =&gt; &quot;a=1,3&amp;b=2,4&quot;</span><br></pre></td></tr></table></figure></p><p>完。<br>84/89</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jex.im/regulex/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则可视化工具&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://regexper.com/#jsah&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>github使用小技巧</title>
    <link href="https://lxchuan12.github.io/posts/e70430df.html"/>
    <id>https://lxchuan12.github.io/posts/e70430df.html</id>
    <published>2017-09-21T15:15:52.000Z</published>
    <updated>2019-02-10T14:29:24.458Z</updated>
    
    <content type="html"><![CDATA[<p>大多数开发者都有github账号，但github这些日常小技巧估计不知道。<br>1、<a href="https://github.com/explore/subscribe" target="_blank" rel="noopener">subscribe订阅github周报，每周会把你关注的开发语言和关注的人的动态等发邮件给你：</a><br><a href="https://github.com/trending" target="_blank" rel="noopener">每天github的热点</a><br>2、快捷键：在github某个项目面板（页面），按shift+?，可以看到所有支持的快捷键。<br>其中常用的主要有。</p><blockquote><p>T，搜索文件<br>S:定位到搜索输入框<br>GC:跳转到code面板<br>GI:跳转到issue面板<br>GP:跳转到 pull request面板<br>GW:跳转到 Wiki<br>搜索issue和pull request时可以使用过滤器。比如：is:open<br>回答输入时，可以用#号来匹配相应的issue.<br>3、Code Line<br>可以标注一些代码。按住shift,选择行号。对应的代码就高亮了。对应链接加上了hash#L1-L21<br>4、<a href="https://github.com/buunguyen/octotree" target="_blank" rel="noopener">octotree chrome插件github</a>可以像编辑器目录文件形式。<br><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="noopener">octotree chrome插件地址</a><br>如果翻墙苦难，可以直接下载dist目录下chrome.crx，拖拽到chrome浏览器插件即可安装。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数开发者都有github账号，但github这些日常小技巧估计不知道。&lt;br&gt;1、&lt;a href=&quot;https://github.com/explore/subscribe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;subscribe订阅githu
      
    
    </summary>
    
      <category term="github" scheme="https://lxchuan12.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://lxchuan12.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象所有API解析</title>
    <link href="https://lxchuan12.github.io/posts/bed2369d.html"/>
    <id>https://lxchuan12.github.io/posts/bed2369d.html</id>
    <published>2017-08-17T15:51:52.000Z</published>
    <updated>2019-02-10T14:29:24.543Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000010753942" target="_blank" rel="noopener">首发于segmentfault:JavaScript 对象所有API解析</a></p><blockquote><p>之前看到<a href="http://louiszhai.github.io/2017/04/28/array/" target="_blank" rel="noopener">【深度长文】JavaScript数组所有API全解密</a>和<a href="http://louiszhai.github.io/2016/01/12/js.String/" target="_blank" rel="noopener">JavaScript字符串所有API全解密</a>这两篇高质量的文章。发现没写对象API解析（估计是博主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。</p></blockquote><p>创建对象的两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">var o = &#123;&#125;; // 推荐</span><br></pre></td></tr></table></figure></p><p>该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object(&apos;something&apos;);</span><br><span class="line">o.constructor; // ƒ String() &#123; [native code] &#125;</span><br><span class="line">var n = new Object(123);</span><br><span class="line">n.constructor; // ƒ Number() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、Object构造器的成员"><a href="#一、Object构造器的成员" class="headerlink" title="一、Object构造器的成员"></a>一、Object构造器的成员</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>该属性是所有对象的原型（包括 <code>Object</code>对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;xuanyuan&apos;);</span><br><span class="line">Object.prototype.custom = 1;</span><br><span class="line">console.log(s.custom); // 1</span><br></pre></td></tr></table></figure></p><h2 id="二、Object-prototype-的成员"><a href="#二、Object-prototype-的成员" class="headerlink" title="二、Object.prototype 的成员"></a>二、Object.prototype 的成员</h2><h3 id="Object-prototype-constructor"><a href="#Object-prototype-constructor" class="headerlink" title="Object.prototype.constructor"></a>Object.prototype.constructor</h3><p>该属性指向用来构造该函数对象的构造器，在这里为<code>Object()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.constructor === Object; // true</span><br><span class="line">var o = new Object();</span><br><span class="line">o.constructor === Object; // true</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-toString-radix"><a href="#Object-prototype-toString-radix" class="headerlink" title="Object.prototype.toString(radix)"></a>Object.prototype.toString(radix)</h3><p>该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数<code>radix</code>，该参数<code>radix</code>，该参数的默认值为10。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop:1&#125;;</span><br><span class="line">o.toString(); // &apos;[object object]&apos;</span><br><span class="line">var n = new Number(255);</span><br><span class="line">n.toString(); // &apos;255&apos;</span><br><span class="line">n.toString(16); // &apos;ff&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p>该方法的作用与<code>toString()</code>基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如<code>Date()</code>,<code>Number()</code>,<code>Array()</code>,它们的值都会以本地化的形式输出。当然，对于包括<code>Object()</code>在内的其他大多数对象来说，该方法与<code>toString()</code>是基本相同的。<br>在浏览器环境下，可以通过<code>BOM</code>对象<code>Navigator</code>的<code>language</code>属性（在<code>IE</code>中则是<code>userLanguage</code>）来了解当前所使用的语言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.language; //&apos;en-US&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p>该方法返回的是用基本类型所表示的<code>this</code>值，如果它可以用基本类型表示的话。如果<code>Number</code>对象返回的是它的基本数值，而<code>Date</code>对象返回的是一个时间戳（<code>timestamp</code>）。如果无法用基本数据类型表示，该方法会返回<code>this</code>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Object</span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">typeof o.valueOf(); // &apos;object&apos;</span><br><span class="line">o.valueOf() === o; // true</span><br><span class="line">// Number</span><br><span class="line">var n = new Number(101);</span><br><span class="line">typeof n; // &apos;object&apos;</span><br><span class="line">typeof n.vauleOf; // &apos;function&apos;</span><br><span class="line">typeof n.valueOf(); // &apos;number&apos;</span><br><span class="line">n.valueOf() === n; // false</span><br><span class="line">// Date</span><br><span class="line">var d = new Date();</span><br><span class="line">typeof d.valueOf(); // &apos;number&apos;</span><br><span class="line">d.valueOf(); // 1503146772355</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-hasOwnProperty-prop"><a href="#Object-prototype-hasOwnProperty-prop" class="headerlink" title="Object.prototype.hasOwnProperty(prop)"></a>Object.prototype.hasOwnProperty(prop)</h3><p>该方法仅在目标属性为对象自身属性时返回<code>true</code>,而当该属性是从原型链中继承而来或根本不存在时，返回<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop:1&#125;;</span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;); // true</span><br><span class="line">o.hasOwnProperty(&apos;toString&apos;); // false</span><br><span class="line">o.hasOwnProperty(&apos;formString&apos;); // false</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-isPrototypeOf-obj"><a href="#Object-prototype-isPrototypeOf-obj" class="headerlink" title="Object.prototype.isPrototypeOf(obj)"></a>Object.prototype.isPrototypeOf(obj)</h3><p>如果目标对象是当前对象的原型，该方法就会返回<code>true</code>，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;&apos;);</span><br><span class="line">Object.prototype.isPrototypeOf(s); // true</span><br><span class="line">String.prototype.isPrototypeOf(s); // true</span><br><span class="line">Array.prototype.isPrototypeOf(s); // false</span><br></pre></td></tr></table></figure></p><h3 id="Object-prototype-propertyIsEnumerable-prop"><a href="#Object-prototype-propertyIsEnumerable-prop" class="headerlink" title="Object.prototype.propertyIsEnumerable(prop)"></a>Object.prototype.propertyIsEnumerable(prop)</h3><p>如果目标属性能在<code>for in</code>循环中被显示出来，该方法就返回<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.propertyIsEnumerable(&apos;length&apos;); // false</span><br><span class="line">a.propertyIsEnumerable(0); // true</span><br></pre></td></tr></table></figure></p><h2 id="三、在ES5中附加的Object属性"><a href="#三、在ES5中附加的Object属性" class="headerlink" title="三、在ES5中附加的Object属性"></a>三、在<code>ES5</code>中附加的<code>Object</code>属性</h2><p>在<code>ES3</code>中，除了一些内置属性（如：<code>Math.PI</code>），对象的所有的属性在任何时候都可以被修改、插入、删除。在<code>ES5</code>中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。<code>ES5</code>中引入了<strong>属性描述符</strong>的概念，我们可以通过它对所定义的属性有更大的控制权。这些<strong>属性描述符</strong>（特性）包括：</p><blockquote><p><code>value</code>——当试图获取属性时所返回的值。<br><code>writable</code>——该属性是否可写。<br><code>enumerable</code>——该属性在<code>for in</code>循环中是否会被枚举<br><code>configurable</code>——该属性是否可被删除。<br><code>set()</code>——该属性的更新操作所调用的函数。<br><code>get()</code>——获取属性值时所调用的函数。<br>另外，<strong>数据描述符</strong>（其中属性为：<code>enumerable</code>，<code>configurable</code>，<code>value</code>，<code>writable</code>）与<strong>存取描述符</strong>（其中属性为<code>enumerable</code>，<code>configurable</code>，<code>set()</code>，<code>get()</code>）之间是有互斥关系的。在定义了<code>set()</code>和<code>get()</code>之后，描述符会认为存取操作已被 定义了，其中再定义<code>value</code>和<code>writable</code>会<strong>引起错误</strong>。<br>以下是<em>ES3</em>风格的属性定义方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.legs = 2;</span><br></pre></td></tr></table></figure></p></blockquote><p>以下是等价的ES5通过<strong>数据描述符</strong>定义属性的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其中， 除了value的默认值为<code>undefined</code>以外，其他的默认值都为<code>false</code>。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为<code>true</code>。<br>或者，我们也可以通过<code>ES5</code>的存储描述符来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;, &#123;</span><br><span class="line">    set:function(v) &#123;</span><br><span class="line">        return this.value = v;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function(v) &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br><span class="line">person.legs = 2;</span><br></pre></td></tr></table></figure></p><p>这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容<code>ES3</code>方面所做的考虑。例如，跟添加<code>Array.prototype</code>属性不一样，我们不能再旧版的浏览器中使用<code>shim</code>这一特性。<br>另外，我们还可以（通过定义<code>nonmalleable</code>属性），在具体行为中运用这些描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &apos;heads&apos;, &#123;value: 1&#125;);</span><br><span class="line">person.heads = 0; // 0</span><br><span class="line">person.heads; // 1  (改不了)</span><br><span class="line">delete person.heads; // false</span><br><span class="line">person.heads // 1 (删不掉)</span><br></pre></td></tr></table></figure></p><h3 id="Object-defineProperty-obj-prop-descriptor-ES5"><a href="#Object-defineProperty-obj-prop-descriptor-ES5" class="headerlink" title="Object.defineProperty(obj, prop, descriptor) (ES5)"></a>Object.defineProperty(obj, prop, descriptor) (ES5)</h3><p>具体用法可参见上文，或者查看MDN。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN Object.defineProperty(obj, descriptor)</a></p><blockquote><p>Vue.js文档：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener"><strong>如何追踪变化</strong></a> 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote><h3 id="Object-defineProperties-obj-props-ES5"><a href="#Object-defineProperties-obj-props-ES5" class="headerlink" title="Object.defineProperties(obj, props) (ES5)"></a>Object.defineProperties(obj, props) (ES5)</h3><p>该方法的作用与<code>defineProperty()</code>基本相同，只不过它可以用来一次定义多个属性。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var glass = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    &apos;color&apos;: &#123;</span><br><span class="line">        value: &apos;transparent&apos;,</span><br><span class="line">        writable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;fullness&apos;: &#123;</span><br><span class="line">        value: &apos;half&apos;,</span><br><span class="line">        writable: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">glass.fullness; // &apos;half&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getPrototypeOf-obj-ES5"><a href="#Object-getPrototypeOf-obj-ES5" class="headerlink" title="Object.getPrototypeOf(obj) (ES5)"></a>Object.getPrototypeOf(obj) (ES5)</h3><p>之前在<code>ES3</code>中，我们往往需要通过<code>Object.prototype.isPrototypeOf()</code>去猜测某个给定的对象的原型是什么，如今在<code>ES5</code>中，我们可以直接询问改对象“你的原型是什么？”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf([]) === Array.prototype; // true</span><br><span class="line">Object.getPrototypeOf(Array.prototype) === Object.prototype; // true</span><br><span class="line">Object.getPrototypeOf(Object.prototype) === null; // true</span><br></pre></td></tr></table></figure></p><h3 id="Object-create-obj-descr-ES5"><a href="#Object-create-obj-descr-ES5" class="headerlink" title="Object.create(obj, descr) (ES5)"></a>Object.create(obj, descr) (ES5)</h3><p>该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;hi: &apos;Hello&apos;&#125;;</span><br><span class="line">var o = Object.create(parent, &#123;</span><br><span class="line">    prop: &#123;</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.hi; // &apos;Hello&apos;</span><br><span class="line">// 获得它的原型</span><br><span class="line">Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototype</span><br><span class="line">Object.getPrototypeOf(o); // &#123;hi: &quot;Hello&quot;&#125; // 说明o的原型是&#123;hi: &quot;Hello&quot;&#125;</span><br><span class="line">o.hasOwnProperty(&apos;hi&apos;); // false 说明hi是原型上的</span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;); // true 说明prop是原型上的自身上的属性。</span><br></pre></td></tr></table></figure></p><p>现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在<code>ES3</code>中可是做不到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o = Object.create(null);</span><br><span class="line">typeof o.toString(); // &apos;undefined&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertyDesciptor-obj-property-ES5"><a href="#Object-getOwnPropertyDesciptor-obj-property-ES5" class="headerlink" title="Object.getOwnPropertyDesciptor(obj, property) (ES5)"></a>Object.getOwnPropertyDesciptor(obj, property) (ES5)</h3><p>该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</span><br><span class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertyNames-obj-ES5"><a href="#Object-getOwnPropertyNames-obj-ES5" class="headerlink" title="Object.getOwnPropertyNames(obj) (ES5)"></a>Object.getOwnPropertyNames(obj) (ES5)</h3><p>该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用<code>Object.keys()</code>来单独返回可枚举的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(Object.prototype);</span><br><span class="line">// [&quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;]</span><br><span class="line">Object.keys(Object.prototype);</span><br><span class="line">// []</span><br><span class="line">Object.getOwnPropertyNames(Object);</span><br><span class="line">// [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;prototype&quot;, &quot;assign&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getOwnPropertyDescriptors&quot;, &quot;getOwnPropertyNames&quot;, &quot;getOwnPropertySymbols&quot;, &quot;is&quot;, &quot;preventExtensions&quot;, &quot;seal&quot;, &quot;create&quot;, &quot;defineProperties&quot;, &quot;defineProperty&quot;, &quot;freeze&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;isFrozen&quot;, &quot;isSealed&quot;, &quot;keys&quot;, &quot;entries&quot;, &quot;values&quot;]</span><br><span class="line">Object.keys(Object);</span><br><span class="line">// []</span><br></pre></td></tr></table></figure></p><h3 id="Object-preventExtensions-obj-ES5"><a href="#Object-preventExtensions-obj-ES5" class="headerlink" title="Object.preventExtensions(obj) (ES5)"></a>Object.preventExtensions(obj) (ES5)</h3><h3 id="Object-isExtensible-obj-ES5"><a href="#Object-isExtensible-obj-ES5" class="headerlink" title="Object.isExtensible(obj) (ES5)"></a>Object.isExtensible(obj) (ES5)</h3><p><code>preventExtensions()</code>方法用于禁止向某一对象添加更多属性，而<code>isExtensible()</code>方法则用于检查某对象是否还可以被添加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var deadline = &#123;&#125;;</span><br><span class="line">Object.isExtensible(deadline); // true</span><br><span class="line">deadline.date = &apos;yesterday&apos;; // &apos;yesterday&apos;</span><br><span class="line">Object.preventExtensions(deadline);</span><br><span class="line">Object.isExtensible(deadline); // false</span><br><span class="line">deadline.date = &apos;today&apos;;</span><br><span class="line">deadline.date; // &apos;today&apos;</span><br><span class="line">// 尽管向某个不可扩展的对象中添加属性不算是一个错误操作，但它没有任何作用。</span><br><span class="line">deadline.report = true;</span><br><span class="line">deadline.report; // undefined</span><br></pre></td></tr></table></figure></p><h3 id="Object-seal-obj-ES5"><a href="#Object-seal-obj-ES5" class="headerlink" title="Object.seal(obj) (ES5)"></a>Object.seal(obj) (ES5)</h3><h3 id="Object-isSeal-obj-ES5"><a href="#Object-isSeal-obj-ES5" class="headerlink" title="Object.isSeal(obj) (ES5)"></a>Object.isSeal(obj) (ES5)</h3><p><code>seal()</code>方法可以让一个对象密封，并返回被密封后的对象。<br><code>seal()</code>方法的作用与<code>preventExtensions()</code>基本相同，但除此之外，它还会将现有属性<br>设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用<code>defineProperty()</code>）重新配置这些属性，例如不能将一个可枚举的属性改成不可枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;legs:2&#125;;</span><br><span class="line">// person === Object.seal(person); // true</span><br><span class="line">Object.isSealed(person); // true</span><br><span class="line">Object.getOwnPropertyDescriptor(person, &apos;legs&apos;);</span><br><span class="line">// &#123;value: 2, writable: true, enumerable: true, configurable: false&#125;</span><br><span class="line">delete person.legs; // false (不可删除，不可配置)</span><br><span class="line">Object.defineProperty(person, &apos;legs&apos;,&#123;value:2&#125;);</span><br><span class="line">person.legs; // 2</span><br><span class="line">person.legs = 1;</span><br><span class="line">person.legs; // 1 (可写)</span><br><span class="line">Object.defineProperty(person, &quot;legs&quot;, &#123; get: function() &#123; return &quot;legs&quot;; &#125; &#125;);</span><br><span class="line">// 抛出TypeError异常</span><br></pre></td></tr></table></figure></p><h3 id="Object-freeze-obj-ES5"><a href="#Object-freeze-obj-ES5" class="headerlink" title="Object.freeze(obj) (ES5)"></a>Object.freeze(obj) (ES5)</h3><h3 id="Object-isFrozen-obj-ES5"><a href="#Object-isFrozen-obj-ES5" class="headerlink" title="Object.isFrozen(obj) (ES5)"></a>Object.isFrozen(obj) (ES5)</h3><p><code>freeze()</code>方法用于执行一切不受<code>seal()</code>方法限制的属性值变更。<code>Object.freeze()</code> 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var deadline = Object.freeze(&#123;date: &apos;yesterday&apos;&#125;);</span><br><span class="line">deadline.date = &apos;tomorrow&apos;;</span><br><span class="line">deadline.excuse = &apos;lame&apos;;</span><br><span class="line">deadline.date; // &apos;yesterday&apos;</span><br><span class="line">deadline.excuse; // undefined</span><br><span class="line">Object.isSealed(deadline); // true;</span><br><span class="line">Object.isFrozen(deadline); // true</span><br><span class="line">Object.getOwnPropertyDescriptor(deadline, &apos;date&apos;);</span><br><span class="line">// &#123;value: &quot;yesterday&quot;, writable: false, enumerable: true, configurable: false&#125; (不可配置，不可写)</span><br><span class="line">Object.keys(deadline); // [&apos;date&apos;] (可枚举)</span><br></pre></td></tr></table></figure></p><h3 id="Object-keys-obj-ES5"><a href="#Object-keys-obj-ES5" class="headerlink" title="Object.keys(obj) (ES5)"></a>Object.keys(obj) (ES5)</h3><p>该方法是一种特殊的<code>for-in</code>循环。它只返回当前对象的属性（不像<code>for-in</code>），而且这些属性也必须是可枚举的（这点和<code>Object.getOwnPropertyNames()</code>不同，不论是否可以枚举）。返回值是一个字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.customProto = 101;</span><br><span class="line">Object.getOwnPropertyNames(Object.prototype);</span><br><span class="line">// [..., &quot;constructor&quot;, &quot;toLocaleString&quot;, &quot;isPrototypeOf&quot;, &quot;customProto&quot;]</span><br><span class="line">Object.keys(Object.prototype); // [&apos;customProto&apos;]</span><br><span class="line">var o = &#123;own: 202&#125;;</span><br><span class="line">o.customProto; // 101</span><br><span class="line">Object.keys(o); // [&apos;own&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="四、在ES6中附加的Object属性"><a href="#四、在ES6中附加的Object属性" class="headerlink" title="四、在ES6中附加的Object属性"></a>四、在<code>ES6</code>中附加的<code>Object</code>属性</h3><h3 id="Object-is-value1-value2-ES6"><a href="#Object-is-value1-value2-ES6" class="headerlink" title="Object.is(value1, value2) (ES6)"></a>Object.is(value1, value2) (ES6)</h3><p>该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。<br>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，而是<code>NaN</code>等于自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.is(&apos;xuanyuan&apos;, &apos;xuanyuan&apos;); // true</span><br><span class="line">Object.is(&#123;&#125;,&#123;&#125;); // false</span><br><span class="line">Object.is(+0, -0); // false</span><br><span class="line">+0 === -0; // true</span><br><span class="line">Object.is(NaN, NaN); // true</span><br><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure></p><p><code>ES5</code>可以通过以下代码部署<code>Object.is</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</span><br><span class="line">    value: function() &#123;x, y&#125; &#123;</span><br><span class="line">        if (x === y) &#123;</span><br><span class="line">           // 针对+0不等于-0的情况</span><br><span class="line">           return x !== 0 || 1 / x === 1 / y;</span><br><span class="line">        &#125;</span><br><span class="line">        // 针对 NaN的情况</span><br><span class="line">        return x !== x &amp;&amp; y !== y;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Object-assign-target-…sources-ES6"><a href="#Object-assign-target-…sources-ES6" class="headerlink" title="Object.assign(target, …sources) (ES6)"></a>Object.assign(target, …sources) (ES6)</h3><p>该方法用来源对象（<code>source</code>）的所有可枚举的属性复制到目标对象（<code>target</code>）。它至少需要两个对象作为参数，第一个参数是目标对象<code>target</code>，后面的参数都是源对象（<code>source</code>）。只有一个参数不是对象，就会抛出<code>TypeError</code>错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;a: 1&#125;;</span><br><span class="line">var source1 = &#123;b: 2&#125;;</span><br><span class="line">var source2 = &#123;c: 3&#125;;</span><br><span class="line">obj = Object.assign(target, source1, source2);</span><br><span class="line">target; // &#123;a:1,b:2,c:3&#125;</span><br><span class="line">obj; // &#123;a:1,b:2,c:3&#125;</span><br><span class="line">target === obj; // true</span><br><span class="line">// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</span><br><span class="line">var source3 = &#123;a:2,b:3,c:4&#125;;</span><br><span class="line">Object.assign(target, source3);</span><br><span class="line">target; // &#123;a:2,b:3,c:4&#125;</span><br></pre></td></tr></table></figure></p><p><code>Object.assign</code>只复制自身属性，不可枚举的属性（<code>enumerable</code>为<code>false</code>）和继承的属性不会被复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;b: &apos;c&apos;&#125;, </span><br><span class="line">    Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123;</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: &apos;hello&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">// &#123;b: &apos;c&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>属性名为<code>Symbol</code>值的属性，也会被<code>Object.assign()</code>复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;a: &apos;b&apos;&#125;, &#123;[Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</span><br><span class="line">// &#123;a: &apos;b&apos;, Symbol(c): &apos;d&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>对于嵌套的对象，<code>Object.assign()</code>的处理方法是替换，而不是添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;a: &#123;b:&apos;c&apos;,d:&apos;e&apos;&#125;&#125;, &#123;a:&#123;b:&apos;hello&apos;&#125;&#125;);</span><br><span class="line">// &#123;a: &#123;b:&apos;hello&apos;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>对于数组，<code>Object.assign()</code>把数组视为属性名为0、1、2的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1,2,3], [4,5]);</span><br><span class="line">// [4,5,3]</span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertySymbols-obj-ES6"><a href="#Object-getOwnPropertySymbols-obj-ES6" class="headerlink" title="Object.getOwnPropertySymbols(obj) (ES6)"></a>Object.getOwnPropertySymbols(obj) (ES6)</h3><p>该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 <code>symbol</code> 属性键。<br>该方法和 <code>Object.getOwnPropertyNames()</code> 类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertySymbols(&#123;a: &apos;b&apos;, [Symbol(&apos;c&apos;)]: &apos;d&apos;&#125;);</span><br><span class="line">// [Symbol(c)]</span><br></pre></td></tr></table></figure></p><h3 id="Object-setPrototypeOf-obj-prototype-ES6"><a href="#Object-setPrototypeOf-obj-prototype-ES6" class="headerlink" title="Object.setPrototypeOf(obj, prototype) (ES6)"></a>Object.setPrototypeOf(obj, prototype) (ES6)</h3><p>该方法设置一个指定的对象的原型 ( 即, 内部<code>[[Prototype]]</code>属性）到另一个对象或  <code>null</code>。<br><code>__proto__</code>属性用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括<code>IE11</code>）都部署了这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ES6写法</span><br><span class="line">var obj = &#123;</span><br><span class="line">    method: function()&#123;</span><br><span class="line">        // code ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// obj.__proto__ = someOtherObj;</span><br><span class="line">// ES5写法</span><br><span class="line">var obj = Object.create(someOtherObj);</span><br><span class="line">obj.method = function()&#123;</span><br><span class="line">    // code ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>该属性没有写入<code>ES6</code>的正文，而是写入了附录。<code>__proto__</code>前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。而是使用<code>Object.setPrototypeOf()</code>（写操作），<code>Object.getPrototypeOf()</code>（读操作），或<code>Object.create()</code>（生成操作）代替。<br>在实现上，<code>__proto__</code>调用的<code>Object.prototype.__proto__</code>。<br><code>Object.setPrototypeOf()</code>方法的作用与<code>__proto__</code>作用相同，用于设置一个对象的<code>prototype</code>对象。它是<code>ES6</code>正式推荐的设置原型对象的方法。</p><h2 id="五、在ES8中附加的Object属性"><a href="#五、在ES8中附加的Object属性" class="headerlink" title="五、在ES8中附加的Object属性"></a>五、在<code>ES8</code>中附加的<code>Object</code>属性</h2><h3 id="Object-getOwnPropertyDescriptors-obj-ES8"><a href="#Object-getOwnPropertyDescriptors-obj-ES8" class="headerlink" title="Object.getOwnPropertyDescriptors(obj) (ES8)"></a>Object.getOwnPropertyDescriptors(obj) (ES8)</h3><p>该方法基本与<code>Object.getOwnPropertyDescriptor(obj, property)</code>用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;);</span><br><span class="line">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ toString()&#125;</span><br><span class="line">Object.getOwnPropertyDescriptors(Object.prototype); // 可以自行在浏览器控制台查看效果。</span><br></pre></td></tr></table></figure></p><h3 id="Object-values-obj-ES8"><a href="#Object-values-obj-ES8" class="headerlink" title="Object.values(obj) (ES8)"></a>Object.values(obj) (ES8)</h3><p><code>Object.values()</code> 方法与<code>Object.keys</code>类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用<code>for...in</code>循环的顺序相同 ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">Object.values(obj); // [1,2,3]</span><br></pre></td></tr></table></figure></p><h3 id="Object-entries-obj-ES8"><a href="#Object-entries-obj-ES8" class="headerlink" title="Object.entries(obj) (ES8)"></a>Object.entries(obj) (ES8)</h3><p><code>Object.entries()</code> 方法返回一个给定对象自己的可枚举属性<code>[key，value]</code>对的数组，数组中键值对的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致（区别在于一个<code>for-in</code>循环也枚举原型链中的属性）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line">Object.keys(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">Object.values(obj); // [1,2,3]</span><br><span class="line">Object.entries(obj); // [[&apos;a&apos;,1],[&apos;b&apos;,2],[&apos;c&apos;,3]]</span><br></pre></td></tr></table></figure></p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>作者：常以<del>轩辕Rowboat</del><strong>若川</strong>为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。<br><a href="https://lxchuan12.github.io/">个人博客</a><br><a href="https://segmentfault.com/u/lxchuan12" target="_blank" rel="noopener">segmentfault个人主页</a><br><a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" rel="noopener">掘金个人主页</a><br><a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" rel="noopener">知乎</a><br><a href="https://github.com/lxchuan12" target="_blank" rel="noopener">github</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>您可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有<code>Object.prototype.toString()</code>，<code>Object.prototype.hasOwnProperty()</code>， <code>Object.getPrototypeOf(obj)</code>，<code>Object.create()</code>，<code>Object.defineProperty</code>，<code>Object.keys(obj)</code>，<code>Object.assign()</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN Object API</a><br><a href="https://book.douban.com/subject/26302623/" target="_blank" rel="noopener">JavaScript面向对象编程指南（第2版）（豆瓣读书链接）</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰 ES6标准入门2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010753942&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;首发于segmentfault:JavaScript 对象所有API解析&lt;/a&gt;&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="javascript" scheme="https://lxchuan12.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://lxchuan12.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
