<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaScript正则表达式迷你书-阅读笔记 | 轩辕Rowboat的博客 | 前端路上 | PPT爱好者 | 所知甚少，唯善学。常以轩辕Rowboat为名混迹于江湖。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="JavaScript">
    <meta name="description" content="正则可视化工具正则可视化工具-regexper正则在线测试工具-regex101 勘误：2.4.2.5. 格式化$ 1888.00 -&amp;gt; $ 1,888.00 3.3.1. 括号嵌套怎么办？最后的是 \4，找到第3个开括号  -&amp;gt; 最后的是 \4，找到第4个开括号 3.5.6. 匹配成对标签其中开标签 &amp;lt;[\^&amp;gt;]+&amp;gt; 改成 &amp;lt;([^&amp;gt;]+)&amp;gt;  -">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript正则表达式迷你书-阅读笔记">
<meta property="og:url" content="https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/index.html">
<meta property="og:site_name" content="轩辕Rowboat的博客">
<meta property="og:description" content="正则可视化工具正则可视化工具-regexper正则在线测试工具-regex101 勘误：2.4.2.5. 格式化$ 1888.00 -&amp;gt; $ 1,888.00 3.3.1. 括号嵌套怎么办？最后的是 \4，找到第3个开括号  -&amp;gt; 最后的是 \4，找到第4个开括号 3.5.6. 匹配成对标签其中开标签 &amp;lt;[\^&amp;gt;]+&amp;gt; 改成 &amp;lt;([^&amp;gt;]+)&amp;gt;  -">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-10-21T15:52:11.461Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript正则表达式迷你书-阅读笔记">
<meta name="twitter:description" content="正则可视化工具正则可视化工具-regexper正则在线测试工具-regex101 勘误：2.4.2.5. 格式化$ 1888.00 -&amp;gt; $ 1,888.00 3.3.1. 括号嵌套怎么办？最后的是 \4，找到第3个开括号  -&amp;gt; 最后的是 \4，找到第4个开括号 3.5.6. 匹配成对标签其中开标签 &amp;lt;[\^&amp;gt;]+&amp;gt; 改成 &amp;lt;([^&amp;gt;]+)&amp;gt;  -">
    
        <link rel="alternate" type="application/atom+xml" title="轩辕Rowboat的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script src="//cdnjs.cloudflare.com/ajax/libs/platform/1.3.5/platform.min.js"></script>
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/logo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">轩辕Rowboat</h5>
          <a href="mailto:lxchuan12@163.com" title="lxchuan12@163.com" class="mail">lxchuan12@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lxchuan12.github.io/2016/11/20/about-me/"  >
                <i class="icon icon-lg icon-user"></i>
                关于我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/57974dc55bbb500063f522fd/posts" target="_blank" >
                <i class="icon icon-lg icon-angle-double-down"></i>
                掘金
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://segmentfault.com/u/lxchuan12/" target="_blank" >
                <i class="icon icon-lg icon-hand-o-right"></i>
                Segmentfault
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lxchuan12" target="_blank" >
                <i class="icon icon-lg icon-github-alt"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://weibo.com/lxchuan12" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.zhihu.com/people/lxchuan12/activities" target="_blank" >
                <i class="icon icon-lg icon-connectdevelop"></i>
                知乎
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.jianshu.com/users/83129d433d72/latest_articles" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                简书
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaScript正则表达式迷你书-阅读笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaScript正则表达式迷你书-阅读笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-10-12T15:45:52.000Z" itemprop="datePublished" class="page-time">
  2017-10-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#勘误："><span class="post-toc-number">1.</span> <span class="post-toc-text">勘误：</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#记录一些学到的"><span class="post-toc-number">2.</span> <span class="post-toc-text">记录一些学到的</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-第一章-正则表达式字符匹配攻略"><span class="post-toc-number">3.</span> <span class="post-toc-text">1. 第一章 正则表达式字符匹配攻略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-1-范围表示法"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">1.2.1. 范围表示法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-3-常见的简写形式"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">1.2.3. 常见的简写形式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-2-贪婪匹配与惰性匹配"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">1.3.2. 贪婪匹配与惰性匹配</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-多选分支"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1.4. 多选分支</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-1-匹配-16-进制颜色值"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">1.5.1. 匹配 16 进制颜色值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-2-匹配时间"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">1.5.2. 匹配时间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-3-匹配日期"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">1.5.3. 匹配日期</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-4-window-操作系统文件路径"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">1.5.4. window 操作系统文件路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-5-匹配-id"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">1.5.5. 匹配 id</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-第二章-正则表达式位置匹配攻略"><span class="post-toc-number">4.</span> <span class="post-toc-text">2. 第二章 正则表达式位置匹配攻略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-如何匹配位置呢？"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">2.2. 如何匹配位置呢？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-1-和"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">2.2.1. ^ 和 $</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-2-b-和-B"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">2.2.2. \b 和 \B</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-3-p-和-p"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">2.2.3. (?=p) 和 (?!p)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-位置的特性"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">2.3. 位置的特性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-相关案例"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">2.4. 相关案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-1-不匹配任何东西的正则"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">2.4.1. 不匹配任何东西的正则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-2-数字的千位分隔符表示法"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">2.4.2 数字的千位分隔符表示法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-2-4-支持其他形式"><span class="post-toc-number">4.3.2.1.</span> <span class="post-toc-text">2.4.2.4. 支持其他形式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-2-5-格式化"><span class="post-toc-number">4.3.2.2.</span> <span class="post-toc-text">2.4.2.5. 格式化</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-3-验证密码问题（TODO-Read-again）"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">2.4.3. 验证密码问题（TODO Read again）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#第三章-正则表达式括号的作用"><span class="post-toc-number">5.</span> <span class="post-toc-text">第三章 正则表达式括号的作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-1-提取数据"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">3.2.1. 提取数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-2-替换"><span class="post-toc-number">5.0.2.</span> <span class="post-toc-text">3.2.2. 替换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-反向引用"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">3.3. 反向引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-1-括号嵌套怎么办？"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">3.3.1. 括号嵌套怎么办？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-2-10-表示什么呢？"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">3.3.2. \10 表示什么呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-3-引用不存在的分组会怎样？"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">3.3.3. 引用不存在的分组会怎样？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-4-分组后面有量词会怎样？"><span class="post-toc-number">5.1.4.</span> <span class="post-toc-text">3.3.4. 分组后面有量词会怎样？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-非捕获括号"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">3.4. 非捕获括号</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-5-相关案例"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">3.5. 相关案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-1-字符串-trim-方法模拟"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">3.5.1. 字符串 trim 方法模拟</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-2-将每个单词的首字母转换为大写"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">3.5.2. 将每个单词的首字母转换为大写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-3-驼峰化"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">3.5.3. 驼峰化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-4-中划线化"><span class="post-toc-number">5.3.4.</span> <span class="post-toc-text">3.5.4. 中划线化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-5-HTML-转义和反转义"><span class="post-toc-number">5.3.5.</span> <span class="post-toc-text">3.5.5. HTML 转义和反转义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-6-匹配成对标签"><span class="post-toc-number">5.3.6.</span> <span class="post-toc-text">3.5.6. 匹配成对标签</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-第四章-正则表达式回溯法原理"><span class="post-toc-number">6.</span> <span class="post-toc-text">4. 第四章 正则表达式回溯法原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-没有回溯的匹配"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">4.1. 没有回溯的匹配</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-有回溯的匹配"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">4.2. 有回溯的匹配</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-常见的回溯形式"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">4.3. 常见的回溯形式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-1-贪婪量词"><span class="post-toc-number">6.3.1.</span> <span class="post-toc-text">4.3.1 贪婪量词</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-2-惰性量词"><span class="post-toc-number">6.3.2.</span> <span class="post-toc-text">4.3.2 惰性量词</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-3-分支结构"><span class="post-toc-number">6.3.3.</span> <span class="post-toc-text">4.3.3 分支结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-4-本章小结"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">4.4. 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-第五章-正则表达式的拆分"><span class="post-toc-number">7.</span> <span class="post-toc-text">5. 第五章 正则表达式的拆分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-结构和操作符"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">5.1. 结构和操作符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-注意要点"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">5.2. 注意要点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-1-匹配字符串整体问题"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">5.2.1 匹配字符串整体问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-2-量词连缀问题"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">5.2.2 量词连缀问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-3-元字符转义问题"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">5.2.3 元字符转义问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-2-3-1-字符组中的元字符"><span class="post-toc-number">7.2.3.1.</span> <span class="post-toc-text">5.2.3.1. 字符组中的元字符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-2-3-2-匹配-“-abc-”-和-“-3-5-”"><span class="post-toc-number">7.2.3.2.</span> <span class="post-toc-text">5.2.3.2. 匹配 “[abc]” 和 “{3,5}”</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-2-3-3-其余情况"><span class="post-toc-number">7.2.3.3.</span> <span class="post-toc-text">5.2.3.3. 其余情况</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-案例分析"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">5.3. 案例分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-1-身份证"><span class="post-toc-number">7.3.1.</span> <span class="post-toc-text">5.3.1 身份证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-2-IPV4-地址"><span class="post-toc-number">7.3.2.</span> <span class="post-toc-text">5.3.2 IPV4 地址</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-第六章-正则表达式的构建"><span class="post-toc-number">8.</span> <span class="post-toc-text">6. 第六章 正则表达式的构建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-平衡法则"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">6.1. 平衡法则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-构建正则前提"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">6.2. 构建正则前提</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-2-是否有必要使用正则？"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">6.2.2. 是否有必要使用正则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-3-是否有必要构建一个复杂的正则？"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">6.2.3. 是否有必要构建一个复杂的正则？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-准确性"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">6.3. 准确性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-1-匹配固定电话"><span class="post-toc-number">8.3.1.</span> <span class="post-toc-text">6.3.1. 匹配固定电话</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-2-匹配浮点数"><span class="post-toc-number">8.3.2.</span> <span class="post-toc-text">6.3.2. 匹配浮点数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-4-效率"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">6.4. 效率</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-1-使用具体型字符组来代替通配符，来消除回溯"><span class="post-toc-number">8.4.1.</span> <span class="post-toc-text">6.4.1. 使用具体型字符组来代替通配符，来消除回溯</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-2-使用非捕获型分组"><span class="post-toc-number">8.4.2.</span> <span class="post-toc-text">6.4.2. 使用非捕获型分组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-3-独立出确定字符"><span class="post-toc-number">8.4.3.</span> <span class="post-toc-text">6.4.3. 独立出确定字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-4-提取分支公共部分"><span class="post-toc-number">8.4.4.</span> <span class="post-toc-text">6.4.4. 提取分支公共部分</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-5-减少分支的数量，缩小它们的范围"><span class="post-toc-number">8.4.5.</span> <span class="post-toc-text">6.4.5. 减少分支的数量，缩小它们的范围</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-第七章-正则表达式编程"><span class="post-toc-number">9.</span> <span class="post-toc-text">7. 第七章 正则表达式编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-1-正则表达式的四种操作"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">7.1. 正则表达式的四种操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-1-验证"><span class="post-toc-number">9.1.1.</span> <span class="post-toc-text">7.1.1. 验证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-2-切分"><span class="post-toc-number">9.1.2.</span> <span class="post-toc-text">7.1.2. 切分</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-3-提取"><span class="post-toc-number">9.1.3.</span> <span class="post-toc-text">7.1.3. 提取</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-4-替换"><span class="post-toc-number">9.1.4.</span> <span class="post-toc-text">7.1.4. 替换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-2-相关-API-注意要点"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">7.2. 相关 API 注意要点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-1-search-和-match-的参数问题"><span class="post-toc-number">9.2.1.</span> <span class="post-toc-text">7.2.1. search 和 match 的参数问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-2-match-返回结果的格式问题"><span class="post-toc-number">9.2.2.</span> <span class="post-toc-text">7.2.2. match 返回结果的格式问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-3-exec-比-match-更强大"><span class="post-toc-number">9.2.3.</span> <span class="post-toc-text">7.2.3. exec 比 match 更强大</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-4-修饰符-g，对-exex-和-test-的影响"><span class="post-toc-number">9.2.4.</span> <span class="post-toc-text">7.2.4. 修饰符 g，对 exex 和 test 的影响</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-5-test-整体匹配时需要使用-和"><span class="post-toc-number">9.2.5.</span> <span class="post-toc-text">7.2.5. test 整体匹配时需要使用 ^ 和 $</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-6-split-相关注意事项"><span class="post-toc-number">9.2.6.</span> <span class="post-toc-text">7.2.6. split 相关注意事项</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-7-replace-是很强大的"><span class="post-toc-number">9.2.7.</span> <span class="post-toc-text">7.2.7. replace 是很强大的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-8-使用构造函数需要注意的问题"><span class="post-toc-number">9.2.8.</span> <span class="post-toc-text">7.2.8. 使用构造函数需要注意的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-9-修饰符"><span class="post-toc-number">9.2.9.</span> <span class="post-toc-text">7.2.9. 修饰符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-10-source-属性"><span class="post-toc-number">9.2.10.</span> <span class="post-toc-text">7.2.10. source 属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-11-构造函数属性"><span class="post-toc-number">9.2.11.</span> <span class="post-toc-text">7.2.11. 构造函数属性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-3-真实案例"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">7.3. 真实案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-1-使用构造函数生成正则表达式"><span class="post-toc-number">9.3.1.</span> <span class="post-toc-text">7.3.1. 使用构造函数生成正则表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-2-使用字符串保存数据"><span class="post-toc-number">9.3.2.</span> <span class="post-toc-text">7.3.2. 使用字符串保存数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-3-if-语句中使用正则替代-amp-amp"><span class="post-toc-number">9.3.3.</span> <span class="post-toc-text">7.3.3. if 语句中使用正则替代 &amp;&amp;</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-4-使用强大的-replace"><span class="post-toc-number">9.3.4.</span> <span class="post-toc-text">7.3.4. 使用强大的 replace</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-20171012-JavaScript regex mini books reading record"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaScript正则表达式迷你书-阅读笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-10-12 23:45:52" datetime="2017-10-12T15:45:52.000Z"  itemprop="datePublished">2017-10-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">正则可视化工具</a><br><a href="https://regexper.com/#jsah" target="_blank" rel="noopener">正则可视化工具-regexper</a><br><a href="http://regex101.com/" target="_blank" rel="noopener">正则在线测试工具-regex101</a></p>
<h1 id="勘误："><a href="#勘误：" class="headerlink" title="勘误："></a>勘误：</h1><p>2.4.2.5. 格式化<br>$ 1888.00 -&gt; $ 1,888.00</p>
<p>3.3.1. 括号嵌套怎么办？<br>最后的是 \4，找到第3个开括号  -&gt; 最后的是 \4，找到第4个开括号</p>
<p>3.5.6. 匹配成对标签<br>其中开标签 &lt;[\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;  -&gt;  其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt;</p>
<p>5.1. 结构和操作符<br>在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构—&gt;按照原文：这里的因此应该不标红。</p>
<p>6.3.2. 匹配浮点数<br>因此整个正则是这三者的或的关系，提取公众部分后是：—-&gt;公共部分</p>
<p>[《JavaScript 正则表达式迷你书》问世了！]（<a href="https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social）</a></p>
<h1 id="记录一些学到的"><a href="#记录一些学到的" class="headerlink" title="记录一些学到的"></a>记录一些学到的</h1><h1 id="1-第一章-正则表达式字符匹配攻略"><a href="#1-第一章-正则表达式字符匹配攻略" class="headerlink" title="1. 第一章 正则表达式字符匹配攻略"></a>1. 第一章 正则表达式字符匹配攻略</h1><h3 id="1-2-1-范围表示法"><a href="#1-2-1-范围表示法" class="headerlink" title="1.2.1. 范围表示法"></a>1.2.1. 范围表示法</h3><p>因为连字符有特殊用途，那么要匹配 “a”、”-“、”z” 这三者中任意一个字符，该怎么做呢？<br>不能写成 [a-z]，因为其表示小写字符中的任何一个字符。<br>可以写成如下的方式：[-az] 或 [az-] 或 [a-z]。<br>即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</p>
<h3 id="1-2-3-常见的简写形式"><a href="#1-2-3-常见的简写形式" class="headerlink" title="1.2.3. 常见的简写形式"></a>1.2.3. 常见的简写形式</h3><p>如果要匹配任意字符怎么办？可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。</p>
<h3 id="1-3-2-贪婪匹配与惰性匹配"><a href="#1-3-2-贪婪匹配与惰性匹配" class="headerlink" title="1.3.2. 贪婪匹配与惰性匹配"></a>1.3.2. 贪婪匹配与惰性匹配</h3><p>其中 /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。</p>
<h2 id="1-4-多选分支"><a href="#1-4-多选分支" class="headerlink" title="1.4. 多选分支"></a>1.4. 多选分支</h2><p>但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 “goodbye” 字符串时，结果是 “good”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|goodbye/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;good&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /goodbye|good/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;goodbye&quot;]</span><br></pre></td></tr></table></figure>
<p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</p>
<h3 id="1-5-1-匹配-16-进制颜色值"><a href="#1-5-1-匹配-16-进制颜色值" class="headerlink" title="1.5.1. 匹配 16 进制颜色值"></a>1.5.1. 匹配 16 进制颜色值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line">var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-匹配时间"><a href="#1-5-2-匹配时间" class="headerlink" title="1.5.2. 匹配时间"></a>1.5.2. 匹配时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure>
<p>如果也要求匹配 “7:9”，也就是说时分前面的 “0” 可以省略。<br>此时正则变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;</span><br><span class="line">console.log( regex.test(&quot;23:59&quot;) );</span><br><span class="line">console.log( regex.test(&quot;02:07&quot;) );</span><br><span class="line">console.log( regex.test(&quot;7:9&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure>
<h3 id="1-5-3-匹配日期"><a href="#1-5-3-匹配日期" class="headerlink" title="1.5.3. 匹配日期"></a>1.5.3. 匹配日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line">console.log( regex.test(&quot;2017-06-10&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure>
<h3 id="1-5-4-window-操作系统文件路径"><a href="#1-5-4-window-操作系统文件路径" class="headerlink" title="1.5.4. window 操作系统文件路径"></a>1.5.4. window 操作系统文件路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/;</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\regular expression.pdf&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript\\regex\\&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\study\\javascript&quot;) );</span><br><span class="line">console.log( regex.test(&quot;F:\\&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure>
<h3 id="1-5-5-匹配-id"><a href="#1-5-5-匹配-id" class="headerlink" title="1.5.5. 匹配 id"></a>1.5.5. 匹配 id</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 解决之道，可以使用惰性匹配：</span><br><span class="line">var regex = /id=&quot;.*?&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br></pre></td></tr></table></figure>
<p>当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;[^&quot;]*&quot;/</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]);</span><br><span class="line">// =&gt; id=&quot;container&quot;</span><br><span class="line">// 思考：id里有特殊字符呢。</span><br></pre></td></tr></table></figure>
<h1 id="2-第二章-正则表达式位置匹配攻略"><a href="#2-第二章-正则表达式位置匹配攻略" class="headerlink" title="2. 第二章 正则表达式位置匹配攻略"></a>2. 第二章 正则表达式位置匹配攻略</h1><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p>
<h2 id="2-2-如何匹配位置呢？"><a href="#2-2-如何匹配位置呢？" class="headerlink" title="2.2. 如何匹配位置呢？"></a>2.2. 如何匹配位置呢？</h2><p>在 ES5 中，共有 6 个锚：<br>^、$、\b、\B、(?=p)、(?!p)</p>
<h3 id="2-2-1-和"><a href="#2-2-1-和" class="headerlink" title="2.2.1. ^ 和 $"></a>2.2.1. ^ 和 $</h3><p>^（脱字符）匹配开头，在多行匹配中匹配行开头。<br>$（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p>
<h3 id="2-2-2-b-和-B"><a href="#2-2-2-b-和-B" class="headerlink" title="2.2.2. \b 和 \B"></a>2.2.2. \b 和 \B</h3><p>\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。<br>比如考察文件名 “[JS] Lesson_01.mp4” 中的 \b，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\b/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></pre></td></tr></table></figure></p>
<p>\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。<br>具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。<br>比如上面的例子，把所有 \B 替换成 “#”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\B/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-p-和-p"><a href="#2-2-3-p-和-p" class="headerlink" title="2.2.3. (?=p) 和 (?!p)"></a>2.2.3. (?=p) 和 (?!p)</h3><p>(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。<br>比如 (?=l)，表示 “l” 字符前面的位置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;he#l#lo&quot;</span><br></pre></td></tr></table></figure></p>
<p>而 (?!p) 就是 (?=p) 的反面意思，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;#h#ell#o#&quot;</span><br></pre></td></tr></table></figure></p>
<p>二者的学名分别是 positive lookahead 和 negative lookahead。<br>中文翻译分别是正向先行断言和负向先行断言。<br>ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。<br>具体是 (?&lt;=p) 和 (?&lt;!p)。<br>也有书上把这四个东西，翻译成环视，即看看右边和看看左边。<br>但一般书上，没有很好强调这四者是个位置。<br>比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。<br><strong>而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。</strong></p>
<h2 id="2-3-位置的特性"><a href="#2-3-位置的特性" class="headerlink" title="2.3. 位置的特性"></a>2.3. 位置的特性</h2><p><strong>对于位置的理解，我们可以理解成空字符 “”。</strong><br>也等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /^^hello$$$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>甚至可以写成更复杂的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = /(?=he)^^he(?=\w)llo$\b\b$/.test(&quot;hello&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>也就是说字符之间的位置，可以写成多个。</p>
<p><strong>TIP 把位置理解空字符，是对位置非常有效的理解方式。</strong></p>
<h2 id="2-4-相关案例"><a href="#2-4-相关案例" class="headerlink" title="2.4. 相关案例"></a>2.4. 相关案例</h2><h3 id="2-4-1-不匹配任何东西的正则"><a href="#2-4-1-不匹配任何东西的正则" class="headerlink" title="2.4.1. 不匹配任何东西的正则"></a>2.4.1. 不匹配任何东西的正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.^/</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-数字的千位分隔符表示法"><a href="#2-4-2-数字的千位分隔符表示法" class="headerlink" title="2.4.2 数字的千位分隔符表示法"></a>2.4.2 数字的千位分隔符表示法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。</span><br><span class="line">var regex = /(?!^)(?=(\d&#123;3&#125;)+$)/g;</span><br><span class="line">var result = &quot;12345678&quot;.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678&quot;</span><br><span class="line">result = &quot;123456789&quot;.replace(regex, &apos;,&apos;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;123,456,789&quot;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/lxchuan12/html5/blob/gh-pages/JS%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/5.2%E3%80%81%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D.html" target="_blank" rel="noopener">github上 demo 5.2、添加千分位</a></p>
<p><a href="https://idiotwu.me/milli-formatting-digitals-with-regex/" target="_blank" rel="noopener">千位分隔符的完整攻略</a></p>
<h4 id="2-4-2-4-支持其他形式"><a href="#2-4-2-4-支持其他形式" class="headerlink" title="2.4.2.4. 支持其他形式"></a>2.4.2.4. 支持其他形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345678 123456789&quot;,</span><br><span class="line">regex = /(?!\b)(?=(\d&#123;3&#125;)+\b)/g;</span><br><span class="line">var result = string.replace(regex, &apos;,&apos;)</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;12,345,678 123,456,789&quot;</span><br></pre></td></tr></table></figure>
<p>其中 (?!\b) 怎么理解呢？<br>要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。<br>因此最终正则变成了：/\B(?=(\d{3})+\b)/g。</p>
<h4 id="2-4-2-5-格式化"><a href="#2-4-2-5-格式化" class="headerlink" title="2.4.2.5. 格式化"></a>2.4.2.5. 格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function format (num) &#123;</span><br><span class="line">return num.toFixed(2).replace(/\B(?=(\d&#123;3&#125;)+\b)/g, &quot;,&quot;).replace(/^/, &quot;$$ &quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log( format(1888) );</span><br><span class="line">// =&gt; &quot;$ 1,888.00&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-验证密码问题（TODO-Read-again）"><a href="#2-4-3-验证密码问题（TODO-Read-again）" class="headerlink" title="2.4.3. 验证密码问题（TODO Read again）"></a>2.4.3. 验证密码问题（TODO Read again）</h3><p>密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。<br>此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。<br>那么，我们就来挑战一下。看看我们对位置的理解是否深刻。<br>（(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。）</p>
<p>// 扩展： 密码中必须包含字母、数字、特称字符，至少8个字符，最多30个字符。</p>
<p><a href="https://segmentfault.com/q/1010000007500712/a-1020000007500959" target="_blank" rel="noopener">Array.apply(null, {length: 10})和Array(10)有什么区别?</a></p>
<p><a href="https://segmentfault.com/q/1010000006793990" target="_blank" rel="noopener">关于apply，Array.apply(null, {length:5})怎么理解</a></p>
<h1 id="第三章-正则表达式括号的作用"><a href="#第三章-正则表达式括号的作用" class="headerlink" title="第三章 正则表达式括号的作用"></a>第三章 正则表达式括号的作用</h1><p><strong>NOTE</strong> match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的<br>内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match<br>返回的数组格式是不一样的。</p>
<h3 id="3-2-1-提取数据"><a href="#3-2-1-提取数据" class="headerlink" title="3.2.1. 提取数据"></a>3.2.1. 提取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 提取日期</span><br><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">console.log( regex.exec(string) );  // 这里的结果一样。</span><br><span class="line">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span><br></pre></td></tr></table></figure>
<p>同时，也可以使用构造函数的全局属性 $1 至 $9 来获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">//regex.exec(string);</span><br><span class="line">//string.match(regex);</span><br><span class="line">console.log(RegExp.$1); // &quot;2017&quot;</span><br><span class="line">console.log(RegExp.$2); // &quot;06&quot;</span><br><span class="line">console.log(RegExp.$3); // &quot;12&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-2-替换"><a href="#3-2-2-替换" class="headerlink" title="3.2.2. 替换"></a>3.2.2. 替换</h3><p>比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-06-12&quot;;</span><br><span class="line">var result = string.replace(regex, &quot;$2/$3/$1&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;06/12/2017&quot;</span><br></pre></td></tr></table></figure></p>
<p>其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result = string.replace(regex, function () &#123;</span><br><span class="line">return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 也等价于</span><br><span class="line">var result = string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">return month + &quot;/&quot; + day + &quot;/&quot; + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
<h2 id="3-3-反向引用"><a href="#3-3-反向引用" class="headerlink" title="3.3. 反向引用"></a>3.3. 反向引用</h2><p>除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。(\1,\2)这类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = &quot;2017-06-12&quot;;</span><br><span class="line">var string2 = &quot;2017/06/12&quot;;</span><br><span class="line">var string3 = &quot;2017.06.12&quot;;</span><br><span class="line">var string4 = &quot;2016-06/12&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // true</span><br><span class="line">console.log( regex.test(string4) ); // false</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-1-括号嵌套怎么办？"><a href="#3-3-1-括号嵌套怎么办？" class="headerlink" title="3.3.1. 括号嵌套怎么办？"></a>3.3.1. 括号嵌套怎么办？</h3><p>以左括号（开括号）为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = &quot;1231231233&quot;;</span><br><span class="line">console.log( regex.test(string) ); // true</span><br><span class="line">console.log( RegExp.$1 ); // 123</span><br><span class="line">console.log( RegExp.$2 ); // 1</span><br><span class="line">console.log( RegExp.$3 ); // 23</span><br><span class="line">console.log( RegExp.$4 ); // 3</span><br></pre></td></tr></table></figure></p>
<p><a href="https://regexper.com/#%5E((%5Cd" target="_blank" rel="noopener">该正则图形化</a>(%5Cd(%5Cd)))%5C1%5C2%5C3%5C4%24)</p>
<p><a href="https://regex101.com/" target="_blank" rel="noopener">在线正则测试</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((\d)(\d([a-z])))\1\2\3\4$</span><br><span class="line">12a12a12aa</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-2-10-表示什么呢？"><a href="#3-3-2-10-表示什么呢？" class="headerlink" title="3.3.2. \10 表示什么呢？"></a>3.3.2. \10 表示什么呢？</h3><p>另外一个疑问可能是，即 \10 是表示第 10 个分组，还是 \1 和 0 呢？<br>答案是前者，虽然一个正则里出现 \10 比较罕见。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;</span><br><span class="line">var string = &quot;123456789# ######&quot;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p><strong>TIP</strong> 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)。</p>
<h3 id="3-3-3-引用不存在的分组会怎样？"><a href="#3-3-3-引用不存在的分组会怎样？" class="headerlink" title="3.3.3. 引用不存在的分组会怎样？"></a>3.3.3. 引用不存在的分组会怎样？</h3><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配<br>反向引用的字符本身。例如 \2，就匹配 “\2”。注意 “\2” 表示对 “2” 进行了转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(&quot;\1\2\3\4\5\6\7\8\9&quot;) );</span><br><span class="line">console.log( &quot;\1\2\3\4\5\6\7\8\9&quot;.split(&quot;&quot;) );</span><br><span class="line">// Chrome 浏览器打印的结果（不同的浏览器和版本，打印的结果可能不一样）</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-4-分组后面有量词会怎样？"><a href="#3-3-4-分组后面有量词会怎样？" class="headerlink" title="3.3.4. 分组后面有量词会怎样？"></a>3.3.4. 分组后面有量词会怎样？</h3><p>分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+/;</span><br><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p>
<p>同理对于反向引用，也是这样的。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d)+ \1/;</span><br><span class="line">console.log( regex.test(&quot;12345 1&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( regex.test(&quot;12345 5&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<h2 id="3-4-非捕获括号"><a href="#3-4-非捕获括号" class="headerlink" title="3.4. 非捕获括号"></a>3.4. 非捕获括号</h2><p>之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分<br>支。<br>如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。<br>此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)。</p>
<h2 id="3-5-相关案例"><a href="#3-5-相关案例" class="headerlink" title="3.5. 相关案例"></a>3.5. 相关案例</h2><h3 id="3-5-1-字符串-trim-方法模拟"><a href="#3-5-1-字符串-trim-方法模拟" class="headerlink" title="3.5.1. 字符串 trim 方法模拟"></a>3.5.1. 字符串 trim 方法模拟</h3><p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim(str) &#123;</span><br><span class="line">return str.replace(/^\s+|\s+$/g, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar&quot;</span><br></pre></td></tr></table></figure></p>
<p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim (str) &#123;</span><br><span class="line">return str.replace(/^\s*(.*?)\s*$/g, &quot;$1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(&quot; foobar &quot;) );</span><br><span class="line">// =&gt; &quot;foobar</span><br></pre></td></tr></table></figure></p>
<p>当然，前者效率高。</p>
<h3 id="3-5-2-将每个单词的首字母转换为大写"><a href="#3-5-2-将每个单词的首字母转换为大写" class="headerlink" title="3.5.2. 将每个单词的首字母转换为大写"></a>3.5.2. 将每个单词的首字母转换为大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unction titleize (str) &#123;</span><br><span class="line">    return str.toLowerCase().replace(/(?:^|\s)\w/g, function (c) &#123;</span><br><span class="line">        return c.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(&apos;my name is epeli&apos;) );</span><br><span class="line">// =&gt; &quot;My Name Is Epeli&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-驼峰化"><a href="#3-5-3-驼峰化" class="headerlink" title="3.5.3. 驼峰化"></a>3.5.3. 驼峰化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function camelize (str) &#123;</span><br><span class="line">    return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123;</span><br><span class="line">        return c ? c.toUpperCase() : &apos;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(&apos;-moz-transform&apos;) );</span><br><span class="line">// =&gt; &quot;MozTransform&quot;</span><br><span class="line">// 这里c不需要判断。&apos;&apos;.toUpperCase() === &apos;&apos;; // true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-中划线化"><a href="#3-5-4-中划线化" class="headerlink" title="3.5.4. 中划线化"></a>3.5.4. 中划线化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function dasherize (str) &#123;</span><br><span class="line">    return str.replace(/([A-Z])/g, &apos;-$1&apos;).replace(/[-_\s]+/g, &apos;-&apos;).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">console.log( dasherize(&apos;MozTransform&apos;) );</span><br><span class="line">// =&gt; &quot;-moz-transform&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-5-HTML-转义和反转义"><a href="#3-5-5-HTML-转义和反转义" class="headerlink" title="3.5.5. HTML 转义和反转义"></a>3.5.5. HTML 转义和反转义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 将HTML特殊字符转换成等值的实体</span><br><span class="line">function escapeHTML (str) &#123;</span><br><span class="line">    var escapeChars = &#123;</span><br><span class="line">    &apos;&lt;&apos; : &apos;lt&apos;,</span><br><span class="line">    &apos;&gt;&apos; : &apos;gt&apos;,</span><br><span class="line">    &apos;&quot;&apos; : &apos;quot&apos;,</span><br><span class="line">    &apos;&amp;&apos; : &apos;amp&apos;,</span><br><span class="line">    &apos;\&apos;&apos; : &apos;#39&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(new RegExp(&apos;[&apos; + Object.keys(escapeChars).join(&apos;&apos;) +&apos;]&apos;, &apos;g&apos;),</span><br><span class="line">    function (match) &#123;</span><br><span class="line">        return &apos;&amp;&apos; + escapeChars[match] + &apos;;&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( escapeHTML(&apos;&lt;div&gt;Blah blah blah&lt;/div&gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;;</span><br></pre></td></tr></table></figure>
<p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。<br>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 实体字符转换为等值的HTML。</span><br><span class="line">function unescapeHTML (str) &#123;</span><br><span class="line">    var htmlEntities = &#123;</span><br><span class="line">        nbsp: &apos; &apos;,</span><br><span class="line">        lt: &apos;&lt;&apos;,</span><br><span class="line">        gt: &apos;&gt;&apos;,</span><br><span class="line">        quot: &apos;&quot;&apos;,</span><br><span class="line">        amp: &apos;&amp;&apos;,</span><br><span class="line">        apos: &apos;\&apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    return str.replace(/\&amp;([^;]+);/g, function (match, key) &#123;</span><br><span class="line">        if (key in htmlEntities) &#123;</span><br><span class="line">            return htmlEntities[key];</span><br><span class="line">        &#125;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );</span><br><span class="line">// =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure></p>
<p>通过 key 获取相应的分组引用，然后作为对象的键。</p>
<h3 id="3-5-6-匹配成对标签"><a href="#3-5-6-匹配成对标签" class="headerlink" title="3.5.6. 匹配成对标签"></a>3.5.6. 匹配成对标签</h3><p>要求匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line">&lt;p&gt;laoyao bye bye&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;，<br>匹配一个闭标签，可以使用 &lt;\/[^&gt;]+&gt;，<br>但是要求匹配成对标签，那就需要使用反向引用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;</span><br><span class="line">var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;</span><br><span class="line">var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;</span><br><span class="line">console.log( regex.test(string1) ); // true</span><br><span class="line">console.log( regex.test(string2) ); // true</span><br><span class="line">console.log( regex.test(string3) ); // false</span><br></pre></td></tr></table></figure></p>
<p><strong>疑惑</strong>：为什么这里没有用.<em>匹配呢，或者说为啥没用.</em>?阻止贪婪匹配模式（惰性模式）呢</p>
<h1 id="4-第四章-正则表达式回溯法原理"><a href="#4-第四章-正则表达式回溯法原理" class="headerlink" title="4. 第四章 正则表达式回溯法原理"></a>4. 第四章 正则表达式回溯法原理</h1><p>学习正则表达式，是需要懂点儿匹配原理的。<br>而研究匹配原理时，有两个字出现的频率比较高：“回溯”。</p>
<h2 id="4-1-没有回溯的匹配"><a href="#4-1-没有回溯的匹配" class="headerlink" title="4.1. 没有回溯的匹配"></a>4.1. 没有回溯的匹配</h2><p>假设我们的正则是 /ab{1,3}c/，<br>而当目标字符串是 “abbbc” 时，就没有所谓的“回溯”。</p>
<h2 id="4-2-有回溯的匹配"><a href="#4-2-有回溯的匹配" class="headerlink" title="4.2. 有回溯的匹配"></a>4.2. 有回溯的匹配</h2><p>如果目标字符串是”abbc”，中间就有回溯。</p>
<p>图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 “b”，准备尝试第三个时，<br>结果发现接下来的字符是 “c”。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即<br>第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 “c”。当然，此时整个表达式匹配成功了。<br>图中的第 6 步，就是“回溯”。</p>
<p>再举一个例子：<br>/ab{1,3}bbc/</p>
<p>目标字符串是”abbbc”，匹配过程是：<br>/“.*”/<br>目标字符串是：”abc”de，</p>
<p>图中省略了尝试匹配双引号失败的过程。可以看出 .<em> 是非常影响效率的。<br>为了减少一些不必要的回溯，可以把正则修改为 /“[^”]</em>“/。</p>
<h2 id="4-3-常见的回溯形式"><a href="#4-3-常见的回溯形式" class="headerlink" title="4.3. 常见的回溯形式"></a>4.3. 常见的回溯形式</h2><p>正则表达式匹配字符串的这种方式，有个学名，叫<strong>回溯法</strong>。</p>
<p>本质上就是<strong>深度优先搜索算法</strong>。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中<br>，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。<br>道理，我们是懂了。<strong>那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？</strong></p>
<h3 id="4-3-1-贪婪量词"><a href="#4-3-1-贪婪量词" class="headerlink" title="4.3.1 贪婪量词"></a>4.3.1 贪婪量词</h3><p>之前的例子都是贪婪量词相关的。</p>
<p>此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？<br>答案是，先下手为强！因为深度优先搜索。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">var regex = /(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-2-惰性量词"><a href="#4-3-2-惰性量词" class="headerlink" title="4.3.2 惰性量词"></a>4.3.2 惰性量词</h3><p>虽然惰性量词不贪，但也会有回溯的现象。<br>比如正则式：/^\d{1,3}?\d{1,3}$/<br>目标字符串是 “12345”。</p>
<p>知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \d{1,3}? 匹配的字<br>符是 “12”，是两个数字，而不是一个。</p>
<h3 id="4-3-3-分支结构"><a href="#4-3-3-分支结构" class="headerlink" title="4.3.3 分支结构"></a>4.3.3 分支结构</h3><p>我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 “candy”，得到的结果是 “can”，因为分支会<br>一个一个尝试，如果前面的满足了，后面就不会再试验了。<br>分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分<br>支。这种尝试也可以看成一种回溯。</p>
<p>比如：/^(?:can|candy)$/ 目标字符串是’candy’</p>
<p>上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是<br>一种回溯的。</p>
<h2 id="4-4-本章小结"><a href="#4-4-本章小结" class="headerlink" title="4.4. 本章小结"></a>4.4. 本章小结</h2><p>其实回溯法，很容易掌握的。<br>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最<br>后都试完后，发现整体匹配不成功。</p>
<blockquote>
<p>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。<br>• 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。<br>• 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。<br>既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动<br>机”的简写。<br>而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。<br>大部分语言中的正则都是 NFA，为啥它这么流行呢？<br>答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。</p>
</blockquote>
<h1 id="5-第五章-正则表达式的拆分"><a href="#5-第五章-正则表达式的拆分" class="headerlink" title="5. 第五章 正则表达式的拆分"></a>5. 第五章 正则表达式的拆分</h1><h2 id="5-1-结构和操作符"><a href="#5-1-结构和操作符" class="headerlink" title="5.1. 结构和操作符"></a>5.1. 结构和操作符</h2><p>JavaScript 正则表达式中，都有哪些结构呢？<br>字符字面量、字符组、量词、锚、分组、选择分支、反向引用。</p>
<p><strong>其中涉及到的操作符有：</strong><br>操作符描述 操作符 优先级<br>转义符  \  1<br>括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2<br>量词限定符 {m}、{m,n}、{m,}、?、*、+ 3<br>位置和序列 ^、$、\元字符、一般字符 4<br>管道符（竖杠） | 5</p>
<h2 id="5-2-注意要点"><a href="#5-2-注意要点" class="headerlink" title="5.2. 注意要点"></a>5.2. 注意要点</h2><h3 id="5-2-1-匹配字符串整体问题"><a href="#5-2-1-匹配字符串整体问题" class="headerlink" title="5.2.1 匹配字符串整体问题"></a>5.2.1 匹配字符串整体问题</h3><p>比如要匹配目标字符串 “abc” 或者 “bcd” 时，如果一不小心，就会写成 /^abc|bcd$/。<br>而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是。</p>
<p>开始-abc<br>bcd-结束<br>应该是：<br>/^(abc|bcd)$/</p>
<h3 id="5-2-2-量词连缀问题"><a href="#5-2-2-量词连缀问题" class="headerlink" title="5.2.2 量词连缀问题"></a>5.2.2 量词连缀问题</h3><ol>
<li>每个字符为 “a、”b”、”c” 任选其一，</li>
<li>字符串的长度是 3 的倍数。<br><code>/^[abc]{3}+$/</code>，这样会报错，说 + 前面没什么可重复的。<br>应该为：<br>/([abc]{3})+/</li>
</ol>
<h3 id="5-2-3-元字符转义问题"><a href="#5-2-3-元字符转义问题" class="headerlink" title="5.2.3 元字符转义问题"></a>5.2.3 元字符转义问题</h3><p>所谓元字符，就是正则中有特殊含义的字符。<br>所有结构里，用到的元字符总结如下：<br>^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,<br>当匹配上面的字符本身时，可以一律转义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,/;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>其中 string 中的 \ 字符也要转义的。<br>另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var string2 = &quot;\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,&quot;;</span><br><span class="line">console.log( string == string2 );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>现在的问题是，是不是每个字符都需要转义呢？否，看情况。</p>
<h4 id="5-2-3-1-字符组中的元字符"><a href="#5-2-3-1-字符组中的元字符" class="headerlink" title="5.2.3.1. 字符组中的元字符"></a>5.2.3.1. 字符组中的元字符</h4><p>跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然<br>会把整个字符组，看成反义字符组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</span><br><span class="line">var regex = /[\^$.*+?|\\/\[\]&#123;&#125;=!:\-,]/g;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;,</span><br><span class="line">&quot;-&quot;, &quot;,&quot;]</span><br></pre></td></tr></table></figure></p>
<h4 id="5-2-3-2-匹配-“-abc-”-和-“-3-5-”"><a href="#5-2-3-2-匹配-“-abc-”-和-“-3-5-”" class="headerlink" title="5.2.3.2. 匹配 “[abc]” 和 “{3,5}”"></a>5.2.3.2. 匹配 “[abc]” 和 “{3,5}”</h4><p>我们知道 [abc]，是个字符组。如果要匹配字符串 “[abc]” 时，该怎么办？<br>可以写成 /[abc]/，也可以写成 /[abc]/<br>只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。</p>
<p>同理，要匹配字符串 “{3,5}”，只需要把正则写成 /{3,5}/ 即可。<br>另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报<br>错。当然，匹配的字符串也是 “{,n}”，测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;&#123;,3&#125;&quot;;</span><br><span class="line">var regex = /&#123;,3&#125;/g;</span><br><span class="line">console.log( string.match(regex)[0] );</span><br><span class="line">// =&gt; &quot;&#123;,3&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-2-3-3-其余情况"><a href="#5-2-3-3-其余情况" class="headerlink" title="5.2.3.3. 其余情况"></a>5.2.3.3. 其余情况</h4><p>比如 =、!、:、-、, 等符号，只要不在特殊结构中，并不需要转义。<br>但是，括号需要前后都转义的，如 /(123)/。<br>至于剩下的 ^、$、.、*、+、?、|、\、/ 等字符，只要不在字符组内，都需要转义的。</p>
<h2 id="5-3-案例分析"><a href="#5-3-案例分析" class="headerlink" title="5.3. 案例分析"></a>5.3. 案例分析</h2><h3 id="5-3-1-身份证"><a href="#5-3-1-身份证" class="headerlink" title="5.3.1 身份证"></a>5.3.1 身份证</h3><p>正则表达式是：<br>/^(\d{15}|\d{17}[\dxX])$/</p>
<h3 id="5-3-2-IPV4-地址"><a href="#5-3-2-IPV4-地址" class="headerlink" title="5.3.2 IPV4 地址"></a>5.3.2 IPV4 地址</h3><p>正则表达式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^((0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.)&#123;3&#125;(0&#123;0,2&#125;\d|0?\d&#123;2&#125;|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/</span><br></pre></td></tr></table></figure></p>
<p>这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：<br>((…).){3}(…)<br>其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是<br>3位数.3位数.3位数.3位数<br>然后再来分析 (…)：<br>(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])</p>
<h1 id="6-第六章-正则表达式的构建"><a href="#6-第六章-正则表达式的构建" class="headerlink" title="6. 第六章 正则表达式的构建"></a>6. 第六章 正则表达式的构建</h1><h2 id="6-1-平衡法则"><a href="#6-1-平衡法则" class="headerlink" title="6.1. 平衡法则"></a>6.1. 平衡法则</h2><p>构建正则有一点非常重要，需要做到下面几点的平衡：<br>1.• 匹配预期的字符串<br>2.• 不匹配非预期的字符串<br>3.• 可读性和可维护性<br>4.• 效率</p>
<h2 id="6-2-构建正则前提"><a href="#6-2-构建正则前提" class="headerlink" title="6.2. 构建正则前提"></a>6.2. 构建正则前提</h2><p>比如匹配这样的字符串：1010010001…。<br>虽然很有规律，但是只靠正则就是无能为力。</p>
<h3 id="6-2-2-是否有必要使用正则？"><a href="#6-2-2-是否有必要使用正则？" class="headerlink" title="6.2.2. 是否有必要使用正则？"></a>6.2.2. 是否有必要使用正则？</h3><p>要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。<strong>能用字符串 API 解决的简单问题，就不该正则出马。</strong></p>
<p>比如，从日期中提取出年月日，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var regex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">console.log( string.match(regex) );</span><br><span class="line">// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;]</span><br></pre></td></tr></table></figure></p>
<p>其实，可以使用字符串的 split 方法来做，即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017-07-01&quot;;</span><br><span class="line">var result = string.split(&quot;-&quot;);</span><br><span class="line">console.log( result );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]</span><br></pre></td></tr></table></figure></p>
<p>比如，判断是否有问号，虽然可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.search(/\?/) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>其实，可以使用字符串的 indexOf 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;?id=xx&amp;act=search&quot;;</span><br><span class="line">console.log( string.indexOf(&quot;?&quot;) );</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>比如获取子串，虽然可以使用正则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.match(/.&#123;4&#125;(.+)/)[1] );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p>
<p>其实，可以直接使用字符串的 substring 或 substr 方法（语言精粹中推荐使用slice,substr是在ES5规范附则里。）来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;JavaScript&quot;;</span><br><span class="line">console.log( string.substring(4) );</span><br><span class="line">// =&gt; Script</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-3-是否有必要构建一个复杂的正则？"><a href="#6-2-3-是否有必要构建一个复杂的正则？" class="headerlink" title="6.2.3. 是否有必要构建一个复杂的正则？"></a>6.2.3. 是否有必要构建一个复杂的正则？</h3><p>6.2.3. 是否有必要构建一个复杂的正则？<br>比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字<br>符。<br>在第2章里，我们写出了正则是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">其实可以使用多个小正则来做：</span><br><span class="line">var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;</span><br><span class="line">var regex2 = /^[0-9]&#123;6,12&#125;$/;</span><br><span class="line">var regex3 = /^[A-Z]&#123;6,12&#125;$/;</span><br><span class="line">var regex4 = /^[a-z]&#123;6,12&#125;$/;</span><br><span class="line">function checkPassword (string) &#123;</span><br><span class="line">    if (!regex1.test(string)) return false;</span><br><span class="line">    if (regex2.test(string)) return false;</span><br><span class="line">    if (regex3.test(string)) return false;</span><br><span class="line">    if (regex4.test(string)) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-准确性"><a href="#6-3-准确性" class="headerlink" title="6.3. 准确性"></a>6.3. 准确性</h2><p>所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。<br>这里提到了“预期”二字，那么我们就需要知道目标的组成规则。</p>
<h3 id="6-3-1-匹配固定电话"><a href="#6-3-1-匹配固定电话" class="headerlink" title="6.3.1. 匹配固定电话"></a>6.3.1. 匹配固定电话</h3><p>比如要匹配如下格式的固定电话号码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">055188888888</span><br><span class="line">0551-88888888</span><br><span class="line">(0551)88888888</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(0\d&#123;2,3&#125;-?|\(0\d&#123;2,3&#125;\))[1-9]\d&#123;6,7&#125;$/</span><br></pre></td></tr></table></figure>
<p>这就是一个平衡取舍问题，一般够用就行。</p>
<h3 id="6-3-2-匹配浮点数"><a href="#6-3-2-匹配浮点数" class="headerlink" title="6.3.2. 匹配浮点数"></a>6.3.2. 匹配浮点数</h3><p>要求匹配如下的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.23、+1.23、-1.23</span><br><span class="line">10、+10、-10</span><br><span class="line">.2、+.2、-.2</span><br></pre></td></tr></table></figure></p>
<p>上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：<br>/^[+-]?(\d+)?(.\d+)?$/<br>此正则看似没问题，但这个正则也会匹配空字符 “”。<br>因为目标字符串的形式关系不是要求每部分都是可选的。<br>/^[+-]?(\d+.\d+|\d+|.\d+)$/</p>
<h2 id="6-4-效率"><a href="#6-4-效率" class="headerlink" title="6.4. 效率"></a>6.4. 效率</h2><p>保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正<br>则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。<br>正则表达式的运行分为如下的阶段：</p>
<p>• 1. 编译；<br>• 2. 设定起始位置；<br>• 3. 尝试匹配；<br>• 4. 匹配失败的话，从下一位开始继续第 3 步；<br>• 5. 最终结果：匹配成功或失败</p>
<p>当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。<br>但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。</p>
<h3 id="6-4-1-使用具体型字符组来代替通配符，来消除回溯"><a href="#6-4-1-使用具体型字符组来代替通配符，来消除回溯" class="headerlink" title="6.4.1. 使用具体型字符组来代替通配符，来消除回溯"></a>6.4.1. 使用具体型字符组来代替通配符，来消除回溯</h3><p>而在第三阶段，最大的问题就是回溯。<br>因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。</p>
<h3 id="6-4-2-使用非捕获型分组"><a href="#6-4-2-使用非捕获型分组" class="headerlink" title="6.4.2. 使用非捕获型分组"></a>6.4.2. 使用非捕获型分组</h3><p>因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。<br>当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。</p>
<h3 id="6-4-3-独立出确定字符"><a href="#6-4-3-独立出确定字符" class="headerlink" title="6.4.3. 独立出确定字符"></a>6.4.3. 独立出确定字符</h3><p>例如，/a+/ 可以修改成 /aa*/。</p>
<h3 id="6-4-4-提取分支公共部分"><a href="#6-4-4-提取分支公共部分" class="headerlink" title="6.4.4. 提取分支公共部分"></a>6.4.4. 提取分支公共部分</h3><p>比如，<code>/^abc|^def/</code> 修改成 <code>/^(?:abc|def)/</code>。<br>又比如， /this|that/修改成 /th(?:is|at)/。<br>这样做，可以减少匹配过程中可消除的重复。</p>
<h3 id="6-4-5-减少分支的数量，缩小它们的范围"><a href="#6-4-5-减少分支的数量，缩小它们的范围" class="headerlink" title="6.4.5. 减少分支的数量，缩小它们的范围"></a>6.4.5. 减少分支的数量，缩小它们的范围</h3><p>/red|read/ 可以修改成 /rea?d/。<br>此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。</p>
<h1 id="7-第七章-正则表达式编程"><a href="#7-第七章-正则表达式编程" class="headerlink" title="7. 第七章 正则表达式编程"></a>7. 第七章 正则表达式编程</h1><h2 id="7-1-正则表达式的四种操作"><a href="#7-1-正则表达式的四种操作" class="headerlink" title="7.1. 正则表达式的四种操作"></a>7.1. 正则表达式的四种操作</h2><p>正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。<br>有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。</p>
<h3 id="7-1-1-验证"><a href="#7-1-1-验证" class="headerlink" title="7.1.1. 验证"></a>7.1.1. 验证</h3><p>比如，判断一个字符串中是否有数字。<br>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!~string.search(regex) );</span><br><span class="line">// ~0 === -1</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( regex.test(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure>
<p>使用 match：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!string.match(regex) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>使用 exec：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d/;</span><br><span class="line">var string = &quot;abc123&quot;;</span><br><span class="line">console.log( !!regex.exec(string) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<p>其中，最常用的是 test。</p>
<h3 id="7-1-2-切分"><a href="#7-1-2-切分" class="headerlink" title="7.1.2. 切分"></a>7.1.2. 切分</h3><p>匹配上了，我们就可以进行一些操作，比如切分。<br>所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。</p>
<h3 id="7-1-3-提取"><a href="#7-1-3-提取" class="headerlink" title="7.1.3. 提取"></a>7.1.3. 提取</h3><p>虽然整体匹配上了，但有时需要提取部分匹配的数据。<br>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。<br>这里，还是以日期为例，提取出年月日。注意下面正则中的括号：<br>使用 match：<br>使用 exec：<br>使用 test：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">regex.test(string);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用 search：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">string.search(regex);</span><br><span class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</span><br><span class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用 replace：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</span><br><span class="line">var string = &quot;2017-06-26&quot;;</span><br><span class="line">var date = [];</span><br><span class="line">string.replace(regex, function (match, year, month, day) &#123;</span><br><span class="line">date.push(year, month, day);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(date);</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span><br></pre></td></tr></table></figure></p>
<p>其中，最常用的是 match。</p>
<h3 id="7-1-4-替换"><a href="#7-1-4-替换" class="headerlink" title="7.1.4. 替换"></a>7.1.4. 替换</h3><p>找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。</p>
<h2 id="7-2-相关-API-注意要点"><a href="#7-2-相关-API-注意要点" class="headerlink" title="7.2. 相关 API 注意要点"></a>7.2. 相关 API 注意要点</h2><p>从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String#search</span><br><span class="line">String#split</span><br><span class="line">String#match</span><br><span class="line">String#replace</span><br><span class="line">RegExp#test</span><br><span class="line">RegExp#exec</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-1-search-和-match-的参数问题"><a href="#7-2-1-search-和-match-的参数问题" class="headerlink" title="7.2.1. search 和 match 的参数问题"></a>7.2.1. search 和 match 的参数问题</h3><p>我们知道字符串实例的那 4 个方法参数都支持正则和字符串。<br>但 search 和 match，会把字符串转换为正则的。<br>replace和split不会。</p>
<h3 id="7-2-2-match-返回结果的格式问题"><a href="#7-2-2-match-返回结果的格式问题" class="headerlink" title="7.2.2. match 返回结果的格式问题"></a>7.2.2. match 返回结果的格式问题</h3><p>match 返回结果的格式，与正则对象是否有修饰符 g 有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017.06.27&quot;;</span><br><span class="line">var regex1 = /\b(\d+)\b/;</span><br><span class="line">var regex2 = /\b(\d+)\b/g;</span><br><span class="line">console.log( string.match(regex1) );</span><br><span class="line">console.log( string.match(regex2) );</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;]</span><br></pre></td></tr></table></figure></p>
<p>没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然<br>后是整体匹配的第一个下标，最后是输入的目标字符串。<br>有 g，返回的是所有匹配的内容。<br>当没有匹配时，不管有无 g，都返回 null。</p>
<h3 id="7-2-3-exec-比-match-更强大"><a href="#7-2-3-exec-比-match-更强大" class="headerlink" title="7.2.3. exec 比 match 更强大"></a>7.2.3. exec 比 match 更强大</h3><p>当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。<br>而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配：<br>其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。<br>比如第一次匹配了 “2017”，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配<br>的位置是 4。<br>从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环：</p>
<h3 id="7-2-4-修饰符-g，对-exex-和-test-的影响"><a href="#7-2-4-修饰符-g，对-exex-和-test-的影响" class="headerlink" title="7.2.4. 修饰符 g，对 exex 和 test 的影响"></a>7.2.4. 修饰符 g，对 exex 和 test 的影响</h3><p>上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。<br><strong>字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。</strong><br>而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。</p>
<h3 id="7-2-5-test-整体匹配时需要使用-和"><a href="#7-2-5-test-整体匹配时需要使用-和" class="headerlink" title="7.2.5. test 整体匹配时需要使用 ^ 和 $"></a>7.2.5. test 整体匹配时需要使用 ^ 和 $</h3><p>这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。<br>如果，要整体匹配，正则前后需要添加开头和结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log( /123/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; true</span><br><span class="line">console.log( /^123$/.test(&quot;a123b&quot;) );</span><br><span class="line">// =&gt; false</span><br><span class="line">console.log( /^123$/.test(&quot;123&quot;) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-6-split-相关注意事项"><a href="#7-2-6-split-相关注意事项" class="headerlink" title="7.2.6. split 相关注意事项"></a>7.2.6. split 相关注意事项</h3><p>split 方法看起来不起眼，但要注意的地方有两个的。<br>第一，它可以有第二个参数，表示结果数组的最大长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/,/, 2) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;css&quot;]</span><br></pre></td></tr></table></figure></p>
<p>第二，正则使用分组时，结果数组中是包含分隔符的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;html,css,javascript&quot;;</span><br><span class="line">console.log( string.split(/(,)/) );</span><br><span class="line">// =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-7-replace-是很强大的"><a href="#7-2-7-replace-是很强大的" class="headerlink" title="7.2.7. replace 是很强大的"></a>7.2.7. replace 是很强大的</h3><p>《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。<br>因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。<br>总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。<br>当第二个参数是字符串时，如下的字符有特殊的含义：</p>
<p><pre><br>属性 描述<br>$1,$2,…,$99 匹配第 1-99 个 分组里捕获的文本<br>$&amp; 匹配到的子串文本<br>$` 匹配到的子串的左边文本<br>$’ 匹配到的子串的右边文本<br>$$ 美元符号<br>记忆中语言精粹中有列举更多。<br></pre><br>再例如，把 “2+3=5”，变成 “2+3=2+3=5=5”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);</span><br><span class="line">console.log(result);</span><br><span class="line">// =&gt; &quot;2+3=2+3=5=5</span><br></pre></td></tr></table></figure></p>
<p>我们对最后这个进行一下说明。要把 “2+3=5”，变成 “2+3=2+3=5=5”，其实就是想办法把 = 替换成<br>=2+3=5=，其中，$&amp; 匹配的是 =， $<code>匹配的是 2+3，$&#39; 匹配的是 5。因此使用 &quot;$&amp;$</code>$&amp;$’$&amp;” 便达成了<br>目的。<br>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;1234 2345 3456&quot;.replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123;</span><br><span class="line">console.log([match, $1, $2, index, input]);</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]</span><br><span class="line">// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;]</span><br></pre></td></tr></table></figure></p>
<p>此时我们可以看到 replace 拿到的信息，并不比 exec 少。</p>
<h3 id="7-2-8-使用构造函数需要注意的问题"><a href="#7-2-8-使用构造函数需要注意的问题" class="headerlink" title="7.2.8. 使用构造函数需要注意的问题"></a>7.2.8. 使用构造函数需要注意的问题</h3><p>一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 <code>\</code>。</p>
<h3 id="7-2-9-修饰符"><a href="#7-2-9-修饰符" class="headerlink" title="7.2.9. 修饰符"></a>7.2.9. 修饰符</h3><p><code>ES5</code> 中修饰符，共 3 个：g,i,m<br>当然正则对象也有相应的只读属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\w/img;</span><br><span class="line">console.log( regex.global );</span><br><span class="line">console.log( regex.ignoreCase );</span><br><span class="line">console.log( regex.multiline );</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-10-source-属性"><a href="#7-2-10-source-属性" class="headerlink" title="7.2.10. source 属性"></a>7.2.10. source 属性</h3><p>正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source<br>属性。<br>它什么时候有用呢？<br>比如，<strong>在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var className = &quot;high&quot;;</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">console.log( regex.source )</span><br><span class="line">// =&gt; (^|\s)high(\s|$) 即字符串&quot;(^|\\s)high(\\s|$)&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-11-构造函数属性"><a href="#7-2-11-构造函数属性" class="headerlink" title="7.2.11. 构造函数属性"></a>7.2.11. 构造函数属性</h3><p>构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的<br>属性（有兼容性问题）：</p>
<p><pre><br>静态属性 描述 简写形式<br>RegExp.input 最近一次目标字符串 RegExp[“$_”]<br>RegExp.lastMatch 最近一次匹配的文本 RegExp[“$&amp;”]<br>RegExp.lastParen 最近一次捕获的文本 RegExp[“$+”]<br>RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”]<br>RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[“$’”]<br></pre></p>
<h2 id="7-3-真实案例"><a href="#7-3-真实案例" class="headerlink" title="7.3. 真实案例"></a>7.3. 真实案例</h2><h3 id="7-3-1-使用构造函数生成正则表达式"><a href="#7-3-1-使用构造函数生成正则表达式" class="headerlink" title="7.3.1. 使用构造函数生成正则表达式"></a>7.3.1. 使用构造函数生成正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3333&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function getElementsByClassName (className) &#123;</span><br><span class="line">var elements = document.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var i = 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">var element = elements[i];</span><br><span class="line">if (regex.test(element.className)) &#123;</span><br><span class="line">result.push(element)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">var highs = getElementsByClassName(&apos;high&apos;);</span><br><span class="line">highs.forEach(function (item) &#123;</span><br><span class="line">item.style.color = &apos;red&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-2-使用字符串保存数据"><a href="#7-3-2-使用字符串保存数据" class="headerlink" title="7.3.2. 使用字符串保存数据"></a>7.3.2. 使用字符串保存数据</h3><p>一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。<br>使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var utils = &#123;&#125;;</span><br><span class="line">&quot;Boolean|Number|String|Function|Array|Date|RegExp|Object|Error&quot;.split(&quot;|&quot;).forEach(fun</span><br><span class="line">ction (item) &#123;</span><br><span class="line">utils[&quot;is&quot; + item] = function (obj) &#123;</span><br><span class="line">return &#123;&#125;.toString.call(obj) == &quot;[object &quot; + item + &quot;]&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log( utils.isArray([1, 2, 3]) );</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-3-if-语句中使用正则替代-amp-amp"><a href="#7-3-3-if-语句中使用正则替代-amp-amp" class="headerlink" title="7.3.3. if 语句中使用正则替代 &amp;&amp;"></a>7.3.3. if 语句中使用正则替代 &amp;&amp;</h3><p>比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var readyRE = /complete|loaded|interactive/;</span><br><span class="line">function ready (callback) &#123;</span><br><span class="line">if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">document.addEventListener(</span><br><span class="line">&apos;DOMContentLoaded&apos;,</span><br><span class="line">function () &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;,</span><br><span class="line">false</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ready(function () &#123;</span><br><span class="line">alert(&quot;加载完毕！&quot;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-4-使用强大的-replace"><a href="#7-3-4-使用强大的-replace" class="headerlink" title="7.3.4. 使用强大的 replace"></a>7.3.4. 使用强大的 replace</h3><p>因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。<br>这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何<br>东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function compress (source) &#123;</span><br><span class="line">var keys = &#123;&#125;;</span><br><span class="line">source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123;</span><br><span class="line">keys[key] = (keys[key] ? keys[key] + &apos;,&apos; : &apos;&apos;) + value;</span><br><span class="line">&#125;);</span><br><span class="line">var result = [];</span><br><span class="line">for (var key in keys) &#123;</span><br><span class="line">result.push(key + &apos;=&apos; + keys[key]);</span><br><span class="line">&#125;</span><br><span class="line">return result.join(&apos;&amp;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;) );</span><br><span class="line">// =&gt; &quot;a=1,3&amp;b=2,4&quot;</span><br></pre></td></tr></table></figure></p>
<p>完。<br>84/89</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-10-21T15:52:11.461Z" itemprop="dateUpdated">2017-10-21 23:52:11</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/10/12/20171012-JavaScript regex mini books reading record/" target="_blank" rel="external">https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/</a>
        
    </div>
    
    <footer>
        <a href="https://lxchuan12.github.io">
            <img src="/img/logo.jpg" alt="轩辕Rowboat">
            轩辕Rowboat
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&title=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&pic=https://lxchuan12.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&title=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&source=轩辕Rowboat，某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以轩辕Rowboat为名混..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&via=https://lxchuan12.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/10/26/20171026-you don't know js-1/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">你不知道的JavaScript上卷-读书笔记 - 未完待续...不用点开了~</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/09/21/20170921-github tips/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">github使用小技巧</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "0TKTK966CPwc1sozltNJnPwi-gzGzoHsz",
            appKey: "pqWw70koe6UNqnGfrPBLgPCO",
            avatar: "mm",
            placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        如果对您有启发和帮助，可以随意赞赏呢~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
        <p>
            <span>轩辕Rowboat &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
    <div class="bottom" style="display: none">
        <p><span>轩辕Rowboat &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&title=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&pic=https://lxchuan12.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&title=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&source=轩辕Rowboat，某世界闻名的陶瓷大学2016届毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以轩辕Rowboat为名混..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript正则表达式迷你书-阅读笔记》 — 轩辕Rowboat的博客&url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/&via=https://lxchuan12.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://lxchuan12.github.io/2017/10/12/20171012-JavaScript regex mini books reading record/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1273798602&web_id=1273798602');
// lazyScripts.push('//cdnjs.cloudflare.com/ajax/libs/platform/1.3.5/platform.min.js');

</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)Good Bye！';
            clearTimeout(titleTime);
        } else {
            document.title = 'Hi~Welcome back!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
